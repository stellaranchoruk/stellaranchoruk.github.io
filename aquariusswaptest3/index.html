<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mirrasets ‚Äî AQUAm25 Locker + Aquarius AMM Router Swap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Freighter API (UMD) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/stellar-freighter-api/5.0.0/index.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <!-- Self-hosted Stellar SDK (UMD v14.3.0) ‚Äî includes Soroban (SDK.rpc) -->
  <script src="/sdk/stellar-sdk-14.3.0.min.js?v=8"></script>

  <style>
    :root { --bg:#0b0f12; --panel:#12181d; --ink:#e8f0f6; --muted:#94a3ad; --accent:#4fd1c5; --err:#ff6b6b; --ok:#57d29a; --border:#1c242c; }
    * { box-sizing: border-box; }
    html,body { margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    .wrap{max-width:980px;margin:28px auto;padding:0 16px}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:22px}
    h1{margin:0 0 10px;font-size:20px;letter-spacing:.3px}
    h2{margin:18px 0 8px}
    p{margin:.25rem 0 .75rem;opacity:.96}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .small{font-size:12px;opacity:.8}
    .muted{color:var(--muted)}
    button{cursor:pointer;font-weight:600;border-radius:10px;border:1px solid #21464f;background:#0c1c20;color:#d9f6ff;padding:10px 14px;transition:.15s}
    button:hover{filter:brightness(1.08)}
    button.ghost{background:#141b22;border-color:#2a3340}
    button:disabled{opacity:.5;cursor:not-allowed}
    input,textarea,select{width:100%;padding:12px;border-radius:10px;border:1px solid #1e2831;background:#0e1419;color:#fff}
    input[readonly]{opacity:.9;background:#0b1115;border-style:dashed}
    label{display:block;margin:10px 0 6px;font-size:12px;color:var(--muted)}
    .section{margin-top:20px;padding-top:14px;border-top:1px dashed #1a232c}
    .box{background:#0e1620;border:1px solid #1c2430;border-radius:12px;padding:14px}
    .pct{display:flex;gap:8px;margin-top:6px}
    .pct button{flex:1;background:#141b22;border:1px solid #2a3340}
    .toggle-row{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .code{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; padding:10px; background:#0b1115; border:1px dashed #20303a; border-radius:8px; overflow:auto;}
    .chip{display:inline-flex;align-items:center;gap:8px;border:1px solid #2a3340;background:#141b22;border-radius:999px;padding:6px 10px;font-size:12px}
    .label-row{display:flex;align-items:center;justify-content:space-between;gap:8px}
    .linkish{border:none;background:transparent;color:#9ab0ff;text-decoration:underline;padding:0;cursor:pointer}
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width:880px){ .grid { grid-template-columns: 1fr 1fr; } }
    .pill { display:inline-flex; align-items:center; gap:8px; font-size:12px; padding:6px 10px; border-radius:999px; background:#0e151a; border:1px solid #1e2831; }
    .pill.ok { border-color:#234b3b; color:var(--ok); }
    .pill.warn { border-color:#4a2a2a; color:var(--err); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    /* Modal (WalletConnect) */
    .backdrop{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none}
    .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center}
    .open{display:flex}
    .modal-inner{width:min(560px,92vw);background:#0e1627;border:1px solid #22315c;border-radius:16px;padding:22px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .x{background:none;border:none;color:var(--muted);font-size:22px;line-height:1;cursor:pointer}
    .wallet-btn{width:100%;padding:14px 16px;display:flex;align-items:center;justify-content:center;gap:10px;margin-top:10px}
    .qr-wrap{display:flex;flex-direction:column;align-items:center;gap:12px;margin-top:12px}
    .wallet-choices{display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
    .wallet-choices button{background:#162554;border:1px solid #344a8a}
    a.link{color:#9ab0ff;text-decoration:underline}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <h1>AQUAm25 Interest Locker + Aquarius AMM Swap</h1>
        <div class="row">
          <button id="connectBtn">Connect Wallet</button>
          <button id="disconnectBtn" class="ghost" disabled>Disconnect</button>
          <span id="status" class="muted" aria-live="polite">Not connected</span>
        </div>
      </div>

      <!-- Swap (Aquarius AMM Router) -->
      <div class="section box" id="swapBox">
        <h2>Swap (Aquarius AMM Router)</h2>
        <p class="small">Swap any Stellar token you hold into <b>AQUAm25</b> via Aquarius AMMs (multi-hop). Type either how much you‚Äôll <b>send</b> or how much AQUAm25 you want to <b>receive</b>. If you don‚Äôt have an AQUAm25 trustline yet, add it first (uses ~1 XLM reserve).</p>

        <!-- Mode -->
        <div class="row" style="gap:10px;margin:4px 0 8px;">
          <button class="ghost" id="btnModeSend" style="border-color:#2a6f7c;background:#0c3137;color:#d9f6ff">Strict-Send (fix input)</button>
          <button class="ghost" id="btnModeRecv">Strict-Receive (fix output)</button>
          <span class="pill">Router: <span class="mono">CBQ‚Ä¶QUK</span></span>
          <span class="pill">Network: <span class="mono">Mainnet</span></span>
        </div>

        <!-- Row 1: From & Amount -->
        <div class="row" style="gap:14px">
          <div style="flex:1;min-width:260px">
            <label for="swapFrom" style="margin-bottom:0">From</label>
            <select id="swapFrom"></select>
          </div>

          <div style="width:260px;max-width:100%">
            <div class="label-row">
              <label for="swapAmount" style="margin-bottom:0">Amount to send</label>
              <button id="fillMaxBtn" class="chip linkish" title="Autofill your spendable balance" style="display:none">
                Balance: <span id="selectedBal">0</span>
              </button>
            </div>
            <input id="swapAmount" type="number" step="any" placeholder="0.0" inputmode="decimal" />
          </div>
        </div>

        <!-- XLM spendable breakdown -->
        <div id="xlmBreak" class="small" style="margin-top:8px;display:none"></div>

        <!-- Row 2: To & Estimated -->
        <div class="row" style="gap:14px;margin-top:6px">
          <div style="flex:1;min-width:260px">
            <label>To</label>
            <div class="mono small" style="padding:10px 12px;border:1px solid #1e2831;border-radius:10px;background:#0e1419">
              AQUAm25<br/>
              <span id="toIssuerMeta" style="opacity:.8">Loading issuer domain‚Ä¶</span>
            </div>
          </div>
          <div style="width:260px">
            <label for="swapEst">Receive (AQUAm25)</label>
            <input id="swapEst" type="number" step="any" placeholder="0.0" inputmode="decimal" />
          </div>
        </div>

        <!-- Actions -->
        <div class="row" style="gap:10px;margin-top:10px">
          <button id="btnValidate" class="ghost">Validate Tokens & Trustline</button>
          <button id="btnQuote" class="ghost">Quote via Aquarius</button>
          <button id="swapSignSubmit">Sign &amp; Submit</button>
          <button id="swapCopy" class="ghost">Copy XDR</button>
          <button id="btnAddTrustline" class="ghost">Add AQUAm25 Trustline</button>
        </div>

        <p class="small" id="swapQuote" style="margin-top:6px" aria-live="polite"></p>
        <!-- NEW: visible route line -->
        <p class="small mono" id="routeLine" style="margin-top:4px;opacity:.9"></p>

        <div class="toggle-row" style="margin-top:10px">
          <label for="xdrSwap" style="margin:0">Swap Transaction XDR (Soroban)</label>
          <button id="toggleSwapXdr" class="linkish small">Reveal XDR</button>
        </div>
        <textarea id="xdrSwap" rows="6" placeholder="Prepared or signed swap XDR appears here" readonly style="display:none"></textarea>

        <p id="swapResult" class="small" style="margin-top:6px" aria-live="polite"></p>

        <!-- Dev readouts -->
        <div class="section">
          <div class="row" style="gap:10px;margin-bottom:6px">
            <span class="muted">Soroban Contract IDs (SAC)</span>
            <button class="ghost small" id="copyContracts">Copy</button>
          </div>
          <div class="code" id="contractsBox">‚Äî</div>

          <div class="row" style="gap:10px;margin:10px 0 6px">
            <span class="muted">Validation</span>
          </div>
          <div id="validationBox" class="small">‚Äî</div>

          <div class="row" style="gap:10px;margin:10px 0 6px">
            <span class="muted">Quote / Route</span>
            <button class="ghost small" id="copyQuote">Copy</button>
          </div>
          <div class="code" id="quoteBox">‚Äî</div>
        </div>
      </div>

      <!-- Locker -->
      <div class="section box" id="lockerBox">
        <h2>Locker</h2>

        <label for="pubkey">Public Key</label>
        <input id="pubkey" placeholder="G‚Ä¶ (manual entry allowed if not connected)" />

        <p class="small">AQUAm25 Balance: <b id="aquaBal">-</b></p>

        <label for="amount">AQUAm25 Amount</label>
        <input id="amount" type="number" step="any" placeholder="Amount to lock" inputmode="decimal" />
        <div class="pct">
          <button data-pct="25">25%</button>
          <button data-pct="50">50%</button>
          <button data-pct="75">75%</button>
          <button data-pct="100">100%</button>
        </div>

        <p id="lockInfo" class="small" style="margin-top:8px;white-space:pre-line;opacity:.9"></p>

        <div class="toggle-row" style="margin-top:10px">
          <label for="xdrOut" style="margin:0">Transaction XDR (Locker)</label>
          <button id="toggleLockerXdr" class="linkish small">Reveal XDR</button>
        </div>
        <textarea id="xdrOut" rows="6" placeholder="Built XDR appears here" readonly style="display:none"></textarea>

        <div class="row" style="margin-top:10px;flex-wrap:wrap">
          <button id="signSubmitBtn">Sign &amp; Submit</button>
          <button id="copyBtn" class="ghost">Copy XDR</button>
          <button id="labBtn" class="ghost">Open in Stellar Lab</button>
        </div>

        <p id="actionResult" class="small" style="margin-top:6px" aria-live="polite"></p>
      </div>
    </div>
  </div>

  <!-- Connect Modal -->
  <div id="backdrop" class="backdrop"></div>
  <div id="loginModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="loginTitle">
    <div class="modal-inner">
      <div class="modal-header">
        <h2 id="loginTitle" style="font-size:18px;margin:0">Connect Wallet</h2>
        <button class="x" id="closeModal" aria-label="Close">√ó</button>
      </div>
      <p>Select a login method:</p>
      <button class="wallet-btn" id="wcBtn">üîó WalletConnect (mobile)</button>
      <button class="wallet-btn" id="freighterExtBtn">üß© Freighter (browser extension)</button>

      <div id="qrArea" class="qr-wrap" style="display:none">
        <canvas id="qrCanvas" width="256" height="256" style="background:#fff;border-radius:12px"></canvas>
        <div class="wallet-choices">
          <button id="btnLobstr">Open in LOBSTR</button>
          <button id="btnFreighter">Open in Freighter</button>
        </div>
        <div class="small">
          Scan with your wallet app (LOBSTR / Freighter), or tap a button above on mobile. ¬∑
          <a id="rawWcLink" class="link" href="#" target="_blank" rel="noreferrer">raw wc link</a>
        </div>
        <p id="linkStatus" class="small" style="margin:0;text-align:center;opacity:.8"></p>
      </div>
    </div>
  </div>

  <script>window.process = window.process || { env: {} };</script>

  <script type="module">
    import SignClient from "https://esm.sh/@walletconnect/sign-client@2.21.8";
    import QRCode     from "https://esm.sh/qrcode@1.5.3";

    // ---------- Shortcuts ----------
    const SDK = window.StellarSdk;
    if(!SDK) throw new Error("Stellar SDK failed to load.");
    const ServerCtor = (SDK.Horizon && SDK.Horizon.Server) || SDK.Server;
    if(!ServerCtor) throw new Error("Stellar SDK: Server constructor not found.");
    if(!SDK.rpc || !SDK.Address || !SDK.nativeToScVal) throw new Error("Stellar SDK UMD present but Soroban helpers missing");

    // ---------- Config ----------
    const HORIZON    = "https://horizon.stellar.org";
    const NETWORK    = SDK.Networks.PUBLIC;

    // Aquarius / Soroban
    const routerContractId = "CBQDHNBFBZYE4MKPWBSJOPIYLW4SFSXAXUTSXJN76GNKYVYPCKWC6QUK";
    const sorobanRpcUrl     = "https://mainnet.sorobanrpc.com";
    const baseApi           = "https://amm-api.aqua.network/api/external/v1";
    const networkPassphrase = NETWORK;

    // AQUA / AQUAm25
    const AQUA_CODE   = "AQUA";
    const AQUA_ISSUER = "GBNZILSTVQZ4R7IKQDGHYGY2QXL5QOFJYQMXPKWRRM5PAV7Y4M67AQUA";
    const AQUAm25_CODE   = "AQUAm25";
    const AQUAm25_ISSUER = "GDXF6SYWIQOKOZ7BACXHBFBLQZEIH25KOTTLWQK35GO3JKRNIFHHGBPC";
    const TRACKER_KEY    = "GDGEWZMIJ2K6AEYYV2L4FYN27YJP5OVZSWCJIM662D5OS7EL6T6WBGBP";

    // WalletConnect
    const PROJECT_ID = "f658ce3a7c8a185214974f71539fea39";
    const EXPLORER   = "https://explorer-api.walletconnect.com/v3/wallets";

    // ---------- DOM ----------
    const $=(id)=>document.getElementById(id);
    const on=(el,ev,fn)=>el&&el.addEventListener(ev,fn);
    const isIOS=()=>/iPhone|iPad|iPod/i.test(navigator.userAgent);

    const connectBtn=$("connectBtn"), disconnectBtn=$("disconnectBtn"), statusEl=$("status");
    const backdrop=$("backdrop"), loginModal=$("loginModal"), closeModalBtn=$("closeModal");
    const qrArea=$("qrArea"), qrCanvas=$("qrCanvas"), linkStatus=$("linkStatus"), rawWcLink=$("rawWcLink");
    const pubkeyEl=$("pubkey"), aquaBalEl=$("aquaBal"), amountEl=$("amount"), lockInfoEl=$("lockInfo");
    const xdrOut=$("xdrOut"), actionResult=$("actionResult");
    const signSubmitBtn=$("signSubmitBtn"), copyBtn=$("copyBtn"), labBtn=$("labBtn");
    const pctBtns=[...document.querySelectorAll(".pct button")];

    // Swap DOM
    const swapFrom=$("swapFrom"), swapAmount=$("swapAmount"), swapQuote=$("swapQuote"),
          xdrSwap=$("xdrSwap"), swapSignSubmit=$("swapSignSubmit"),
          swapCopy=$("swapCopy"), swapResult=$("swapResult"),
          swapEst=$("swapEst"), selectedBal=$("selectedBal"), fillMaxBtn=$("fillMaxBtn"),
          toIssuerMeta=$("toIssuerMeta"), toggleSwapXdr=$("toggleSwapXdr"), toggleLockerXdr=$("toggleLockerXdr"),
          btnModeSend=$("btnModeSend"), btnModeRecv=$("btnModeRecv"),
          btnValidate=$("btnValidate"), btnQuote=$("btnQuote"),
          contractsBox=$("contractsBox"), validationBox=$("validationBox"),
          quoteBox=$("quoteBox"), routeLine=$("routeLine");

    // ---------- State ----------
    let connectionMode="none"; // 'none' | 'wc' | 'freighter'
    let client=null, session=null, latestWcUri=null;
    let pubkey=null;

    let _server=null; const getServer=()=>(_server ||= new ServerCtor(HORIZON));
    const AQUA     = new SDK.Asset(AQUA_CODE, AQUA_ISSUER);
    const AQUAm25  = new SDK.Asset(AQUAm25_CODE, AQUAm25_ISSUER);

    let buildTimer=null;       // locker debounce
    let swapTimer=null;        // swap debounce
    let lockerRefreshTimer=null;

    // Aquarius swap state
    let lastQuote=null;
    let quoteMode="send";
    let lastIsSend=true;

    // ---------- Soroban RPC ----------
    let _soro = null;
    function rpc() {
      if (_soro) return _soro;
      const Server = SDK.rpc?.Server;
      if (!Server) throw new Error("SorobanRpc unavailable from StellarSdk.");
      _soro = new Server(sorobanRpcUrl, { allowHttp: false });
      return _soro;
    }

    // Cache for issuer -> domain
    const DOMAIN_CACHE = new Map();

    // ---------- Helpers ----------
    const isValidG = k => { try{return SDK.StrKey.isValidEd25519PublicKey(k);}catch{return false;} };
    const cleanAmt = a => { const n=Number(a); if(!isFinite(n) || n<=0) return null; return n.toFixed(7).replace(/\.0+$/,""); };
    const shortG = g => `${g.slice(0,6)}‚Ä¶${g.slice(-6)}`;
    const toNativeLabel = asset => (asset.isNative && asset.isNative()) ? "XLM" : (asset.code || (asset.getCode ? asset.getCode() : "asset"));
    const plain = (v) => { const s=String(v); if(!/e/i.test(s)) return s; const n=Number(v); return n.toFixed(7).replace(/\.?0+$/,''); };
    function toast(msg, err=false){ statusEl.textContent = msg; statusEl.style.color = err ? "#ff6b6b" : ""; }
    function contractId(asset){ return asset.contractId(NETWORK); }
    function round7(x){ return Math.floor(x * 1e7) / 1e7; }

    // ---------- Spendable XLM (match aqua.network) ----------
    async function getNetworkBaseReserveXLM() {
      const r = await fetch(`${HORIZON}/ledgers?order=desc&limit=1`);
      const j = await r.json().catch(()=>null);
      const stroops = parseInt(j?._embedded?.records?.[0]?.base_reserve_in_stroops || "5000000", 10);
      return stroops / 1e7;
    }

    async function getXlmBreakdown(pk) {
      const base = await getNetworkBaseReserveXLM();
      const acc  = await fetch(`${HORIZON}/accounts/${pk}`).then(r=>r.json());

      const balNative = parseFloat((acc.balances || []).find(b => b.asset_type === "native")?.balance || "0");
      const sellLiab  = parseFloat((acc.balances || []).find(b => b.asset_type === "native")?.selling_liabilities || "0");

      const sub        = parseInt(acc?.subentry_count || 0, 10);
      const sponsoring = parseInt(acc?.num_sponsoring || 0, 10);
      const sponsored  = parseInt(acc?.num_sponsored || 0, 10);

      const minBalance = base * (2 + sub + sponsoring - sponsored);

      const trustlines = (acc.balances || []).filter(b => b.asset_type !== "native" && !b.liquidity_pool_id).length;
      const lpTrust    = (acc.balances || []).filter(b => !!b.liquidity_pool_id).length;
      const signersCt  = Math.max((acc.signers?.length || 1) - 1, 0);
      const offersCt   = parseInt(acc?.num_offers || 0, 10);

      const lineBaseReserve = base * 2;
      const lineTrustlines  = trustlines * base;
      const lineLpTrust     = lpTrust * base;
      const lineSigners     = signersCt * base;
      const lineOffers      = offersCt * base;
      const lineSponsoring  = Math.max(sponsoring - sponsored, 0) * base;
      const lineInOffers    = sellLiab;
      const feeReserve      = 2;

      const spendable = Math.max(balNative - sellLiab - minBalance - feeReserve, 0);

      return {
        baseReserve: round7(lineBaseReserve),
        feeReserve:  round7(feeReserve),
        xlmInOffers: round7(lineInOffers),
        trustlines:  round7(lineTrustlines),
        lpTrust:     round7(lineLpTrust),
        offers:      round7(lineOffers),
        signers:     round7(lineSigners),
        sponsoring:  round7(lineSponsoring),
        totalLocked: round7(minBalance + feeReserve + sellLiab),
        spendable:   round7(spendable),
        balance:     round7(balNative),
        base
      };
    }

    async function getSpendableXLM(pk) {
      const b = await getXlmBreakdown(pk);
      return b.spendable;
    }

    async function refreshXlmBreakdownMaybe() {
      const opt = getSelectedOption();
      const pk  = pubkeyEl.value.trim();
      const isXlm = opt && opt.value === "XLM";
      const el = document.getElementById("xlmBreak");
      if (!el) return;
      if (!isXlm || !isValidG(pk)) { el.style.display="none"; el.innerHTML=""; return; }

      const b = await getXlmBreakdown(pk);
      el.style.display="block";
      el.innerHTML = `
        <div class="box" style="margin-top:6px">
          <div><b>XLM available:</b> ${b.spendable} / ${b.balance}</div>
          <div class="small muted" style="margin-top:6px;line-height:1.35">
            Base reserve: ${b.baseReserve} XLM<br/>
            Fee reserve: ${b.feeReserve} XLM<br/>
            XLM in active offers: ${b.xlmInOffers} XLM<br/>
            Trustlines: ${b.trustlines} XLM${b.lpTrust?` (+ LP: ${b.lpTrust})`:''}<br/>
            Offers: ${b.offers} XLM ¬∑ Signers: ${b.signers} XLM<br/>
            Sponsoring entries for others: ${b.sponsoring} XLM<br/>
            <b>Total locked:</b> ${b.totalLocked} XLM
          </div>
        </div>`;
    }

    // ---------- Connection UI ----------
    function openModal()  { backdrop.classList.add('open'); loginModal.classList.add('open'); }
    function closeModal() { backdrop.classList.remove('open'); loginModal.classList.remove('open'); }
    on(connectBtn,"click",openModal);
    on(closeModalBtn,"click",closeModal);
    on(backdrop,"click",closeModal);

    function setConnected(address, mode){
      statusEl.textContent = address ? `Connected (${mode==="wc"?"WalletConnect":"Freighter"})` : "Not connected";
      disconnectBtn.disabled = !address;

      if(address){
        pubkey = address;
        pubkeyEl.value = address;
        pubkeyEl.readOnly = true;
        initForNewAccount();
        startLockerAutoRefresh();
      }else{
        pubkey = null;
        pubkeyEl.readOnly = false;
        stopLockerAutoRefresh();
      }
    }

    on(disconnectBtn,"click", async ()=>{
      try{
        if(connectionMode==="wc" && client && session){
          await client.disconnect({ topic: session.topic, reason:{ code:6000, message:"User disconnected" }});
        }
      }catch(e){ console.warn(e); }
      session=null; connectionMode="none"; setConnected("", "none");
      xdrOut.value = ""; xdrSwap.value = ""; swapEst.value = "";
      actionResult.textContent = ""; swapResult.textContent = ""; swapQuote.textContent = ""; routeLine.textContent = "";
      disableLockerButtons(); disableSwapButtons();
      refreshXlmBreakdownMaybe();
    });

    // ---------- Freighter connect ----------
    async function ensureFreighterApi(){
      if (window.freighterApi) return window.freighterApi;
      try{
        const mod = await import('https://esm.sh/@stellar/freighter-api@5.0.0');
        window.freighterApi = mod?.default ?? mod;
        return window.freighterApi;
      }catch{ return null; }
    }
    on($("freighterExtBtn"),"click", async ()=>{
      try{
        const freighter = await ensureFreighterApi();
        if(!freighter){ alert("Freighter extension not detected."); return; }

        let address = "";
        try { address = await freighter.getPublicKey(); } catch {}
        if(!address && freighter.getAddress){ const r=await freighter.getAddress(); address=r?.address||""; }
        if(!address && freighter.requestAccess){ const r=await freighter.requestAccess(); address=r?.address||""; }
        if(!address){ alert("Freighter connect denied or failed."); return; }

        connectionMode="freighter";
        closeModal();
        setConnected(address, "freighter");
        toast("Freighter connected.");
      }catch(e){ console.error(e); alert("Freighter connect failed."); }
    });

    // ---------- WalletConnect ----------
    let wcClient=null;
    async function ensureClient(){ if(!wcClient){ wcClient = await SignClient.init({ projectId: PROJECT_ID }); } return wcClient; }
    async function getFreighterLinks(){
      try{
        const url = `${EXPLORER}?projectId=${encodeURIComponent(PROJECT_ID)}&entries=200&page=1`;
        const res = await fetch(url); const data = await res.json();
        const raw = data?.listings ?? data?.data ?? [];
        const arr = Array.isArray(raw) ? raw : Object.values(raw);
        const w = arr.find(it => ((it.name||it.app?.name||"").toLowerCase()).includes("freighter"));
        const mobile = w?.mobile || w?.app?.mobile || {};
        return { native: mobile.native||mobile.nativeLink||null, universal: mobile.universal||mobile.universalLink||null, found: !!w };
      }catch{ return {native:null,universal:null,found:false}; }
    }
    function buildCandidates(base, wcUri){
      if(!base) return [];
      const enc = encodeURIComponent(wcUri);
      if (base.includes("{wc}") || base.includes("{URI}")) return [ base.replace("{wc}",enc).replace("{URI}",enc) ];
      const j = base.includes("?") ? "&" : "?";
      return [ `${base}${j}wc=${enc}`, `${base}${j}uri=${enc}` ];
    }
    function openFreighterSmart(links, wcUri){
      const store = isIOS()? "https://apps.apple.com/app/freighter/id6743947720" : "https://play.google.com/store/apps/details?id=org.stellar.freighterwallet&pli=1";
      const natives = buildCandidates(links.native, wcUri);
      const universals = buildCandidates(links.universal, wcUri);
      let attempted=false;
      for(const href of natives){ attempted=true; window.location.href = href; setTimeout(()=>{},350); }
      if(universals.length){ attempted=true; window.open(universals[0], "_blank", "noopener"); }
      if(!attempted){ window.open(store, "_blank", "noopener"); }
    }
    function openLobstrApp(uri){
      const scheme = `lobstr://wc?uri=${encodeURIComponent(uri)}`;
      const store  = isIOS()? "https://apps.apple.com/app/id1404357892" : "https://play.google.com/store/apps/details?id=com.lobstr.client";
      const t0 = Date.now();
      window.location.href = scheme;
      setTimeout(()=>{ if(!document.hidden && Date.now()-t0<2000){ window.open(store, "_blank", "noopener"); } }, 1800);
    }

    on($("wcBtn"),"click", async ()=>{
      try{
        const sc = await ensureClient();
        toast("Starting WalletConnect‚Ä¶");
        const { uri, approval } = await sc.connect({
          optionalNamespaces: {
            stellar: { chains:["stellar:pubnet"], methods:["stellar_signXDR","stellar_signAndSubmitXDR"], events:[] }
          }
        });
        if(!uri) throw new Error("No WC URI");
        latestWcUri = uri;

        try { await QRCode.toCanvas(qrCanvas, uri, { width:256, margin:1 }); } catch {}
        qrArea.style.display = "flex";
        rawWcLink.href = uri;

        linkStatus.textContent = "Loading Freighter deep link‚Ä¶";
        const freighterLinks = await getFreighterLinks();
        linkStatus.textContent = freighterLinks.found ? "" : "Freighter link not found ‚Äî store fallback.";

        $("btnLobstr").onclick = ()=> openLobstrApp(latestWcUri);
        $("btnFreighter").onclick = async ()=>{
          const links = await getFreighterLinks();
          openFreighterSmart(links, latestWcUri);
        };

        session = await approval();
        connectionMode="wc";
        qrArea.style.display="none"; closeModal();

        const accounts = session.namespaces?.stellar?.accounts || [];
        const first = accounts.find(a=>a.startsWith("stellar:pubnet")) || accounts[0] || "";
        const address = first.split(":")[2] || "";
        setConnected(address, "wc");
        client = sc;
      }catch(e){
        console.error(e);
        toast("Connection canceled or failed.", true);
      }
    });

    // ---------- Signing helpers ----------
    const wcRequest = (method, xdr) => client.request({
      topic: session.topic, chainId: "stellar:pubnet",
      request: { jsonrpc:"2.0", method, params:{ xdr } }
    });
    async function signCurrent(xdr){
      if(connectionMode==="wc"){
        const r = await wcRequest("stellar_signXDR", xdr);
        if(!r?.signedXDR) throw new Error("WalletConnect: no signedXDR");
        return r.signedXDR;
      }
      if(connectionMode==="freighter"){
        const api = await ensureFreighterApi();
        const res = await api.signTransaction(xdr, { networkPassphrase: NETWORK, accountToSign: pubkey });
        if(res?.error) throw new Error(res.error.message||"Freighter: sign failed");
        return res.signedTxXdr || res.signedXDR || res;
      }
      throw new Error("Not connected");
    }

    // ---------- Locker ----------
    function disableLockerButtons(){ [signSubmitBtn,copyBtn,labBtn].forEach(b=>b.disabled=true); }
    function enableLockerButtons(){ const ok=!!xdrOut.value.trim(); [signSubmitBtn,copyBtn,labBtn].forEach(b=>b.disabled=!ok); }

    async function loadAquaM25Balance(pk){
      const acct = await getServer().loadAccount(pk);
      const bal = acct.balances.find(b => b.asset_code===AQUAm25_CODE && b.asset_issuer===AQUAm25_ISSUER);
      return { acct, balance: bal ? bal.balance : "0" };
    }
    function startLockerAutoRefresh(){
      stopLockerAutoRefresh();
      lockerRefreshTimer = setInterval(async ()=>{
        const pk = pubkeyEl.value.trim();
        if(!isValidG(pk)) return;
        try{
          const { balance } = await loadAquaM25Balance(pk);
          aquaBalEl.textContent = plain(balance);
        }catch(e){ console.warn(e); }
      }, 15000);
    }
    function stopLockerAutoRefresh(){
      if(lockerRefreshTimer) clearInterval(lockerRefreshTimer);
      lockerRefreshTimer = null;
    }

    function scheduleLockerBuild(){
      disableLockerButtons();
      if(buildTimer) clearTimeout(buildTimer);
      buildTimer = setTimeout(async ()=>{
        const xdr = await buildLockXDR();
        if(xdr){ xdrOut.value = xdr; enableLockerButtons(); }
        else { xdrOut.value=""; disableLockerButtons(); }
      }, 600);
    }

    async function buildLockXDR(){
      const pk = pubkeyEl.value.trim();
      const amt = cleanAmt(amountEl.value.trim());
      if(!isValidG(pk) || !amt) return null;

      try{
        const src = await getServer().loadAccount(pk);

        const now = new Date();
        const end = new Date(now);
        end.setUTCFullYear(end.getUTCFullYear()+1);
        end.setUTCHours(23,59,59,0);
        const endTs = Math.floor(end.getTime()/1000).toString();
        lockInfoEl.textContent = `Lock start: ${now.toLocaleString()}
Lock end (UTC):   ${end.toLocaleString(undefined,{timeZone:'UTC'})}`;

        const claimants = [
          new SDK.Claimant(pk, SDK.Claimant.predicateNot(SDK.Claimant.predicateBeforeAbsoluteTime(endTs))),
          new SDK.Claimant(TRACKER_KEY, SDK.Claimant.predicateBeforeAbsoluteTime("0"))
        ];

        const tx = new SDK.TransactionBuilder(src, { fee: "20000", networkPassphrase: NETWORK })
          .addOperation(SDK.Operation.createClaimableBalance({ asset: AQUAm25, amount: amt, claimants }))
          .setTimeout(180)
          .build();

        return tx.toXDR();
      }catch(e){ console.error(e); return null; }
    }

    on(pubkeyEl,"input", ()=>{ if(pubkeyEl.readOnly) return; scheduleLockerBuild(); });
    on(pubkeyEl,"change", ()=>{ if(pubkeyEl.readOnly) return; initForNewAccount(); startLockerAutoRefresh(); });
    on(amountEl,"input", scheduleLockerBuild);

    pctBtns.forEach(btn=>btn.addEventListener("click", ()=>{
      const bal = Math.max(0, parseFloat(aquaBalEl.textContent) || 0);
      const pct = parseInt(btn.dataset.pct,10)/100;
      const v = cleanAmt(bal*pct);
      amountEl.value = v||"";
      scheduleLockerBuild();
    }));

    // ---------- Swap balances + dropdown ----------
    async function loadAllBalances(pk){
      const acct = await getServer().loadAccount(pk);
      const items = [];
      const xlmBal = acct.balances.find(b=>b.asset_type==="native");
      if (xlmBal && parseFloat(xlmBal.balance) > 0) {
        items.push({ code:"XLM", issuer:null, balance: xlmBal.balance, domain:"native" });
      }
      for(const b of acct.balances){
        if(b.asset_type==="native") continue;
        if(parseFloat(b.balance) <= 0) continue;
        items.push({ code:b.asset_code, issuer:b.asset_issuer, balance:b.balance });
      }
      return { acct, items };
    }
    async function fetchDomainsForIssuers(issuers){
      const unique = [...new Set((issuers||[]).filter(Boolean))];
      const need = unique.filter(i => !DOMAIN_CACHE.has(i));
      await Promise.all(need.map(async (issuer)=>{
        try{
          const r = await fetch(`${HORIZON}/accounts/${issuer}`);
          const j = await r.json();
          const d = (j && j.home_domain) ? j.home_domain : "";
          DOMAIN_CACHE.set(issuer, d);
        }catch(_){ DOMAIN_CACHE.set(issuer, ""); }
      }));
    }
    function labelWithDomain(code, issuer){
      if(!issuer) return `${code} ¬∑ native`;
      const dom = DOMAIN_CACHE.get(issuer) || "";
      const right = dom || shortG(issuer);
      return `${code} ¬∑ ${right}`;
    }
    function fillSwapDropdownOnce(items){
      swapFrom.innerHTML = "";
      for(const it of items){
        const opt = document.createElement("option");
        opt.value = it.issuer ? `${it.code}:${it.issuer}` : "XLM";
        opt.textContent = labelWithDomain(it.code, it.issuer);
        opt.dataset.balance = it.balance;
        opt.dataset.code = it.code;
        if(it.issuer) opt.dataset.issuer = it.issuer;
        swapFrom.appendChild(opt);
      }
      const def = `${AQUA_CODE}:${AQUA_ISSUER}`;
      const found = [...swapFrom.options].find(o=>o.value===def);
      swapFrom.value = found ? def : (swapFrom.options[0]?.value || "");
      updateSelectedAssetUI();
    }
    function getSelectedOption(){ return swapFrom.options[swapFrom.selectedIndex] || null; }
    function updateSelectedAssetUI(){
      const opt = getSelectedOption();
      if(!opt){ fillMaxBtn.style.display="none"; return; }
      const bal = opt.dataset.balance || "0";
      selectedBal.textContent = plain(bal);
      fillMaxBtn.style.display = parseFloat(bal)>0 ? "inline-flex" : "none";
      refreshXlmBreakdownMaybe();
    }
    async function updateToBoxDomain(){
      if(!DOMAIN_CACHE.has(AQUAm25_ISSUER)){
        await fetchDomainsForIssuers([AQUAm25_ISSUER]);
      }
      const dom = DOMAIN_CACHE.get(AQUAm25_ISSUER) || shortG(AQUAm25_ISSUER);
      toIssuerMeta.textContent = dom;
    }

    async function initForNewAccount(){
      const pk = pubkeyEl.value.trim();
      if(!isValidG(pk)) { aquaBalEl.textContent="Invalid key"; return; }

      try{
        const { balance } = await loadAquaM25Balance(pk);
        aquaBalEl.textContent = plain(balance);

        const { items } = await loadAllBalances(pk);
        await fetchDomainsForIssuers(items.map(i=>i.issuer).filter(Boolean).concat([AQUAm25_ISSUER]));
        fillSwapDropdownOnce(items);

        updateToBoxDomain();

        if(!amountEl.value.trim()){
          const v = cleanAmt(parseFloat(balance||"0")*0.25);
          if(v){ amountEl.value = v; }
        }
        scheduleLockerBuild();
        refreshXlmBreakdownMaybe();
      }catch(e){ console.error(e); }
    }

    // ---------- Aquarius validators ----------
    function showContracts(){
      const tokenIn = getCurrentSendAsset();
      const data = {
        token_in: { code: tokenIn.isNative() ? "XLM" : tokenIn.code, issuer: tokenIn.isNative() ? "(native)" : tokenIn.issuer, contract_id: contractId(tokenIn) },
        token_out:{ code: AQUAm25.isNative() ? "XLM" : AQUAm25.code, issuer: AQUAm25.isNative() ? "(native)" : AQUAm25.issuer, contract_id: contractId(AQUAm25) },
        router_contract_id: routerContractId
      };
      contractsBox.textContent = JSON.stringify(data, null, 2);
    }
    async function hasTrustline(account, asset){
      if (asset.isNative()) return true;
      const r = await fetch(`${HORIZON}/accounts/${account}`);
      if(!r.ok) throw new Error("Horizon account lookup failed");
      const j = await r.json();
      const bal = (j.balances || []).find(b => b.asset_code === asset.code && b.asset_issuer === asset.issuer);
      return !!bal;
    }
    async function softTokenCheck(asset){
      const probe = { token_in_address:  contractId(asset), token_out_address: contractId(SDK.Asset.native()), amount: "1" };
      const r = await fetch(`${baseApi}/find-path/`, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(probe) });
      const j = await r.json().catch(()=>null);
      return !!j && (typeof j.success === "boolean");
    }
    async function onValidate(){
      try{
        showContracts();
        const tokenIn = getCurrentSendAsset();
        const tokenOut = AQUAm25;
        const bits = [];

        const [okIn, okOut] = await Promise.all([softTokenCheck(tokenIn), softTokenCheck(tokenOut)]);
        bits.push(okIn ? `<div class="pill ok">Token In recognized by Aquarius</div>` : `<div class="pill warn">Token In not recognized</div>`);
        bits.push(okOut ? `<div class="pill ok">Token Out recognized by Aquarius</div>` : `<div class="pill warn">Token Out not recognized</div>`);

        if(pubkey){
          const tl = await hasTrustline(pubkey, tokenOut);
          bits.push(tl ? `<div class="pill ok">Trustline: OK for output asset</div>` : `<div class="pill warn">No trustline for output asset ‚Äî click ‚ÄúAdd AQUAm25 Trustline‚Äù</div>`);
        } else {
          bits.push(`<div class="pill">Connect to check trustline</div>`);
        }

        validationBox.innerHTML = `<div class="row" style="gap:8px">${bits.join("")}</div>`;
        toast("Validation finished.");
      } catch(e){
        validationBox.innerHTML = `<span style="color:#ff6b6b">${e.message}</span>`;
        toast("Validation error.", true);
      }
    }

    // ---------- Route helpers (Horizon trustlines) ----------
    function assetEqual(a,b){ return a.code===b.code && (a.issuer||null)===(b.issuer||null); }

    // Fetch the two token trustlines of a pool contract (ignoring AQUA emissions if present)
    async function fetchPoolTrustlines(poolCid){
      try{
        const res = await fetch(`${HORIZON}/accounts/${poolCid}`);
        if(!res.ok) throw new Error(`Horizon ${res.status}`);
        const j = await res.json();
        const rows = (j.balances||[])
          .filter(b => b.asset_type==="native" || (b.asset_code && b.asset_issuer))
          .map(b => ({
            code: b.asset_type==="native" ? "XLM" : b.asset_code,
            issuer: b.asset_type==="native" ? null : b.asset_issuer,
            bal: parseFloat(b.balance||"0")
          }));
        let list = rows;
        if(rows.length>2){
          const nonAqua = rows.filter(x => !(x.code==="AQUA" && x.issuer===AQUA_ISSUER));
          if(nonAqua.length>=2) list = nonAqua;
        }
        list.sort((a,b)=>b.bal-a.bal);
        const uniq=[];
        for(const a of list){
          if(!uniq.some(x=>assetEqual(x,a))){
            uniq.push({code:a.code,issuer:a.issuer});
            if(uniq.length===2) break;
          }
        }
        return uniq;
      }catch(e){
        console.warn("fetchPoolTrustlines failed",poolCid,e);
        return [];
      }
    }

// --- REPLACE your fetchPoolTrustlines + buildRouteLabelsFromPools with this ---

// Soroban RPC instance (we already have rpc() elsewhere)
function scvSym(s){ return SDK.xdr.ScVal.scvSymbol(s); }
function toScAddressFromString(str){
  return SDK.Address.fromString(str).toScAddress();
}

/**
 * Read token pair from an Aquarius AMM pool contract by querying its
 * persistent contract-data keys (e.g., "token_a" / "token_b").
 * Returns [{code,issuer}|{code:"XLM"}] entries (code/issuer unknown here;
 * we return contract addresses and map to tickers separately below).
 */
async function fetchPoolTokenContracts(poolCid){
  try{
    const server = rpc();

    // Build two LedgerKey.contractData entries
    const keys = ["token_a","token_b"].map(sym => {
      return SDK.xdr.LedgerKey.contractData(
        new SDK.xdr.LedgerKeyContractData({
          contract: toScAddressFromString(poolCid),
          key: scvSym(sym),
          durability: SDK.xdr.ContractDataDurability.persistent()
        })
      );
    });

    const resp = await server.getLedgerEntries(keys);
    // Each entry‚Äôs value is an ScVal Address; decode to string.
    const out = [];
    for (const item of (resp?.entries||[])){
      const valXdr = item?.xdr?.val || item?.val || item?.liveEntry?.data?.contractData?.val;
      if(!valXdr) continue;
      const scv = (valXdr instanceof SDK.xdr.ScVal) ? valXdr : SDK.xdr.ScVal.fromXDR(valXdr, "base64");
      // Expected shape: Address (contract for Soroban token or classic for native)
      const addr = SDK.Address.fromScVal(scv);
      out.push(addr.toString());
    }

    // Return two contract (or classic) addresses in order [token_a, token_b]
    return out;
  }catch(e){
    console.warn("fetchPoolTokenContracts RPC failed", poolCid, e);
    return [];
  }
}

/**
 * Resolve a human-readable ticker for a token address.
 * Strategy:
 *  - If it matches the known AQUAm25 classic asset -> "AQUAm25"
 *  - If it‚Äôs native classic (G‚Ä¶ doesn‚Äôt mean native; XLM is represented by a special token contract on Soroban),
 *    but the Aquarius router path will still include a Soroban token for native. We therefore try:
 *      1) Call the Soroban token‚Äôs `symbol` (standard token interface) via a lightweight simulation.
 *      2) Fallback to "TOKEN" shortened.
 */
async function resolveTickerFromAddress(addr){
  // Known outputs
  if (addr === AQUAm25.contractId(NETWORK)) return "AQUAm25";

  // If this address is actually a classic issuer for a known asset we care about:
  if (addr === null) return "XLM"; // just in case

  // Try token::symbol() on Soroban token contracts
  try{
    const server = rpc();
    const c = new SDK.Contract(addr);

    // Build a dummy tx that calls symbol(); use simulation via prepareTransaction
    const kp = SDK.Keypair.random(); // ephemeral
    const acc = await server.getAccount(kp.publicKey()); // no state needed; simulation only

    const op = c.call("symbol"); // no args
    let tx = new SDK.TransactionBuilder(acc, { fee: "10000", networkPassphrase })
      .setTimeout(30)
      .addOperation(op)
      .build();

    // Prepare & simulate
    tx = await server.prepareTransaction(tx);
    const sim = await server.simulateTransaction(tx);

    // Return value lives in sim.result.retVal
    const rv = sim?.result?.retVal;
    if (rv) {
      const scv = (rv instanceof SDK.xdr.ScVal) ? rv : SDK.xdr.ScVal.fromXDR(rv, "base64");
      if (scv.switch() === SDK.xdr.ScValType.scvSymbol()) {
        const sym = SDK.scValToNative(scv); // "AQUA", "USDC", etc.
        if (typeof sym === "string" && sym.length) return sym;
      }
      // Some tokens may return scvString for symbol/name
      try {
        const native = SDK.scValToNative(scv);
        if (typeof native === "string" && native.length) return native;
      } catch(_) {}
    }
  }catch(e){
    // ignore ‚Äî we‚Äôll fallback
  }

  // Last resort: shortened contract id
  return `${addr.slice(0,4)}‚Ä¶${addr.slice(-4)}`;
}

/**
 * Build "X ‚Üí Y ‚Üí Z" labels for the pools in the Aquarius quote by reading each pool‚Äôs
 * token_a/token_b contracts, then resolving their tickers. We also *skip AQUA* where it‚Äôs
 * a 3rd emissions balance on pools (we‚Äôre only reading the two canonical tokens anyway).
 */
async function buildRouteLabelsFromPools(sendAsset, pools){
  // Start/end
  const start = (sendAsset.isNative && sendAsset.isNative())
    ? { label: "XLM", addr: null }
    : { label: sendAsset.code, addr: sendAsset.contractId(NETWORK) };

  const endLabel = "AQUAm25";

  const labels = [start.label];
  let currentAddr = start.addr; // token contract address for Soroban (null for XLM ‚Äî OK)

  // Walk pools (max 4 per Aquarius)
  for (const pool of (pools||[]).slice(0,4)){
    const poolCid = (typeof pool === "string") ? pool : (pool.contract || pool.id || pool.pool || "");
    if (!poolCid) { labels.push("???"); continue; }

    const pair = await fetchPoolTokenContracts(poolCid);
    if (pair.length < 2) { labels.push("???"); continue; }

    // Choose the "other" token vs current
    const [a,b] = pair;
    let nextAddr;
    if (!currentAddr) {
      // When current is native (XLM), we don‚Äôt have a contract addr; pick the non-XLM if possible
      // but we don't know which is XLM without symbol ‚Äî resolve both and choose later
      // Resolve a first; if it looks like "XLM", pick the other.
      const [la, lb] = await Promise.all([resolveTickerFromAddress(a), resolveTickerFromAddress(b)]);
      nextAddr = (la === "XLM") ? b : ((lb === "XLM") ? a : a);
      const nextLabel = (la === "XLM") ? lb : ((lb === "XLM") ? la : la);
      labels.push(nextLabel);
      currentAddr = nextAddr;
      continue;
    }

    if (a === currentAddr) nextAddr = b;
    else if (b === currentAddr) nextAddr = a;
    else {
      // If neither matches (first hop from XLM or ambiguous), just pick a non-AQUA if available
      nextAddr = (a && a !== AQUA.contractId(NETWORK)) ? a : b;
    }

    const lbl = await resolveTickerFromAddress(nextAddr);
    labels.push(lbl);
    currentAddr = nextAddr;
  }

  // Ensure last is AQUAm25
  if (labels[labels.length-1] !== endLabel) labels.push(endLabel);

  return labels.join(" ‚Üí ");
}

      // Aquarius router caps at 4 pools; enforce here too
      for(const pool of (pools||[]).slice(0,4)){
        const cid = typeof pool==="string" ? pool : (pool.contract||pool.id||pool.pool||"");
        if(!cid){ hops.push({code:"???",issuer:null}); continue; }
        const pair=await fetchPoolTrustlines(cid);
        if(pair.length<2){
          hops.push({code:"???",issuer:null});
          continue;
        }
        const next =
          assetEqual(pair[0],current) ? pair[1] :
          assetEqual(pair[1],current) ? pair[0] :
          (pair.find(x=>x.code!=="AQUA") || pair[0]);
        hops.push(next);
        current=next;
      }

      if(!assetEqual(current,end)) hops.push(end);

      const labels=hops.map(h=>h.code||"???");
      return labels.join(" ‚Üí ");
    }

    // ---------- Aquarius quotes ----------
    function getCurrentSendAsset(){
      if(!swapFrom.value || swapFrom.value === "XLM") return SDK.Asset.native();
      const [code, issuer] = (swapFrom.value||"").split(":");
      return new SDK.Asset(code, issuer);
    }
    function routeSummary(isSend, j, sendLabel){
      const est = Number(j.amount)/1e7;
      return isSend
        ? `Mode: <b>Strict Send</b> ¬∑ You send <b>${swapAmount.value}</b> ${sendLabel}. Estimated receive: <b>${plain(est)}</b> AQUAm25`
        : `Mode: <b>Strict Receive</b> ¬∑ To receive <b>${swapEst.value}</b> AQUAm25, estimated spend: <b>${plain(est)}</b> ${sendLabel}`;
    }

    async function quoteStrictSend(){
      disableSwapButtons();
      xdrSwap.value=""; swapQuote.textContent=""; routeLine.textContent="";
      const pk = pubkeyEl.value.trim();
      const sendAmt = cleanAmt(swapAmount.value.trim());
      if(!isValidG(pk) || !sendAmt) return;

      const sendAsset = getCurrentSendAsset();
      const sendLabel = toNativeLabel(sendAsset);

      try{
        const body = {
          token_in_address:  contractId(sendAsset),
          token_out_address: contractId(AQUAm25),
          amount: String(Math.round(parseFloat(sendAmt)*1e7))
        };
        const res = await fetch(`${baseApi}/find-path/`, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
        const j = await res.json();
        if(!j?.success) throw new Error("No route from Aquarius AMM");

        lastQuote = j; lastIsSend = true;

        const outStroops = BigInt(j.amount);
        const estOut = Number(outStroops) / 1e7;

        swapEst.value = plain(estOut);
        swapQuote.innerHTML = routeSummary(true, j, sendLabel);
        quoteBox.textContent = JSON.stringify({mode:"strict-send", estimate_out:estOut, pools:j.pools, tokens:j.tokens}, null, 2);

    async function quoteStrictReceive(){
      disableSwapButtons();
      xdrSwap.value=""; swapQuote.textContent=""; routeLine.textContent="";
      const pk = pubkeyEl.value.trim();
      const wantOut = cleanAmt(swapEst.value.trim());
      if(!isValidG(pk) || !wantOut) return;

      const sendAsset = getCurrentSendAsset();
      const sendLabel = toNativeLabel(sendAsset);

      try{
        const body = {
          token_in_address:  contractId(sendAsset),
          token_out_address: contractId(AQUAm25),
          amount: String(Math.round(parseFloat(wantOut)*1e7))
        };
        const res = await fetch(`${baseApi}/find-path-strict-receive/`, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
        const j = await res.json();
        if(!j?.success) throw new Error("No route from Aquarius AMM");

        lastQuote = j; lastIsSend = false;

        const inNeeded = BigInt(j.amount);
        const estIn = Number(inNeeded) / 1e7;

        swapAmount.value = plain(estIn);
        swapQuote.innerHTML = routeSummary(false, j, sendLabel);
        quoteBox.textContent = JSON.stringify({mode:"strict-receive", estimate_in:estIn, pools:j.pools, tokens:j.tokens}, null, 2);

        // NEW: resolve route labels via Horizon trustlines
        try {
          const route = await buildRouteLabelsFromPools(sendAsset, j.pools || []);
          routeLine.textContent = `Route: ${route}`;
        } catch { routeLine.textContent = ""; }

        // Balance guard (use spendable XLM when XLM is input)
        let available = parseFloat(getSelectedOption()?.dataset.balance || "0");
        if (swapFrom.value === "XLM") {
          try { available = await getSpendableXLM(pk); } catch {}
        }
        const inMax = inNeeded + (inNeeded / 100n);       // +1% cushion
        if (available * 1e7 < Number(inMax)) {
          swapQuote.textContent = `Insufficient balance for this strict-receive target ‚Äî need about ${plain(Number(inMax)/1e7)} ${sendLabel}, available ${plain(available)}.`;
          routeLine.textContent = "";
          lastQuote = null; xdrSwap.value = ""; disableSwapButtons();
          return;
        }

        const outExact = BigInt(Math.round(parseFloat(wantOut)*1e7));
        const needTL = !(await hasTrustline(pk, AQUAm25));

        const tx = await buildSorobanSwapTx({
          account: pk, isSend: false, tokenIn: sendAsset,
          inAmountStroops: inMax,          // MAX IN
          limitOutOrExact: outExact,       // EXACT OUT
          swapChainXdr: j.swap_chain_xdr,
          addTrustlineFirst: needTL
        });
        xdrSwap.value = tx.toXDR();
        enableSwapButtons();
      }catch(e){
        console.error(e);
        swapQuote.textContent = `Aquarius quote failed (strict receive). ${e.message||""}`;
        routeLine.textContent = "";
        lastQuote=null; xdrSwap.value=""; disableSwapButtons();
      }
    }

    // ---------- Build Soroban swap tx ----------
    async function buildSorobanSwapTx({
      account,          // G...
      isSend,           // true -> swap_chained, false -> swap_chained_strict_receive
      tokenIn,          // SDK.Asset
      inAmountStroops,  // BigInt  (send mode: amount_in; receive mode: max_amount_in)
      limitOutOrExact,  // BigInt  (send mode: min_amount_out; receive mode: exact_amount_out)
      swapChainXdr,     // base64 ScVal from Aquarius API
      addTrustlineFirst // boolean
    }){
      if (addTrustlineFirst) {
        throw new Error("Missing AQUAm25 trustline. Click ‚ÄúAdd AQUAm25 Trustline‚Äù first, then retry the swap.");
      }

      const server = rpc();
      const acc = await server.getAccount(account);

      const router = new SDK.Contract(routerContractId);
      const tokenInCid = tokenIn.contractId(NETWORK);

      const addrAccount  = SDK.Address.fromString(account).toScVal();
      const addrTokenIn  = SDK.Address.fromString(tokenInCid).toScVal();
      const u128In       = SDK.nativeToScVal(BigInt(inAmountStroops), { type: "u128" });
      const u128LimOrEx  = SDK.nativeToScVal(BigInt(limitOutOrExact), { type: "u128" });
      const swapChainVal = SDK.xdr.ScVal.fromXDR(swapChainXdr, "base64");

      let swapOp;
      if (isSend) {
        // (account, swap_chain, token_in, amount_in, min_amount_out)
        swapOp = router.call("swap_chained",
          addrAccount, swapChainVal, addrTokenIn, u128In, u128LimOrEx
        );
      } else {
        // (account, swap_chain, token_in, exact_amount_out, max_amount_in)
        swapOp = router.call("swap_chained_strict_receive",
          addrAccount, swapChainVal, addrTokenIn, u128LimOrEx /* exact out */, u128In /* max in */
        );
      }

      let tx = new SDK.TransactionBuilder(acc, { fee: "20000", networkPassphrase })
        .setTimeout(300)
        .addOperation(swapOp)
        .build();

      try {
        tx = await server.prepareTransaction(tx);
      } catch (e) {
        console.error("prepareTransaction failed:", e);
        throw new Error(
          `prepareTransaction failed: ${
            e?.response?.data?.error?.message ||
            e?.data?.error?.message ||
            e?.message || "unknown"
          }`
        );
      }
      return tx;
    }

    // ---------- Classic trustline helper ----------
    async function buildTrustlineXDR(pk){
      const src = await getServer().loadAccount(pk);
      const tx = new SDK.TransactionBuilder(src, { fee: "10000", networkPassphrase: NETWORK })
        .addOperation(SDK.Operation.changeTrust({ asset: AQUAm25 }))
        .setTimeout(180)
        .build();
      return tx.toXDR();
    }

    on($("btnAddTrustline"), "click", async ()=>{
      try{
        const pk = pubkeyEl.value.trim();
        if(!isValidG(pk)) { toast("Connect a wallet first.", true); return; }

        if(await hasTrustline(pk, AQUAm25)){
          toast("AQUAm25 trustline already exists.");
          return;
        }

        toast("Preparing trustline transaction‚Ä¶");
        const trustXdr = await buildTrustlineXDR(pk);

        toast("Signing trustline‚Ä¶");
        const signed = await signCurrent(trustXdr);

        toast("Submitting trustline‚Ä¶");
        const hash = await submitToHorizon(signed);

        toast(`Trustline added ‚úì tx: ${hash}`);
        await initForNewAccount();

        try { if (lastQuote) { if (lastIsSend) await quoteStrictSend(); else await quoteStrictReceive(); } } catch(_) {}
      }catch(e){
        console.error(e);
        toast(e.message || "Trustline add failed.", true);
      }
    });

    // Submit Soroban
    async function submitToSoroban(signedXdr){
      const tx = SDK.TransactionBuilder.fromXDR(signedXdr, NETWORK);
      const send = await rpc().sendTransaction(tx);
      if (send.status !== "PENDING" && send.status !== "SUCCESS")
        throw new Error(`Soroban send failed: ${send.status}`);

      let final = await rpc().getTransaction(send.hash);
      let tries = 0;
      while(final.status === "NOT_FOUND" && tries < 10){
        await new Promise(r=>setTimeout(r, 800));
        final = await rpc().getTransaction(send.hash);
        tries++;
      }
      if(final.status !== "SUCCESS") throw new Error(`Tx failed: ${final.status}`);
      return final;
    }

    // ---------- Swap buttons ----------
    function disableSwapButtons(){ [swapSignSubmit,swapCopy].forEach(b=>b.disabled=true); }
    function enableSwapButtons(){ const ok=!!xdrSwap.value.trim(); [swapSignSubmit,swapCopy].forEach(b=>b.disabled=!ok); }

    function debounceQuote(fn){ if(swapTimer) clearTimeout(swapTimer); swapTimer = setTimeout(fn, 400); }

    on(swapFrom,"change", ()=>{
      updateSelectedAssetUI();

      // Reset values & UI to avoid invalid carry-over when changing assets
      swapAmount.value = "";
      swapEst.value = "";
      xdrSwap.value = "";
      swapQuote.textContent = "";
      routeLine.textContent = "";
      disableSwapButtons();

      if(quoteMode==="send" && swapAmount.value.trim()) debounceQuote(quoteStrictSend);
      else if(quoteMode==="receive" && swapEst.value.trim()) debounceQuote(quoteStrictReceive);
    });

    on(swapAmount,"input", ()=>{
      quoteMode = "send";
      if(!swapAmount.value || Number(swapAmount.value) <= 0){ xdrSwap.value=""; swapQuote.textContent=""; routeLine.textContent=""; disableSwapButtons(); return; }
      debounceQuote(quoteStrictSend);
    });

    on(swapEst,"input", ()=>{
      quoteMode = "receive";
      if(!swapEst.value || Number(swapEst.value) <= 0){ xdrSwap.value=""; swapQuote.textContent=""; routeLine.textContent=""; disableSwapButtons(); return; }
      debounceQuote(quoteStrictReceive);
    });

    on(fillMaxBtn,"click", async ()=>{
      const opt = getSelectedOption();
      if(!opt) return;
      const pk = pubkeyEl.value.trim();
      if(!isValidG(pk)){ toast("Connect first to auto-fill balance.", true); return; }

      if(opt.value === "XLM"){
        try{
          const spendable = await getSpendableXLM(pk);
          swapAmount.value = plain(spendable);
          await refreshXlmBreakdownMaybe();
        }catch(e){
          console.error(e);
          toast("Could not compute spendable XLM.", true);
          return;
        }
      }else{
        const bal = parseFloat(opt.dataset.balance || "0");
        swapAmount.value = plain(bal);
      }
      quoteMode = "send";
      quoteStrictSend();
    });

    // Toggle XDR areas
    function toggleEl(el, btn){
      const isHidden = el.style.display === "none" || !el.style.display;
      el.style.display = isHidden ? "block" : "none";
      btn.textContent = isHidden ? "Hide XDR" : "Reveal XDR";
    }
    on(toggleSwapXdr, "click", ()=> toggleEl(xdrSwap, toggleSwapXdr));
    on(toggleLockerXdr, "click", ()=> toggleEl(xdrOut,  toggleLockerXdr));

    // Copy helpers
    on($("copyContracts"),"click", async ()=>{ try{ await navigator.clipboard.writeText(contractsBox.textContent); toast("Copied."); }catch{} });
    on($("copyQuote"),"click", async ()=>{ try{ await navigator.clipboard.writeText(quoteBox.textContent); toast("Copied."); }catch{} });
    on(swapCopy,"click", async ()=>{ try{ await navigator.clipboard.writeText(xdrSwap.value); swapCopy.textContent="Copied!"; setTimeout(()=>swapCopy.textContent="Copy XDR",1500);}catch(e){console.error(e);} });

    // Mode toggle
    function setMode(m){
      if(m==="send"){ btnModeSend.style.background="#0c3137"; btnModeSend.style.borderColor="#2a6f7c"; btnModeRecv.style.background="#141b22"; btnModeRecv.style.borderColor="#2a3340"; }
      else { btnModeRecv.style.background="#0c3137"; btnModeRecv.style.borderColor="#2a6f7c"; btnModeSend.style.background="#141b22"; btnModeSend.style.borderColor="#2a3340"; }
      quoteMode = m==="send" ? "send" : "receive";
      lastIsSend = (m==="send");
      swapQuote.textContent=""; routeLine.textContent=""; xdrSwap.value=""; disableSwapButtons();
      refreshXlmBreakdownMaybe();
    }
    on(btnModeSend,"click", ()=>setMode("send"));
    on(btnModeRecv,"click", ()=>setMode("receive"));

    // Swap signing & submit
    on(swapSignSubmit,"click", async ()=>{
      swapResult.textContent="";
      try{
        let xdrToSubmit = xdrSwap.value.trim();
        if(!xdrToSubmit || !/AAAA/.test(xdrToSubmit)){
          if(lastIsSend) await quoteStrictSend(); else await quoteStrictReceive();
          xdrToSubmit = xdrSwap.value.trim();
          if(!xdrToSubmit) throw new Error("No prepared XDR.");
        }
        swapResult.textContent="Signing‚Ä¶";
        const signed = await signCurrent(xdrToSubmit);
        swapResult.textContent="Submitting to Soroban‚Ä¶";
        const final = await submitToSoroban(signed);
        const u = BigInt(final.returnValue?.u128 ?? 0n);
        const sentOrRecv = lastIsSend ? `Amount OUT: ${plain(Number(u)/1e7)} ${AQUAm25_CODE}` :
                                        `Amount IN: ${plain(Number(u)/1e7)} ${getSelectedOption()?.dataset.code||"asset"}`;
        swapResult.innerHTML = `Submitted ‚úì hash: ${final.hash}<br/>${sentOrRecv}<br/>View: https://stellar.expert/explorer/public/tx/${final.hash}`;

        // refresh AQUAm25 balance after swap
        setTimeout(async ()=>{
          const pk = pubkeyEl.value.trim();
          if(isValidG(pk)){
            try{ const { balance } = await loadAquaM25Balance(pk); aquaBalEl.textContent = plain(balance); }catch{}
          }
        }, 1200);
      }catch(e){ console.error(e); swapResult.textContent=e.message||"Sign/submit failed."; }
    });

    // ---------- Locker submit (classic) ----------
    async function submitToHorizon(signedXdr){
      const resp = await fetch(`${HORIZON}/transactions`,{
        method:"POST",
        headers:{ "Content-Type":"application/x-www-form-urlencoded;charset=UTF-8" },
        body:"tx="+encodeURIComponent(signedXdr)
      });
      const data = await resp.json().catch(()=> ({}));
      if(!resp.ok){
        const code = data?.extras?.result_codes?.transaction || resp.status;
        const op   = data?.extras?.result_codes?.operations || [];
        throw new Error(`Horizon error: ${code}${op.length?` (${op.join(",")})`:""}`);
      }
      return data.hash;
    }

    on(signSubmitBtn,"click", async ()=>{
      actionResult.textContent="";
      const xdr = xdrOut.value.trim();
      if(!xdr){ actionResult.textContent="No XDR to sign. Enter key + amount first."; return; }
      try{
        actionResult.textContent="Signing‚Ä¶";
        const signed = await signCurrent(xdr);
        actionResult.textContent="Submitting‚Ä¶";
        const hash = await submitToHorizon(signed);
        actionResult.innerHTML = `Submitted ‚úì tx: ${hash}<br/>View: https://stellar.expert/explorer/public/tx/${hash}`;
      }catch(e){ console.error(e); actionResult.textContent=e.message||"Sign/submit failed."; }
    });

    on(copyBtn,"click", async ()=>{ try{ await navigator.clipboard.writeText(xdrOut.value); copyBtn.textContent="Copied!"; setTimeout(()=>copyBtn.textContent="Copy XDR",1500); } catch(e){ console.error(e); } });

    on(labBtn,"click", ()=>{
      const xdr = xdrOut.value.trim(); if(!xdr) return;
      let enc = encodeURIComponent(xdr).replace(/%2F/g,'/').replace(/%2B/g,'+').replace(/%3D/g,'=');
      enc = enc.replace(/\//g,'//') + ';;';
      window.open('https://lab.stellar.org/transaction/sign?$=network$id=mainnet&label=Mainnet&horizonUrl=https:////horizon.stellar.org&rpcUrl=https:////mainnet.sorobanrpc.com&passphrase=Public%20Global%20Stellar%20Network%20/;%20September%202015;&transaction$sign$activeView=overview&importXdr='+enc, "_blank");
    });

    // ---------- Validate / Quote buttons ----------
    on(btnValidate,"click", onValidate);
    on(btnQuote,"click", ()=>{ if(lastIsSend) quoteStrictSend(); else quoteStrictReceive(); });

    // ---------- First-load ----------
    window.addEventListener("load", ()=>{
      const pk = pubkeyEl.value.trim();
      updateToBoxDomain();
      if(isValidG(pk)){ initForNewAccount(); startLockerAutoRefresh(); }
      disableLockerButtons();
      disableSwapButtons();
      showContracts(); // SAC IDs for defaults
      refreshXlmBreakdownMaybe();
    });

  </script>

  <!-- Freighter UMD fallback -->
  <script>
    if(!window.freighterApi){
      const s = document.createElement('script');
      s.src = "https://cdn.freighter.app/freighter-api-v1.js";
      document.head.appendChild(s);
    }
  </script>
</body>
</html>
