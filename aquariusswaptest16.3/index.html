<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mirrasets â€” Swap & Lock (v16.3 AQUAmb)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Freighter API (UMD) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/stellar-freighter-api/5.0.0/index.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <!-- Stellar SDK (UMD v14.3.0) â€” includes Soroban (SDK.rpc) -->
  <script src="/sdk/stellar-sdk-14.3.0.min.js?v=12"></script>

  <style>
    :root { --bg:#0b0f12; --panel:#12181d; --ink:#e8f0f6; --muted:#94a3ad; --accent:#7d4bd1; --accent-2:#4fd1c5; --err:#ff6b6b; --ok:#57d29a; --border:#1c242c; }
    * { box-sizing: border-box; }
    html,body { margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    .wrap{max-width:980px;margin:28px auto;padding:0 16px}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:22px}
    h1{margin:0 0 10px;font-size:20px;letter-spacing:.3px}
    h2{margin:18px 0 8px}
    p{margin:.25rem 0 .75rem;opacity:.96}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .small{font-size:12px;opacity:.8}
    .muted{color:var(--muted)}
    button{cursor:pointer;font-weight:700;border-radius:10px;border:1px solid #21464f;background:#0c1c20;color:#d9f6ff;padding:10px 14px;transition:.15s}
    button:hover{filter:brightness(1.08)}
    button.ghost{background:#141b22;border-color:#2a3340}
    button:disabled{opacity:.5;cursor:not-allowed}
    input,textarea,select{width:100%;padding:12px;border-radius:10px;border:1px solid #1e2831;background:#0e1419;color:#fff}
    input[readonly]{opacity:.95;background:#0b1115;border-style:dashed}
    label{display:block;margin:10px 0 6px;font-size:12px;color:var(--muted)}
    .section{margin-top:28px;padding-top:18px;border-top:1px dashed #1a232c}
    .box{background:#0e1620;border:1px solid #1c2430;border-radius:12px;padding:14px}
    .toggle-row{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .linkish{border:none;background:transparent;color:#9ab0ff;text-decoration:underline;padding:0;cursor:pointer}
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    /* Constrain and center swap/locker, keep real gaps (480px as requested) */
    #swapBox, #lockerCard { width:100%; max-width:480px; margin:0 auto; }
    #swapBox { margin-top:22px; position:relative; }
    #lockerCard { margin-top:26px; }

    /* Modals (center-align content) */
    .backdrop{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;z-index:9997}
    .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:9998;text-align:center}
    .open{display:flex}
    .modal-inner{width:min(560px,92vw);background:#0e1627;border:1px solid #22315c;border-radius:16px;padding:22px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .x{background:none;border:none;color:#bcc6d4;font-size:22px;line-height:1;cursor:pointer}
    .wallet-btn{width:100%;padding:14px 16px;display:flex;align-items:center;justify-content:center;gap:10px;margin-top:10px}
    .qr-wrap{display:flex;flex-direction:column;align-items:center;gap:12px;margin-top:12px}
    .wallet-choices{display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
    .wallet-choices button{background:#162554;border:1px solid #344a8a}
    a.link{color:#9ab0ff;text-decoration:underline}

    /* Swap card */
    .card-swap { border-radius:24px; padding:18px; position:relative; }
    .card-swap .slab { background:#0f1520; border:1px solid #1b2633; border-radius:22px; padding:16px; margin-bottom:12px; position:relative; }
    .slab-top { display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:6px; }
    .slab-label { font-size:14px; color:var(--muted); }
    .slab-right { display:flex; flex-direction:column; align-items:flex-end; gap:6px; min-width:180px; }

    .asset-chip { display:inline-flex; align-items:center; gap:10px; }
    .chip-pill { display:inline-flex; align-items:center; gap:5px; padding:6px 8px; border-radius:999px; border:1px solid #1e2831; background:#0e1419; color:#dfe8ff; }
    .chip-btn { border:1px solid #1e2831; background:#0e1419; color:#dfe8ff; padding:6px 8px; border-radius:999px; display:inline-flex; align-items:center; gap:5px; }
    .chip-btn:hover{ filter:brightness(1.08); }
    .icon { width:32px; height:32px; border-radius:50%; background:#0b1115; object-fit:cover; display:inline-block; }

    .sell-ticker { font-size: 16px; font-weight: 500; letter-spacing: 0.2px; color: #eaf2ff; }
    .down-arrow { font-size: 13px; opacity: 0.6; margin-left: 2px; position: relative; top: -0.5px; }

    .big-input {
      width:100%; border:1px solid #1e2831; background:#0e1419; color:#fff;
      border-radius:16px; padding:10px 12px; margin-top:4px;
      font-variant-numeric: tabular-nums;
      font-size: clamp(20px, 5.4vw, 32px); line-height:1.15; font-weight:600;
    }
    .big-input.readonly { opacity:.95; background:#0b1115; border-style:dashed; }
    .big-input.error { outline:2px solid #ff6b6b55; border-color:#803c3c; }

    .rate-line { text-align:center; padding:6px 0 2px; }
    .actions { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .actions .primary {
      flex:1; padding:14px; border-radius:16px; background:var(--accent); color:#fff; border:1px solid #8b66d8;
      font-weight:800;
    }
    .actions .primary.warn { background:#5d2a2a; border-color:#7a3a3a; }
    .actions .ghost.small { padding:10px 12px; border-radius:12px; }
    .swap-header { display:flex; justify-content:flex-start; margin-bottom:8px; }

    /* Old toast (kept for compatibility) */
    .toast-wrap { position: fixed; left: 50%; top: 18px; transform: translateX(-50%); z-index: 9999; display: grid; gap: 8px; width: min(92vw, 520px); pointer-events:none; }
    .toast { pointer-events:auto; border-radius:12px; border:1px solid #2a3340; background:#101a24; color:#e7f2ff; padding:12px 14px; box-shadow:0 10px 30px rgba(0,0,0,.35); display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .toast.err { border-color:#5a2a2a; background:#201114; color:#ffd8d8; }
    .toast .x { margin-left:10px; font-size:18px; }

    /* Asset Picker Modal (Mirrasets style) */
    .picker-backdrop{position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; z-index:9997;}
    .picker-modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:9998;}
    .picker-open{display:flex;}
    .picker-inner{ width:min(540px,92vw); background:#0f1526; border:1px solid #26324a; border-radius:16px; padding:14px 14px 8px; box-shadow:0 10px 30px rgba(0,0,0,.35);}
    .picker-head{ display:flex; align-items:center; justify-content:space-between; padding:6px 6px 10px; }
    .picker-title{ font-size:16px; color:#cfe0ff; margin:0; }
    .picker-close{ background:none; border:none; color:#9bb3d9; font-size:20px; cursor:pointer; }
    .picker-body{ max-height:60vh; overflow:auto; padding:6px; }
    .asset-row{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:10px 10px; border-radius:12px; border:1px solid #1b2636; background:#0c1520; margin-bottom:8px; cursor:pointer; transition:.12s; }
    .asset-row:hover{ filter:brightness(1.06); }
    .asset-left{ display:flex; align-items:center; gap:10px; }
    .asset-meta{ display:flex; flex-direction:column; line-height:1.2; }
    .asset-code{ font-size:15px; color:#eaf2ff; font-weight:600; }
    .asset-domain{ font-size:12px; color:#9db0c6; }
    .asset-bal{ font-size:12px; color:#cfe0ff; }

    /* Swap balance popover */
    .avail-row{ display:flex; align-items:center; gap:6px; }
    .info-ico{ width:18px; height:18px; border-radius:50%; border:1px solid #2a3340; background:#0c1520; color:#cfe0ff; font-size:12px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; }

    .popover{ position:absolute; z-index:50; right:8px; top:64px; background:#0f1526; border:1px solid #26324a; border-radius:12px; padding:10px 12px; min-width:240px; max-width:320px; text-align:left; display:none; box-shadow:0 10px 30px rgba(0,0,0,.35); }
    .popover.open{ display:block; }
    .popover .line{ display:flex; justify-content:space-between; gap:10px; font-size:12px; color:#cfe0ff; padding:3px 0; }
    .popover .line .muted{ color:#9db0c6; }

    /* Rate flip */
    .rate-line { text-align: center; padding: 6px 0 2px; transition: opacity .15s; cursor: pointer; color: #9aa5b1; font-size: 13px; }
    .rate-line:hover { opacity: .85; }
    .rate-swap { display: inline-block; margin-left: 6px; opacity: 0.6; transition: opacity 0.2s, transform 0.2s; }
    .rate-line:hover .rate-swap { opacity: 1; transform: rotate(180deg); }

    /* Hide the native <select> â€“ we keep it for internal logic */
    #swapFrom { display:none; }

    /* v4 toasts (top-right) */
    .toast-v4-wrap{ position:fixed; right:18px; top:18px; z-index:9999; display:grid; gap:10px; width:min(92vw,420px); pointer-events:none; }
    .toast-v4{
      pointer-events:auto; display:grid; grid-template-columns:28px 1fr auto; align-items:start; gap:10px;
      padding:12px 14px; border-radius:14px; border:1px solid #253244; background:#0f1a24; color:#e7f2ff;
      box-shadow:0 12px 28px rgba(0,0,0,.35); transform:translateX(14px); opacity:0; animation:tv4in .18s ease-out forwards;
    }
    .toast-v4 .ico{ width:28px; height:28px; border-radius:999px; display:flex; align-items:center; justify-content:center; font-size:16px; }
    .toast-v4 .body{ line-height:1.25; }
    .toast-v4 .title{ font-weight:700; margin-bottom:2px; }
    .toast-v4 .msg{ opacity:.9; font-size:13px; }
    .toast-v4 .x{ background:none; border:none; color:#9fb2c6; font-size:18px; cursor:pointer; }
    .toast-v4.ok  { border-color:#214a3a; background:#0f1f1a; }
    .toast-v4.err { border-color:#5a2a2a; background:#201114; }
    .toast-v4.info{ border-color:#253c66; background:#0f1826; }
    .toast-v4.ok  .ico { background:#1e3c33; }
    .toast-v4.err .ico { background:#3f1b1b; }
    .toast-v4.info .ico{ background:#1a2a46; }
    @keyframes tv4in { to{ transform:translateX(0); opacity:1; } }
    @keyframes tv4out{ to{ transform:translateX(14px); opacity:0; } }

    /* spinner */
    .spinner-wrap{ display:flex; align-items:center; justify-content:center; padding:16px; }
    .ring{ width:26px; height:26px; border-radius:50%; border:3px solid #2b3950; border-top-color:#8aa3ff; animation:spin .8s linear infinite; }
    @keyframes spin{ to{ transform:rotate(360deg);} }

    /* Slippage button */
    #slipBtn {
      position:absolute; right:6px; top:-10px;
      width:34px; height:34px; border-radius:999px;
      border:1px solid #243045; background:#0f1520;
      display:flex; align-items:center; justify-content:center;
      box-shadow:0 6px 14px rgba(0,0,0,.25);
      font-size:16px; line-height:1;
    }
    #slipBtn .badge {
      position:absolute; bottom:-6px; right:-6px; font-size:10px; padding:2px 6px; border-radius:999px; background:#142233; border:1px solid #223553; color:#cfe0ff;
    }

    /* Slippage modal */
    .slip-grid{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin:10px 0; }
    .slip-opt{ padding:10px 12px; border-radius:12px; border:1px solid #2a3750; background:#0e1620; cursor:pointer; }
    .slip-opt.active{ border-color:#445ea8; box-shadow:0 0 0 2px rgba(68,94,168,.25) inset; }
    .slip-row{ display:flex; align-items:center; justify-content:center; gap:6px; }
    .slip-row input{ width:90px; text-align:center; }

    /* Locker visuals (also reused for "Usable" pill in Swap) */
    .locker-slab { background:#0f1520; border:1px solid #1b2633; border-radius:22px; padding:16px; margin-bottom:12px; position:relative; }
    .locker-pill{display:inline-flex;align-items:center;gap:6px;padding:5px 10px;border-radius:999px;background:#0e1627;border:1px solid #2a3656;color:#cfe0ff;font-size:12px}
    .locker-pill.apy{border-color:#3d2e6d;background:#1b1233;color:#d9caff;font-weight:600}
    .locker-right{display:flex;flex-direction:column;align-items:flex-end;gap:6px;margin-top:2px}
    .percent-btns button{padding:8px 10px;border-radius:10px}
    #usablePill, #swapUsablePill {cursor:pointer}

.wallet-pill {
  display:inline-flex;
  align-items:center;
  gap:8px;
  border-radius:999px;
  padding:5px 9px;
  background:#0e1419;
  border:1px solid #1e2831;
  color:#d9f6ff;
  cursor:pointer;
}
.wallet-pill:hover { filter:brightness(1.05); }

.status-pill {
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:4px 8px;
  border-radius:999px;
  border:1px solid #2a3656;
  background:#0e1627;
  color:#cfe0ff;
  font-size:11px;
}
.status-pill.vault {
  border-color:#214a3a;
  background:#0f1f1a;
  color:#cfeede;
}

/* --- Wallet identicon wrapper (circle frame, square icon inside) --- */
.ident-wrap{
  width:26px;              /* circle diameter */
  height:26px;
  border-radius:999px;
  background:#0e1419;
  border:1px solid #1e2831;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:1px;             /* space between ring and square */
  overflow:hidden;         /* keep it circular */
}

/* Square inside the circle (smaller than before) */
.ident-wrap img,
.ident-wrap canvas{
  width:16px;              /* â†“ from 18â€“20 to 16 to avoid clipping */
  height:16px;
  display:block;
  image-rendering: crisp-edges;
}

    @media (max-width: 380px){
  .ident-wrap{ width:24px; height:24px; padding:3px; }
  .ident-wrap img, .ident-wrap canvas{ border-radius:5px; }
}

    /* Lock preview row â€“ tighter label so pill fits on one line (mobile) */
.preview-row{display:flex;align-items:center;gap:4px;margin:2px 0}
.preview-row .label{min-width:68px}
@media (max-width:420px){ .preview-row .label{min-width:64px} }

    /* Locker popover */
    #usablePopover{ position:absolute; z-index:50; right:8px; top:94px; background:#0f1526; border:1px solid #26324a; border-radius:12px; padding:10px 12px; min-width:240px; max-width:320px; text-align:left; display:none; box-shadow:0 10px 30px rgba(0,0,0,.35); }
    #usablePopover.open{ display:block; }
    #usablePopover .line{ display:flex; justify-content:space-between; gap:10px; font-size:12px; color:#cfe0ff; padding:3px 0; }
    #usablePopover .muted{ color:#9db0c6; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <h1>AQUAmb Swap &amp; Lock</h1>
        <div class="row">
  <!-- Shown when NOT connected -->
  <button id="connectBtn">Connect Wallet</button>

  <!-- Shown when connected -->
<button id="walletBtn" class="ghost wallet-pill" style="display:none" title="Connected account">
<span class="ident-wrap">
  <img id="identImg" alt="" style="display:none" />
  <canvas id="identCanvas" width="16" height="16" style="display:none"></canvas>
</span>
  <span id="walletLabel" class="mono">G......G</span>
</button>

  <button id="disconnectBtn" class="ghost" disabled>Disconnect</button>
  <span id="status" class="status-pill" aria-live="polite">Not connected</span>
</div>
      </div>

      <!-- Swap -->
      <div class="section box card-swap" id="swapBox">
        <h2>Swap</h2>

        <!-- Slippage button -->
        <button id="slipBtn" title="Transaction settings">
          âš™ï¸Ž
          <span id="slipBadge" class="badge">1%</span>
        </button>

        <!-- SELL -->
        <div class="slab" style="position:relative">
          <div class="slab-top">
            <div class="slab-label">Sell</div>
            <div class="slab-right">
              <div class="asset-chip">
                <select id="swapFrom" hidden></select>
                <button id="openPicker" class="chip-btn" type="button" aria-haspopup="dialog" aria-controls="assetPicker">
                  <img id="sellIcon" class="icon" alt="" />
                  <span id="sellLabel" class="sell-ticker">Select asset</span>
                  <span class="down-arrow" aria-hidden="true">â–¾</span>
                </button>
              </div>
              <div class="avail-row">
                <!-- Usable pill (swap) -->
                <span class="small muted">Usable:</span>
                <span id="swapUsablePill" class="locker-pill" title="Tap to fill input">0</span>
                <div id="availInfo" class="info-ico" title="Details">i</div>
              </div>
            </div>
          </div>

          <input id="swapAmount" class="big-input" type="text" step="any" inputmode="decimal" placeholder="0" />

          <!-- Swap % buttons -->
          <div class="row percent-btns" style="justify-content:flex-end;margin-top:8px">
            <button data-sp="25" class="ghost small">25%</button>
            <button data-sp="50" class="ghost small">50%</button>
            <button data-sp="75" class="ghost small">75%</button>
            <button data-sp="100" class="ghost small">MAX</button>
          </div>

          <div id="availPopover" class="popover" role="dialog" aria-modal="false" aria-live="polite"></div>
        </div>

        <!-- BUY -->
        <div class="slab">
          <div class="slab-top">
            <div class="slab-label">Buy</div>
            <div class="asset-chip">
              <div class="chip-pill">
                <img id="buyIcon" class="icon" alt="AQUAmb" />
                <span>AQUAmb</span>
              </div>
            </div>
          </div>
          <input id="swapEst" class="big-input" type="text" step="any" inputmode="decimal" placeholder="0" />
        </div>

        <div class="rate-line small muted" id="rateLine" aria-live="polite"></div>

        <div class="actions">
          <button id="swapSignSubmit" class="primary">Swap to AQUAmb</button>
          <button id="swapCopy" class="ghost small">Copy XDR</button>
          <button id="btnAddTrustline" class="ghost small" style="display:none">Add AQUAmb Trustline</button>
        </div>

        <div class="toggle-row" style="margin-top:10px">
          <label for="xdrSwap" style="margin:0">Swap Transaction XDR (Soroban)</label>
          <button id="toggleSwapXdr" class="linkish small">Reveal XDR</button>
        </div>
        <textarea id="xdrSwap" rows="6" placeholder="Prepared or signed swap XDR appears here" readonly style="display:none"></textarea>

        <p id="swapResult" class="small" style="margin-top:6px" aria-live="polite"></p>

        <div class="section">
          <div class="row" style="gap:10px;margin-bottom:6px">
            <span class="muted">Validation</span>
          </div>
          <div id="validationBox" class="small">â€”</div>
        </div>
      </div>

      <!-- Locker -->
      <div class="section box" id="lockerCard">
        <h2 style="margin:0 0 8px">Locker</h2>

        <!-- hidden pubkey (used internally) -->
        <input id="pubkey" type="hidden" />

        <!-- LOCK slab -->
        <div class="locker-slab">
          <div class="slab-top">
            <div class="slab-label">Lock</div>
            <div class="asset-chip">
              <div class="chip-pill">
                <img id="lockAquaIcon" class="icon" alt="AQUAmb" />
                <span>AQUAmb</span>
              </div>
            </div>
          </div>

          <!-- Right column: usable + % buttons -->
          <div class="locker-right">
            <div class="row" style="gap:8px;align-items:center">
              <span class="muted small">Usable:</span>
              <span id="usablePill" class="locker-pill" title="Tap to fill input">0.0000000</span>
              <span id="usableInfo" title="Details" class="info-ico">i</span>
            </div>
          </div>

          <!-- Hidden balance line kept for JS but not shown -->
          <p class="small" style="margin-top:6px; display:none">AQUAmb Balance: <b id="aquaBal">-</b></p>

          <!-- Amount -->
          <input id="amount" class="big-input" type="text" step="any" placeholder="0" inputmode="decimal" />
          <div class="row percent-btns" style="justify-content:flex-end;margin-top:8px">
            <button data-p="25" class="ghost small">25%</button>
            <button data-p="50" class="ghost small">50%</button>
            <button data-p="75" class="ghost small">75%</button>
            <button data-p="100" class="ghost small">MAX</button>
          </div>
          <div id="usablePopover" role="dialog" aria-modal="false" aria-live="polite"></div>
        </div>

        <!-- Duration slab (fixed 12 months) -->
        <div class="locker-slab">
          <div class="slab-top" style="margin-bottom:4px">
            <div class="slab-label">Duration</div>
            <div class="row" style="gap:8px">
              <span class="locker-pill">12 months</span>
              <span class="locker-pill apy">7.5% APY</span>
            </div>
          </div>
        </div>

        <!-- Preview slab -->
<div class="locker-slab">
  <div class="slab-label" style="margin-bottom:6px">Lock preview</div>

  <div class="preview-row">
    <span class="small muted label">Lock Start:</span>
    <span id="whenStart" class="locker-pill">--/--/----, --:--:--</span>
  </div>

  <div class="preview-row">
    <span class="small muted label">Lock End:</span>
    <span id="whenEnd" class="locker-pill">--/--/----, --:--:-- UTC</span>
  </div>

  <div id="previewLine" class="small muted" style="margin-top:6px">
    Enter an amount to preview your lock.
  </div>
</div>

<div class="actions">
  <button id="signSubmitBtn" class="primary">Lock AQUAmb</button>
  <button id="copyBtn" class="ghost small">Copy XDR</button>
</div>

        <div class="toggle-row" style="margin-top:10px">
          <label for="xdrOut" style="margin:0">Locker Transaction XDR</label>
          <button id="toggleLockerXdr" class="linkish small">Reveal XDR</button>
        </div>
        <textarea id="xdrOut" rows="7" placeholder="Built XDR appears here" style="display:none" readonly></textarea>

        <p id="actionResult" class="small" style="margin-top:6px" aria-live="polite"></p>
      </div>
    </div>
  </div>

  <!-- Old toast container (kept) -->
  <div class="toast-wrap" id="toastWrap" aria-live="polite"></div>
  <!-- New v4 toast container (top-right) -->
  <div class="toast-v4-wrap" id="toastV4Wrap" aria-live="polite"></div>

  <!-- Connect Modal -->
  <div id="backdrop" class="backdrop"></div>
  <div id="loginModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="loginTitle">
    <div class="modal-inner">
      <div class="modal-header">
        <h2 id="loginTitle" style="font-size:18px;margin:0">Connect Wallet</h2>
        <button class="x" id="closeModal" aria-label="Close">Ã—</button>
      </div>
      <p class="small">Select a login method:</p>
      <button class="wallet-btn" id="wcBtn">ðŸ”— WalletConnect (mobile)</button>
      <button class="wallet-btn" id="freighterExtBtn">ðŸ§© Freighter (browser extension)</button>

      <div id="qrArea" class="qr-wrap" style="display:none">
        <canvas id="qrCanvas" width="256" height="256" style="background:#fff;border-radius:12px"></canvas>
        <div class="wallet-choices">
          <button id="btnLobstr">Open in LOBSTR</button>
          <button id="btnFreighter">Open in Freighter</button>
        </div>
        <div class="small">
          Scan with your wallet app (LOBSTR / Freighter), or tap a button above on mobile. Â·
          <a id="rawWcLink" class="link" href="#" target="_blank" rel="noreferrer">raw wc link</a>
        </div>
        <p id="linkStatus" class="small" style="margin:0;opacity:.8"></p>
      </div>
    </div>
  </div>

  <!-- Sign Prompt Modal -->
  <div id="signBackdrop" class="backdrop"></div>
  <div id="signModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="signTitle">
    <div class="modal-inner">
      <div class="modal-header">
        <h2 id="signTitle" style="font-size:18px;margin:0">Sign Transaction</h2>
        <button class="x" id="closeSign" aria-label="Close">Ã—</button>
      </div>
      <p class="small">
        Your transaction is ready to sign.
        <br><br>
        <b>On desktop:</b> Sign via the wallet connected via WalletConnect
        <br><br>
        <b>On mobile:</b> Open your connected wallet via the buttons below
      </p>
      <div class="wallet-choices" style="margin-top:8px">
        <button id="signLobstr">Open in LOBSTR</button>
        <button id="signFreighter">Open in Freighter</button>
      </div>
    </div>
  </div>

  <!-- Asset Picker Modal -->
  <div id="pickerBackdrop" class="picker-backdrop"></div>
  <div id="assetPicker" class="picker-modal" role="dialog" aria-modal="true" aria-labelledby="pickerTitle">
    <div class="picker-inner">
      <div class="picker-head">
        <h3 id="pickerTitle" class="picker-title">Select an asset to sell</h3>
        <button id="pickerClose" class="picker-close" aria-label="Close">Ã—</button>
      </div>
      <div id="pickerBody" class="picker-body">
        <div class="spinner-wrap"><div class="ring"></div></div>
      </div>
    </div>
  </div>

  <!-- Slippage Modal -->
  <div id="slipBackdrop" class="backdrop"></div>
  <div id="slipModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="slipTitle">
    <div class="modal-inner" style="max-width:520px">
      <div class="modal-header">
        <h2 id="slipTitle" style="font-size:18px;margin:0">Transaction settings</h2>
        <button class="x" id="slipClose" aria-label="Close">Ã—</button>
      </div>
      <p class="small" style="text-align:left">
        Swap transactions will fail if the price moves unfavorably by more than your slippage tolerance.
        Values above 1% can result in poorer execution.
      </p>
      <div class="slip-grid">
        <button class="slip-opt" data-bps="10">0.1%</button>
        <button class="slip-opt" data-bps="50">0.5%</button>
        <button class="slip-opt" data-bps="100">1%</button>
        <div class="slip-row">
          <input id="slipCustom" type="number" min="0" step="0.01" placeholder="1" aria-label="Custom %" />
          <span class="small muted">%</span>
          <button id="slipApplyCustom" class="ghost">Use</button>
        </div>
      </div>
      <button id="slipSave" class="wallet-btn" style="margin-top:6px">Save</button>
    </div>
  </div>

    <!-- Vault Guidance Modal -->
  <div id="vaultBackdrop" class="backdrop"></div>
  <div id="vaultModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="vaultTitle">
    <div class="modal-inner" style="max-width:480px">
      <div class="modal-header">
        <h2 id="vaultTitle" style="font-size:18px;margin:0">LOBSTR Vault Protected</h2>
        <button class="x" id="closeVault" aria-label="Close">Ã—</button>
      </div>

      <!-- Centered SVG logo -->
      <div style="display:flex;justify-content:center;margin:8px 0 12px;">
        <svg width="90" height="90" viewBox="0 0 244 244" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect x="3" y="3" width="238" height="238" rx="58" fill="url(#paint0_linear_2740_9594)" stroke="#411286" stroke-width="6"/>
          <path d="M151.209 108.487C153.908 71.0573 144.152 52.3425 121.941 52.3425C99.7304 52.3425 89.9744 71.0573 92.6733 108.487H76.6456C72.4688 60.1623 87.5673 36 121.941 36C156.315 36 171.414 60.1623 167.237 108.487H151.209Z" fill="url(#paint1_linear_2740_9594)"/>
          <path d="M121.941 89.7803L181.402 103.237C182.043 128.08 182.043 144.999 181.402 153.994C180.299 169.475 174.492 175.712 168.158 182.304C159.862 190.938 144.457 199.652 121.941 208.448C99.4264 199.652 84.0208 190.938 75.7248 182.304C69.3905 175.712 63.584 169.475 62.4808 153.994C61.8397 144.999 61.8397 128.08 62.4808 103.237L121.941 89.7803Z" fill="url(#paint2_linear_2740_9594)" fill-opacity="0.31"/>
          <path d="M151.039 84.5192C150.667 62.6952 140.947 51.7832 121.88 51.7832C102.813 51.7832 93.1342 62.6952 92.8438 84.5192C96.1 65.1275 105.779 55.4317 121.88 55.4317C137.981 55.4317 147.701 65.1275 151.039 84.5192Z" fill="url(#paint3_linear_2740_9594)"/>
          <path d="M121.941 89.7803L181.402 102.575C182.043 126.193 182.043 142.279 181.402 150.831C180.299 165.55 174.492 171.479 168.158 177.746C159.862 185.954 144.457 194.24 121.941 202.603C99.4264 194.24 84.0208 185.954 75.7248 177.746C69.3905 171.479 63.584 165.55 62.4808 150.831C61.8397 142.279 61.8397 126.193 62.4808 102.575L121.941 89.7803Z" fill="url(#paint4_linear_2740_9594)"/>
          <path d="M121.941 89.7803L181.402 102.575C182.043 126.193 182.043 142.279 181.402 150.831C180.299 165.55 174.492 171.479 168.158 177.746C159.862 185.954 144.457 194.24 121.941 202.603V89.7803Z" fill="url(#paint5_linear_2740_9594)"/>
          <path d="M121.942 89.7803V99.12L62.2803 111.285L62.4808 102.575L121.942 89.7803Z" fill="url(#paint6_linear_2740_9594)"/>
          <path d="M121.941 89.7803V99.12L181.611 111.217L181.416 102.566L121.941 89.7803Z" fill="url(#paint7_linear_2740_9594)"/>
          <defs>
            <linearGradient id="paint0_linear_2740_9594" x1="216.5" y1="24.5" x2="27" y2="220" gradientUnits="userSpaceOnUse">
              <stop stop-color="#5218A6"/><stop offset="1" stop-color="#9769FF"/>
            </linearGradient>
            <linearGradient id="paint1_linear_2740_9594" x1="71.5176" y1="51.0569" x2="89.4992" y2="104.069" gradientUnits="userSpaceOnUse">
              <stop stop-color="#FBF8FF"/><stop offset="1" stop-color="#D0B1FF"/>
            </linearGradient>
            <linearGradient id="paint2_linear_2740_9594" x1="198.502" y1="150.41" x2="109.64" y2="57.0717" gradientUnits="userSpaceOnUse">
              <stop/><stop offset="1" stop-color="#090114" stop-opacity="0.01"/>
            </linearGradient>
            <linearGradient id="paint3_linear_2740_9594" x1="116.076" y1="48.5008" x2="116.076" y2="55.1001" gradientUnits="userSpaceOnUse">
              <stop stop-color="#EEEEEE"/><stop offset="1" stop-color="#DAC1FF"/>
            </linearGradient>
            <linearGradient id="paint4_linear_2740_9594" x1="62" y1="165.456" x2="121.941" y2="165.456" gradientUnits="userSpaceOnUse">
              <stop stop-color="white"/><stop offset="1" stop-color="#DBC3FF"/>
            </linearGradient>
            <linearGradient id="paint5_linear_2740_9594" x1="139.305" y1="259.014" x2="212.436" y2="236.504" gradientUnits="userSpaceOnUse">
              <stop stop-color="#B27EFF"/><stop offset="1" stop-color="#B482FF"/>
            </linearGradient>
            <linearGradient id="paint6_linear_2740_9594" x1="62.2803" y1="104.205" x2="92.1109" y2="104.205" gradientUnits="userSpaceOnUse">
              <stop stop-color="white"/><stop offset="1" stop-color="#E8D8FF"/>
            </linearGradient>
            <linearGradient id="paint7_linear_2740_9594" x1="165.912" y1="117.499" x2="141.688" y2="82.0186" gradientUnits="userSpaceOnUse">
              <stop stop-color="#C7A1FF"/><stop offset="1" stop-color="#BE92FF"/>
            </linearGradient>
          </defs>
        </svg>
      </div>

      <p class="small" style="margin-top:0">
        This account is protected with <b>LOBSTR Vault</b>. Please add the additional signature in Vault to complete your transaction.
      </p>
      <ol class="steps" style="margin:6px 0 10px; text-align:left; color:#cde; font-size:14px; line-height:1.5">
        <li>Tap <b>Copy Signed XDR</b> below.</li>
        <li>Open <b>LOBSTR Vault</b> and paste the XDR into the signer.</li>
        <li>Approve the request in Vault â€“ then the transaction will submit to the network.</li>
      </ol>

      <button id="copySignedXdr" class="wallet-btn" style="margin:6px 0 10px">Copy Signed XDR</button>

      <div style="text-align:right; margin-top:4px; margin-bottom:4px;">
        <button id="toggleVaultXdr" class="linkish small" type="button">Reveal XDR</button>
      </div>
      <textarea id="signedXdrOut" rows="7" readonly class="mono" placeholder="Signed XDR will appear here" style="display:none;width:100%;"></textarea>
    </div>
  </div>

  <script>window.process = window.process || { env: {} };</script>

  <script type="module">
    import SignClient from "https://esm.sh/@walletconnect/sign-client@2.21.8";
    import QRCode     from "https://esm.sh/qrcode@1.5.3";

    // ---------- Shortcuts ----------
    const SDK = window.StellarSdk;
    if(!SDK) throw new Error("Stellar SDK failed to load.");
    const ServerCtor = (SDK.Horizon && SDK.Horizon.Server) || SDK.Server;
    if(!ServerCtor) throw new Error("Stellar SDK: Server constructor not found.");
    if(!SDK.rpc || !SDK.Address || !SDK.nativeToScVal) throw new Error("Stellar SDK UMD present but Soroban helpers missing");

    // ---------- Config ----------
    const HORIZON    = "https://horizon.stellar.org";
    const NETWORK    = SDK.Networks.PUBLIC;

    // Aquarius / Soroban
    const routerContractId = "CBQDHNBFBZYE4MKPWBSJOPIYLW4SFSXAXUTSXJN76GNKYVYPCKWC6QUK";
    const sorobanRpcUrl     = "https://mainnet.sorobanrpc.com";
    const baseApi           = "https://amm-api.aqua.network/api/external/v1";
    const networkPassphrase = NETWORK;

    // AQUA / AQUAmb
    const AQUA_CODE   = "AQUA";
    const AQUA_ISSUER = "GBNZILSTVQZ4R7IKQDGHYGY2QXL5QOFJYQMXPKWRRM5PAV7Y4M67AQUA";
    const AQUAmb_CODE   = "AQUAmb";
    const AQUAmb_ISSUER = "GDXF6SYWIQOKOZ7BACXHBFBLQZEIH25KOTTLWQK35GO3JKRNIFHHGBPC";
    const TRACKER_KEY    = "GCZWVRELD5V426NZ23LXG7BBZRDB4QRS2JRMPS5S7Z6LOFPWPPFYVMMB";

    // LOBSTR Vault signer (well-known key)
    const VAULT_KEY = "GA2T6GR7VXXXBETTERSAFETHANSORRYXXXPROTECTEDBYLOBSTRVAULT";

    // WalletConnect
    const PROJECT_ID = "f658ce3a7c8a185214974f71539fea39";
    const EXPLORER   = "https://explorer-api.walletconnect.com/v3/wallets";

    // ---------- DOM ----------
    const $=(id)=>document.getElementById(id);
    const on=(el,ev,fn)=>el&&el.addEventListener(ev,fn);
    const isIOS=()=>/iPhone|iPad|iPod/i.test(navigator.userAgent);

// New wallet pill elements
const walletBtn = $("walletBtn");
const walletLabel = $("walletLabel");
const identImg = $("identImg");
const identCanvas = $("identCanvas");

    const connectBtn=$("connectBtn"), disconnectBtn=$("disconnectBtn"), statusEl=$("status");
    const backdrop=$("backdrop"), loginModal=$("loginModal"), closeModalBtn=$("closeModal");
    const signBackdrop=$("signBackdrop"), signModal=$("signModal"), closeSign=$("closeSign");
    const qrArea=$("qrArea"), qrCanvas=$("qrCanvas"), linkStatus=$("linkStatus"), rawWcLink=$("rawWcLink");

    // Locker DOM
    const pubkeyEl=$("pubkey"), aquaBalEl=$("aquaBal"), amountEl=$("amount"),
          whenStart=$("whenStart"), whenEnd=$("whenEnd"), previewLine=$("previewLine"),
          usablePill=$("usablePill"), usableInfo=$("usableInfo"), usablePopover=$("usablePopover");
    const xdrOut=$("xdrOut"), actionResult=$("actionResult");
    const signSubmitBtn=$("signSubmitBtn"), copyBtn=$("copyBtn");
    const lockAquaIcon=$("lockAquaIcon");

    // Swap DOM
    const swapFrom=$("swapFrom"), swapAmount=$("swapAmount"),
          xdrSwap=$("xdrSwap"), swapSignSubmit=$("swapSignSubmit"),
          swapCopy=$("swapCopy"), swapResult=$("swapResult"),
          swapEst=$("swapEst"),
          toggleSwapXdr=$("toggleSwapXdr"), toggleLockerXdr=$("toggleLockerXdr"),
          validationBox=$("validationBox"), rateLine=$("rateLine"),
          btnAddTrustline=$("btnAddTrustline"),
          sellIcon=$("sellIcon"), buyIcon=$("buyIcon"),
          openPickerBtn=$("openPicker"),
          availInfo=$("availInfo"), availPopover=$("availPopover"),
          slipBtn=$("slipBtn"), slipBadge=$("slipBadge"),
          swapUsablePill=$("swapUsablePill");

    // Picker DOM
    const pickerBackdrop=$("pickerBackdrop"), assetPicker=$("assetPicker"), pickerClose=$("pickerClose"), pickerBody=$("pickerBody");
    const sellLabel=$("sellLabel");

    // Vault modal DOM
const vaultBackdrop      = $("vaultBackdrop");
const vaultModal         = $("vaultModal");
const closeVaultBtn      = $("closeVault");
const copySignedXdrBtn   = $("copySignedXdr");
const signedXdrOut       = $("signedXdrOut");
const toggleVaultXdrBtn  = $("toggleVaultXdr");

function openVaultModal(xdr){
  signedXdrOut.value = xdr || "";
  vaultBackdrop.classList.add("open");
  vaultModal.classList.add("open");
}

function closeVaultModal(){
  vaultBackdrop.classList.remove("open");
  vaultModal.classList.remove("open");
}

closeVaultBtn.addEventListener("click", closeVaultModal);
vaultBackdrop.addEventListener("click", (e)=>{
  if(e.target === vaultBackdrop) closeVaultModal();
});

copySignedXdrBtn.addEventListener("click", async ()=>{
  try {
    await navigator.clipboard.writeText(signedXdrOut.value || "");
    toast("Signed XDR copied.");
  } catch {
    toast("Clipboard failed.", true);
  }
});

toggleVaultXdrBtn.addEventListener("click", ()=>{
  const hidden = signedXdrOut.style.display === "none" || !signedXdrOut.style.display;
  signedXdrOut.style.display = hidden ? "block" : "none";
  toggleVaultXdrBtn.textContent = hidden ? "Hide XDR" : "Reveal XDR";
});

    // Slippage modal
    const slipBackdrop=$("slipBackdrop"), slipModal=$("slipModal"), slipClose=$("slipClose"),
          slipSave=$("slipSave"), slipApplyCustom=$("slipApplyCustom"), slipCustom=$("slipCustom");

    // ---------- v4 toasts ----------
    const toastV4Wrap = $("toastV4Wrap");
    function toastV4({ type="info", title="", message="", timeout=3000 } = {}){
      const el = document.createElement("div");
      el.className = `toast-v4 ${type}`;
      const icon = type==="ok" ? "âœ“" : type==="err" ? "!" : "â„¹ï¸Ž";
      el.innerHTML = `
        <div class="ico">${icon}</div>
        <div class="body">${title?`<div class="title">${title}</div>`:""}<div class="msg">${message||""}</div></div>
        <button class="x" aria-label="Close">Ã—</button>`;
      toastV4Wrap.appendChild(el);
      const close = ()=>{ el.style.animation="tv4out .16s ease-in forwards"; setTimeout(()=>el.remove(), 180); };
      el.querySelector(".x").onclick = close;
      if(timeout) setTimeout(close, timeout);
      return { close };
    }
    const toast = (msg, err=false)=> toastV4({ type:err?"err":"ok", title:err?"Error":"Done", message:msg, timeout:2600 });

    // ---------- State ----------
    let connectionMode="none"; // 'none' | 'wc' | 'freighter'
    let session=null, latestWcUri=null;
    let wcClient=null;
    let pubkey=null;

    let _server=null; const getServer=()=>(_server ||= new ServerCtor(HORIZON));
    const AQUA     = new SDK.Asset(AQUA_CODE, AQUA_ISSUER);
    const AQUAmb  = new SDK.Asset(AQUAmb_CODE, AQUAmb_ISSUER);

    let buildTimer=null;       // locker debounce
    let swapTimer=null;        // swap debounce
    let lockerRefreshTimer=null;

    // Aquarius swap state
    let lastQuote=null;
    let lastIsSend=true;       // tracks which mode produced the current XDR

    // ---------- Slippage (bps) ----------
    const LS_SLIP_KEY = "mirra_slippage_bps";
    const LS_ASSET_KEY = "mirra_last_sell_asset";
    let slippageBps = parseInt(localStorage.getItem(LS_SLIP_KEY)||"100",10); // default 1%
    function setSlipUi(){
      const pct = (slippageBps/100).toFixed(slippageBps%100===0?0:2);
      slipBadge.textContent = `${pct}%`;
      document.querySelectorAll(".slip-opt").forEach(b=>{
        b.classList.toggle("active", parseInt(b.dataset.bps,10)===slippageBps);
      });
      slipCustom.value = (slippageBps/100).toString().replace(/\.00$/,"");
    }

    // ---------- Soroban RPC ----------
    let _soro = null;
    function rpc() { if (_soro) return _soro; const Server = SDK.rpc?.Server; if (!Server) throw new Error("SorobanRpc unavailable from StellarSdk."); _soro = new Server(sorobanRpcUrl, { allowHttp: false }); return _soro; }

    // Caches
    const DOMAIN_CACHE = new Map();
    const ICON_CACHE   = new Map();

    // ---------- Icon overrides (CORS-safe) ----------
    const ICON_OVERRIDES = new Map([
      ["EURC:GDHU6WRG4IEQXM5NZ4BMPKOXHW76MZM4Y2IEMFDVXBSDP6SJY4ITNPP2", "https://static.ultrastellar.com/media/assets/img/81bd6386-74bd-4d9e-9f18-b737baf946a6.png"]
    ]);

    // ---------- Helpers ----------
    const isValidG = k => { try{return SDK.StrKey.isValidEd25519PublicKey(k);}catch{return false;} };
    const toNativeLabel = asset => (asset.isNative && asset.isNative()) ? "XLM" : (asset.code || (asset.getCode ? asset.getCode() : "asset"));
    // Number helpers (with separators)
const stripCommas = (s) => String(s||"").replace(/,/g,"");
const plain = (v) => {                     // unchanged semantics: canonical 0-7dp string
  const s = String(v);
  if(!/e/i.test(s)) return s;
  const n = Number(v);
  return n.toFixed(7).replace(/\.?0+$/,'');
};
const formatDisp = (num) => {              // for UI display: 1,234,567.1234567
  const n = Number(num);
  if(!isFinite(n)) return String(num ?? "");
  // keep up to 7dp but trim trailing zeros
  const fixed = n.toFixed(7).replace(/\.?0+$/,'');
  const [i, d] = fixed.split(".");
  const withSep = i.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  return d ? `${withSep}.${d}` : withSep;
};

    // === Stellar-style Identicon (SEP-33-like 5Ã—5 mirrored pattern) ===
function hash32(s){
  let h = 5381;
  for (let i = 0; i < s.length; i++) h = ((h << 5) + h) ^ s.charCodeAt(i);
  return (h >>> 0);
}
function seededRand(seed){
  let x = seed || 1;
  return ()=>{ x ^= x << 13; x ^= x >>> 17; x ^= x << 5; return (x>>>0)/0xFFFFFFFF; };
}
function fitHiDPICanvas(canvas, cssSize){
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.width  = cssSize * dpr;
  canvas.height = cssSize * dpr;
  // ensure CSS size remains cssSize px
  canvas.style.width  = cssSize + "px";
  canvas.style.height = cssSize + "px";
  return dpr;
}   
function drawIdenticon(canvas, accountId, cssSize=20){
  if(!canvas || !accountId) return;
  const dpr = fitHiDPICanvas(canvas, cssSize);
  const size = cssSize * dpr;
  const ctx = canvas.getContext("2d");
  const N = 5;
  const pad = Math.max(1*dpr, Math.round(size*0.08));
  const cell = Math.floor((size - pad*2) / N);
  const ox = Math.floor((size - cell*N)/2);
  const oy = Math.floor((size - cell*N)/2);

  ctx.clearRect(0,0,size,size);

  // no circular clipping â€” keep full square pattern visible
  ctx.fillStyle = "#0b1115";
  ctx.fillRect(0,0,size,size);

  const h   = hash32(accountId);
  const rng = seededRand(h);
  const hue = h % 360;
  const sat = 50 + Math.floor((h>>8)%40);
  const lig = 45 + Math.floor((h>>16)%20);
  const fill = `hsl(${hue},${sat}%,${lig}%)`;

  ctx.fillStyle = fill;
  const dotChance = 0.55;
  for(let y=0;y<N;y++){
    const row=[];
    for(let x=0;x<Math.ceil(N/2);x++) row[x] = rng() < dotChance;
    for(let x=0;x<N;x++){
      const val = x<Math.ceil(N/2)?row[x]:row[N-1-x];
      if(val) ctx.fillRect(ox + pad + x*cell, oy + pad + y*cell, cell-1, cell-1);
    }
  }
}

// --- Identicon loader: use official LOBSTR image with safe fallback ---
async function setIdenticonFor(address){
  if(!address){ 
    identImg.style.display = "none";
    identCanvas.style.display = "none";
    return;
  }

  // 1) Try official LOBSTR identicon (PNG)
  const url = `https://id.lobstr.co/${address}.png`;
  let usedImage = false;

  // Use onload/onerror to control which one is visible
  identImg.onload  = () => {
    identImg.style.display = "block";
    identCanvas.style.display = "none";
    usedImage = true;
  };
  identImg.onerror = () => {
    // Fallback if image fails
    identImg.style.display = "none";
    identCanvas.style.display = "block";
    drawIdenticon(identCanvas, address, 16);
  };

  // Assign after listeners are set
  identImg.src = url;

  // 2) Safety timeout (covers odd cases where onerror never fires)
  setTimeout(() => {
    if (!usedImage && identImg.style.display !== "block") {
      identImg.style.display = "none";
      identCanvas.style.display = "block";
      drawIdenticon(identCanvas, address, 16);
    }
  }, 1200);
}
    
// --- live numeric formatter (caret-safe, IME-safe, â‰¤7dp) ---
// Keeps commas in the integer part while typing, single dot allowed, trims to 7 dp.

function _sanitizeNumericRaw(s){
  // keep only digits and dots; collapse multiple dots
  s = String(s || "").replace(/[^\d.]/g, "");
  const parts = s.split(".");
  const head = parts.shift() || "";
  const tail = parts.join(""); // remove extra dots by joining
  return tail ? `${head}.${tail}` : head;
}

function _clampDecimals(raw, maxDp = 7){
  const [i = "", d = ""] = String(raw).split(".");
  const d7 = d.slice(0, maxDp);
  return d7 ? `${i}.${d7}` : i;
}

function _stripIntLeadingZeros(intStr){
  // "000123" -> "123", BUT keep "0" if string becomes empty
  const z = String(intStr || "").replace(/^0+(?=\d)/, "");
  return z === "" ? "0" : z;
}

function _formatIntWithCommas(intStr){
  return String(intStr || "").replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

// Maps a raw (no commas) caret index -> formatted index (with commas)
function _mapRawIdxToFmt(rawIdx, formatted){
  let seen = 0;
  for (let i = 0; i < formatted.length; i++){
    if (formatted[i] !== ",") seen++;
    if (seen >= rawIdx) return i + 1;
  }
  return formatted.length;
}

// Convert current input value to formatted-with-commas while
// preserving caret for typing/paste/delete and IME composition.
function formatAsYouType(el, { maxDp = 7 } = {}){
  if (!el || el._fmtLock) return;
  el._fmtLock = true;

  // composition guard: during IME composition, donâ€™t format
  if (el._composing) { el._fmtLock = false; return; }

  const selStart = el.selectionStart ?? el.value.length;
  const value    = String(el.value || "");

  // Build a "raw" equivalent (single dot, only digits)
  const rawAll   = _sanitizeNumericRaw(value);
  const capped   = _clampDecimals(rawAll, maxDp);

  // Determine how many *raw, non-comma* characters exist before the caret
  const before   = value.slice(0, selStart);
  const rawBefore = _sanitizeNumericRaw(before);
  let rawCaretIdx = rawBefore.length;

  // Split to integer/decimal and apply display formatting
  const [ri = "", rd = ""] = capped.split(".");
  const riNoZeros = _stripIntLeadingZeros(ri);
  const iWithCommas = _formatIntWithCommas(riNoZeros);
  const formatted = rd ? `${iWithCommas}.${rd}` : iWithCommas;

  // Special case: allow a trailing "." the user just typed
  // If user typed "." and there were no decimals yet, keep it visible
  if (value.endsWith(".") && !rd && capped.indexOf(".") >= 0) {
    // Ensure we donâ€™t add another dot if commas changed length
    const fmtNoDot = _formatIntWithCommas(_stripIntLeadingZeros(capped.replace(/\./g,"")));
    el.value = fmtNoDot + ".";
    el.setSelectionRange(el.value.length, el.value.length);
    el._fmtLock = false;
    return;
  }

  // Map caret position
  const newCaret = _mapRawIdxToFmt(rawCaretIdx, formatted);

  el.value = formatted;
  try { el.setSelectionRange(newCaret, newCaret); } catch {}

  el._fmtLock = false;
}

// Blur snap (pretty-prints using your existing formatDisp)
function formatFieldOnBlur(el){
  const val = stripCommas(el.value || "");
  if(val && isFinite(Number(val))) el.value = formatDisp(val);
}

// Utility to attach typing formatter + hooks
function attachLiveNumericFormatter(el, {
  maxDp = 7,
  onEdited,         // fires after each keystroke/paste (post-format)
  onEmpty,          // fires when field becomes empty or 0-ish
  selectAllOnFirstFocus = true, // optional extra
} = {}){
  if (!el || el._fmtAttached) return;
  el._fmtAttached = true;

  // IME composition handling
  el.addEventListener("compositionstart", ()=>{ el._composing = true; });
  el.addEventListener("compositionend",   ()=>{
    el._composing = false;
    formatAsYouType(el, { maxDp });
    onEdited && onEdited(el);
  });

  // Typing/paste
  el.addEventListener("input", ()=>{
    formatAsYouType(el, { maxDp });
    const n = Number(stripCommas(el.value || "0"));
    if (!el.value || !(n > 0)) {
      onEmpty && onEmpty(el);
    } else {
      onEdited && onEdited(el);
    }
  });

  // Optional: select-all on first focus (handy on mobile)
  if (selectAllOnFirstFocus){
    el.addEventListener("focus", function onFirstFocus(){
      // Only do this once to avoid fighting the caret on subsequent focuses
      el.removeEventListener("focus", onFirstFocus);
      try { el.select(); } catch {}
    });
  }

  // Snap to pretty on blur
  el.addEventListener("blur", ()=> formatFieldOnBlur(el));
}
const cleanAmt = (a) => {                  // accepts "1,234.56"
  const s = stripCommas(a);
  const n = Number(s);
  if(!isFinite(n) || n<=0) return null;
  return n.toFixed(7).replace(/\.0+$/,"");
};
    function contractId(asset){ return asset.contractId(NETWORK); }
    function round7(x){ return Math.floor(x * 1e7) / 1e7; }
    const shortG = g => `${g.slice(0,6)}â€¦${g.slice(-6)}`;

    async function getAvailableForCurrent(pk){
      const opt = getSelectedOption();
      if(!opt) return 0;
      if (opt.value === "XLM") {
        try { return await getSpendableXLM(pk); }
        catch { return parseFloat(opt.dataset.balance || "0"); }
      }
      const bal = parseFloat(opt.dataset.balance || "0");
      const sellLiab = parseFloat(opt.dataset.selling_liabilities || "0");
      return Math.max(bal - sellLiab, 0);
    }

    // ---------- Icon pipeline ----------
    async function fetchTomlUrlAndDomain(code, issuer){
      const url = `${HORIZON}/assets?asset_code=${encodeURIComponent(code)}&asset_issuer=${issuer}`;
      const j   = await fetch(url).then(r=>r.json()).catch(()=>null);
      const rec = j?._embedded?.records?.[0];
      const tomlUrl = rec?._links?.toml?.href || "";
      let domain = rec?.home_domain || "";
      if(!domain && tomlUrl){ try{ domain = new URL(tomlUrl).hostname; } catch(_){} }
      return { tomlUrl, domain };
    }
    function parseTomlCurrencies(t){
      const blocks = t.split(/\n\[\[CURRENCIES\]\][^\n]*\n/).slice(1);
      const items=[]; const reKV=/^\s*([A-Za-z0-9_]+)\s*=\s*"(.*?)"\s*$/;
      for(const b of blocks){ const obj={};
        for(const line of b.split(/\r?\n/)){ const m=line.match(reKV); if(m){ obj[m[1].toLowerCase()] = m[2]; } }
        if(obj.code||obj.asset_code){ items.push({ code:(obj.code||obj.asset_code||"").trim(), issuer:(obj.issuer||obj.asset_issuer||"").trim(), image:(obj.image||"").trim() }); }
      }
      return items;
    }
    async function fetchTomlTextWithFallback(tomlUrl){
      try{ const r=await fetch(tomlUrl,{cache:"force-cache"}); if(r.ok) return await r.text(); }catch(_){}
      try{ const u=new URL(tomlUrl); const alt=`https://r.jina.ai/http://${u.host}${u.pathname}`; const r2=await fetch(alt,{cache:"force-cache"}); if(r2.ok) return await r2.text(); }catch(_){}
      return "";
    }
    async function fetchAssetIcon(code, issuer){
      const key = `${code}:${issuer||""}`; if(ICON_CACHE.has(key)) return ICON_CACHE.get(key);
      if (ICON_OVERRIDES.has(key)) { const url = ICON_OVERRIDES.get(key); ICON_CACHE.set(key, url); return url; }
      try{
        const { tomlUrl } = await fetchTomlUrlAndDomain(code, issuer);
        if(!tomlUrl){ ICON_CACHE.set(key,""); return ""; }
        const txt = await fetchTomlTextWithFallback(tomlUrl);
        const items = parseTomlCurrencies(txt);
        let hit = items.find(i => i.code?.toUpperCase()===code.toUpperCase() && i.issuer?.toUpperCase()===String(issuer).toUpperCase());
        if(!hit) hit = items.find(i => i.code?.toUpperCase()===code.toUpperCase());
        const img = (hit?.image || "").trim();
        ICON_CACHE.set(key, img);
        return img;
      }catch{ ICON_CACHE.set(key,""); return ""; }
    }

    function setChipIcon(imgEl, code, issuer) {
      if (!issuer || (code || "").toUpperCase() === "XLM") {
        const xlmSvg = `
          <svg width="25" height="24" viewBox="0 0 25 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M19.7968 5.54249L17.3951 6.76612L5.79767 12.6733C5.75845 12.3742 5.73872 12.0728 5.7386 11.7712C5.74182 9.32209 7.04138 7.05775 9.15439 5.81951C11.2674 4.58127 13.878 4.55421 16.0162 5.74839L17.3909 5.04797L17.596 4.94333C15.0283 3.07965 11.6322 2.81369 8.8057 4.25491C5.97917 5.69613 4.19987 8.60095 4.2002 11.7737C4.2002 11.9886 4.20836 12.2027 4.22467 12.4159C4.2714 13.0333 3.94261 13.6183 3.39092 13.8994L2.66602 14.2691V15.9931L4.8002 14.9054L5.49134 14.5526L6.17235 14.2058L18.3985 7.97624L19.7723 7.27666L22.612 5.82941V4.1062L19.7968 5.54249Z" fill="white"/>
            <path d="M22.612 7.55469L6.86687 15.5716L5.49303 16.2728L2.66602 17.7133V19.4357L5.47362 18.0053L7.87531 16.7817L19.4846 10.8661C19.5238 11.1672 19.5435 11.4705 19.5436 11.7741C19.5421 14.2261 18.2411 16.4936 16.1249 17.7323C14.0088 18.9711 11.3946 18.9952 9.2559 17.796L9.17151 17.8408L7.68121 18.6003C10.2483 20.464 13.6437 20.7306 16.4702 19.2903C19.2968 17.8501 21.0768 14.9464 21.0778 11.7741C21.0778 11.5572 21.0694 11.3403 21.0533 11.126C21.0067 10.5088 21.3351 9.92397 21.8863 9.64245L22.612 9.27283V7.55469Z" fill="white"/>
          </svg>
        `;
        imgEl.src = "data:image/svg+xml;utf8," + encodeURIComponent(xlmSvg);
        imgEl.alt = "XLM";
        imgEl.style.background = "transparent";
        return;
      }
      fetchAssetIcon(code, issuer).then(url => {
        if (url) {
          imgEl.src = url; imgEl.alt = code; imgEl.style.background = "transparent";
        } else {
          const fallbackSvg = "data:image/svg+xml;utf8," + encodeURIComponent(`
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18">
              <rect width="100%" height="100%" rx="9" ry="9" fill="#0b1115"/>
              <text x="50%" y="54%" text-anchor="middle" dominant-baseline="middle"
                font-family="Arial, Helvetica, sans-serif" font-size="9" fill="#94a3ad">
                ${(code || "?").slice(0, 3).toUpperCase()}
              </text>
            </svg>`);
          imgEl.src = fallbackSvg; imgEl.alt = code;
        }
      }).catch(()=>{ imgEl.removeAttribute("src"); imgEl.alt = code || "asset"; });
    }

    // ---------- Spendable XLM ----------
    async function getNetworkBaseReserveXLM() {
      const r = await fetch(`${HORIZON}/ledgers?order=desc&limit=1`);
      const j = await r.json().catch(()=>null);
      const stroops = parseInt(j?._embedded?.records?.[0]?.base_reserve_in_stroops || "5000000", 10);
      return stroops / 1e7;
    }
    async function getXlmBreakdown(pk) {
      const base = await getNetworkBaseReserveXLM();
      const acc  = await fetch(`${HORIZON}/accounts/${pk}`).then(r=>r.json());
      const native = (acc.balances || []).find(b => b.asset_type === "native") || {};
      const balNative = parseFloat(native.balance || "0");
      const sellLiab  = parseFloat(native.selling_liabilities || "0");
      const sub        = parseInt(acc?.subentry_count || 0, 10);
      const sponsoring = parseInt(acc?.num_sponsoring || 0, 10);
      const sponsored  = parseInt(acc?.num_sponsored || 0, 10);
      const minBalance = base * (2 + sub + sponsoring - sponsored);
      const trustlines = (acc.balances || []).filter(b => b.asset_type !== "native" && !b.liquidity_pool_id).length;
      const lpTrust    = (acc.balances || []).filter(b => !!b.liquidity_pool_id).length;
      const signersCt  = Math.max((acc.signers?.length || 1) - 1, 0,);
      const offersCt   = parseInt(acc?.num_offers || 0, 10);
      const lineBaseReserve = base * 2;
      const lineTrustlines  = trustlines * base;
      const lineLpTrust     = lpTrust * base;
      const lineSigners     = signersCt * base;
      const lineOffers      = offersCt * base;
      const lineSponsoring  = Math.max(sponsoring - sponsored, 0) * base;
      const lineInOffers    = sellLiab;
      const feeReserve      = 2;
      const spendable = Math.max(balNative - sellLiab - minBalance - feeReserve, 0);
      return { baseReservePerEntry: round7(base), feeReserve: round7(feeReserve), xlmInOffers: round7(lineInOffers), trustlines: round7(lineTrustlines), lpTrust: round7(lineLpTrust), offers: round7(lineOffers), signers: round7(lineSigners), sponsoring: round7(lineSponsoring), totalLocked: round7(minBalance + feeReserve + sellLiab), spendable: round7(spendable), balance: round7(balNative), base };
    }
    async function getSpendableXLM(pk) { const b = await getXlmBreakdown(pk); return b.spendable; }

    walletBtn.addEventListener("click", ()=>{
  if(!pubkey) return;
  const url = `https://stellar.expert/explorer/public/account/${pubkey}`;
  window.open(url, "_blank", "noopener,noreferrer");
});

    // ---------- Connection UI ----------
    function openModal()  { backdrop.classList.add('open'); loginModal.classList.add('open'); }
    function closeModal() { backdrop.classList.remove('open'); loginModal.classList.remove('open'); }
    on(connectBtn,"click",openModal);
    on(closeModalBtn,"click",closeModal);
    on(backdrop,"click",closeModal);

    function openSignModal(){ signBackdrop.classList.add('open'); signModal.classList.add('open'); }
    function closeSignModal(){ signBackdrop.classList.remove('open'); signModal.classList.remove('open'); }
    on(closeSign,"click",closeSignModal); on(signBackdrop,"click",closeSignModal);

        async function detectVault(account){
      if(!account) {
        statusEl.textContent = "Not connected";
        statusEl.classList.remove("vault");
        return false;
      }
      try{
        const r  = await fetch(`${HORIZON}/accounts/${account}`);
        const j  = await r.json();
        const ks = (j.signers || []).map(s => s.key);
        const hasVault = ks.includes(VAULT_KEY);

        if(hasVault){
          statusEl.textContent = "LOBSTR Vault Protected";
          statusEl.classList.add("vault");
        }else{
          statusEl.textContent = connectionMode === "wc"
            ? "Connected (WalletConnect)"
            : "Connected (Freighter)";
          statusEl.classList.remove("vault");
        }
        return hasVault;
      }catch(e){
        console.warn("Vault detect failed", e);
        // Leave existing status text as-is, don't flip anything
        return false;
      }
    }

function setConnected(address, mode){
  disconnectBtn.disabled = !address;

  if(address){
    pubkey = address;
    pubkeyEl.value = address;

    // hide "Connect", show wallet pill
    connectBtn.style.display = "none";
    walletBtn.style.display  = "inline-flex";

    // shorten the G...G address and show identicon (official + fallback)
    const short = `${address.slice(0,5)}...${address.slice(-5)}`;
    walletLabel.textContent = short;
    setIdenticonFor(address);  // âœ… new helper does the image + fallback logic

    initForNewAccount();
    detectVault(address).catch(()=>{});
    startLockerAutoRefresh();
    } else {
    pubkey = null;
    pubkeyEl.value = "";

    walletBtn.style.display  = "none";
    connectBtn.style.display = "";

    statusEl.textContent = "Not connected";
    statusEl.classList.remove("vault");

    setTrustlineUI(false, true);
    usablePill.textContent = "0.0000000";
    hydrateUsablePopover({balance:0,inOffers:0,usable:0});
    swapUsablePill.textContent = "0";
  }
}

    on(disconnectBtn,"click", async ()=>{
      try{
        if(connectionMode==="wc" && wcClient && session){
          await wcClient.disconnect({ topic: session.topic, reason:{ code:6000, message:"User disconnected" }});
        }
      }catch(e){ console.warn(e); }
      session=null; connectionMode="none"; setConnected("", "none");
      xdrOut.value = ""; xdrSwap.value = ""; swapEst.value = "";
      actionResult.textContent = ""; swapResult.textContent = ""; rateLine.textContent = "";
      rateReversed = false;
      disableLockerButtons(); disableSwapButtons();
    });

    // ---------- Freighter connect ----------
    async function ensureFreighterApi(){
      if (window.freighterApi) return window.freighterApi;
      try{
        const mod = await import('https://esm.sh/@stellar/freighter-api@5.0.0');
        window.freighterApi = mod?.default ?? mod;
        return window.freighterApi;
      }catch{ return null; }
    }
    on($("freighterExtBtn"),"click", async ()=>{
      try{
        const freighter = await ensureFreighterApi();
        if(!freighter){ alert("Freighter extension not detected."); return; }
        let address = "";
        try { address = await freighter.getPublicKey(); } catch {}
        if(!address && freighter.getAddress){ const r=await freighter.getAddress(); address=r?.address||""; }
        if(!address && freighter.requestAccess){ const r=await freighter.requestAccess(); address=r?.address||""; }
        if(!address){ alert("Freighter connect denied or failed."); return; }
        connectionMode="freighter";
        closeModal();
        setConnected(address, "freighter");
        toast("Freighter connected.");
      }catch(e){ console.error(e); alert("Freighter connect failed."); }
    });

    // ---------- WalletConnect (single client) ----------
        async function purgeWcStorage(){
      try{
        Object.keys(localStorage).forEach(k=>{
          if(k.startsWith("wc@2")) localStorage.removeItem(k);
        });
      }catch{}
    }

    async function ensureClient({ retry = false } = {}){
      if(wcClient) return wcClient;
      try{
        wcClient = await SignClient.init({
          projectId: PROJECT_ID,
          relayUrl:  "wss://relay.walletconnect.com",
          metadata: {
            name: "Mirrasets Swap & Lock",
            description: "Vault-aware Aquarius swap & AQUAmb locker",
            url: location.origin,
            icons: ["https://walletconnect.com/walletconnect-logo.png"]
          }
        });

        // Clean up expired pairings (helps avoid ghost errors)
        try{
          const pairings = wcClient.core.pairing.getPairings?.() || [];
          for(const p of pairings){
            if(p.expiry && p.expiry*1000 < Date.now()){
              wcClient.core.pairing.disconnect({ topic:p.topic });
            }
          }
        }catch{}

        return wcClient;
      }catch(e){
        if(!retry && /No matching key/i.test(String(e?.message||e))){
          await purgeWcStorage();
          wcClient = null;
          return ensureClient({ retry:true });
        }
        throw e;
      }
    }
    async function getFreighterLinks(){
      try{
        const url = `${EXPLORER}?projectId=${encodeURIComponent(PROJECT_ID)}&entries=200&page=1`;
        const res = await fetch(url); const data = await res.json();
        const raw = data?.listings ?? data?.data ?? [];
        const arr = Array.isArray(raw) ? raw : Object.values(raw);
        const w = arr.find(it => ((it.name||it.app?.name||"").toLowerCase()).includes("freighter"));
        const mobile = w?.mobile || w?.app?.mobile || {};
        return { native: mobile.native||mobile.nativeLink||null, universal: mobile.universal||mobile.universalLink||null, found: !!w };
      }catch{ return {native:null,universal:null,found:false}; }
    }
    function buildCandidates(base, wcUri){
      if(!base) return [];
      const enc = encodeURIComponent(wcUri);
      if (base.includes("{wc}") || base.includes("{URI}")) return [ base.replace("{wc}",enc).replace("{URI}",enc) ];
      const j = base.includes("?") ? "&" : "?";
      return [ `${base}${j}wc=${enc}`, `${base}${j}uri=${enc}` ];
    }
    function openFreighterSmart(links, wcUri){
      const store = isIOS()? "https://apps.apple.com/app/freighter/id6743947720" : "https://play.google.com/store/apps/details?id=org.stellar.freighterwallet&pli=1";
      const natives = buildCandidates(links.native, wcUri);
      const universals = buildCandidates(links.universal, wcUri);
      let attempted=false;
      for(const href of natives){ attempted=true; window.location.href = href; setTimeout(()=>{},350); }
      if(universals.length){ attempted=true; window.open(universals[0], "_blank", "noopener"); }
      if(!attempted){ window.open(store, "_blank", "noopener"); }
    }
    function openLobstrApp(uri){
      const scheme = `lobstr://wc?uri=${encodeURIComponent(uri)}`;
      const store  = isIOS()? "https://apps.apple.com/app/id1404357892" : "https://play.google.com/store/apps/details?id=com.lobstr.client";
      const t0 = Date.now();
      window.location.href = scheme;
      setTimeout(()=>{ if(!document.hidden && Date.now()-t0<2000){ window.open(store, "_blank", "noopener"); } }, 1800);
    }

    on($("wcBtn"),"click", async ()=>{
      try{
        const sc = await ensureClient();
        toast("Starting WalletConnectâ€¦");
        const { uri, approval } = await sc.connect({
          optionalNamespaces: {
            stellar: { chains:["stellar:pubnet"], methods:["stellar_signXDR","stellar_signAndSubmitXDR"], events:[] }
          }
        });
        if(!uri) throw new Error("No WC URI");
        latestWcUri = uri;

        try { await QRCode.toCanvas(qrCanvas, uri, { width:256, margin:1 }); } catch {}
        qrArea.style.display = "flex";
        rawWcLink.href = uri;

        linkStatus.textContent = "Loading Freighter deep linkâ€¦";
        const freighterLinks = await getFreighterLinks();
        linkStatus.textContent = freighterLinks.found ? "" : "Freighter link not found â€” store fallback.";

        $("btnLobstr").onclick = ()=> openLobstrApp(latestWcUri);
        $("btnFreighter").onclick = async ()=>{
          const links = await getFreighterLinks();
          openFreighterSmart(links, latestWcUri);
        };

        session = await approval();
        connectionMode="wc";
        qrArea.style.display="none"; closeModal();

        const accounts = session.namespaces?.stellar?.accounts || [];
        const first = accounts.find(a=>a.startsWith("stellar:pubnet")) || accounts[0] || "";
        const address = first.split(":")[2] || "";
        setConnected(address, "wc");
        wcClient = sc;
      }catch(e){
        console.error(e);
        toast("Connection canceled or failed.", true);
      }
    });

    // ---------- Locker ----------
    function disableLockerButtons(){ [signSubmitBtn,copyBtn].forEach(b=>b.disabled=true); }
    function enableLockerButtons(){ const ok=!!xdrOut.value.trim(); [signSubmitBtn,copyBtn].forEach(b=>b.disabled=!ok); }

    async function loadAQUAmbBalance(pk){
      const acct = await getServer().loadAccount(pk);
      const bal = acct.balances.find(b => b.asset_code===AQUAmb_CODE && b.asset_issuer===AQUAmb_ISSUER);
      return { acct, balance: bal ? bal.balance : "0", selling_liabilities: bal ? (bal.selling_liabilities||"0") : "0" };
    }

    function scheduleLockerBuild(){
      disableLockerButtons();
      if(buildTimer) clearTimeout(buildTimer);
      buildTimer = setTimeout(async ()=>{
        const xdr = await buildLockXDR();
        if(xdr){ xdrOut.value = xdr; enableLockerButtons(); }
        else { xdrOut.value=""; disableLockerButtons(); }
      }, 600);
    }

    function updatePreviewNow(){
  const amt = Number(stripCommas(amountEl.value || "0"));

  if (!(amt > 0)) {
    // show placeholders when nothing (or 0) entered
    whenStart.textContent = "--/--/----, --:--:--";
    whenEnd.textContent   = "--/--/----, --:--:-- UTC";
    previewLine.textContent = "Enter an amount to preview your lock.";
    return;
  }

  // Valid amount: show real times
  const now = new Date();
  const end = new Date(now);
  end.setUTCFullYear(end.getUTCFullYear() + 1);
  end.setUTCHours(23, 59, 59, 0); // lock end at 23:59:59 UTC next year

  whenStart.textContent = now.toLocaleString(); // local display
  whenEnd.textContent   = end.toLocaleString(undefined, { timeZone: "UTC", timeZoneName: "short" });

  previewLine.textContent = `Locking ${formatDisp(amt)} ${AQUAmb_CODE} for 12 months`;
}

    function hydrateUsablePopover({balance=0, inOffers=0, usable=0}={}){
  usablePopover.innerHTML = `
    <div class="line"><span class="muted">AQUAmb balance</span><span>${formatDisp(balance)}</span></div>
    <div class="line"><span class="muted">In active offers</span><span>${formatDisp(inOffers)}</span></div>
    <div class="line"><span class="muted"><b>Usable</b></span><span><b>${formatDisp(usable)}</b></span></div>
  `;
}
    const openUP = ()=>usablePopover.classList.add("open");
    const closeUP= ()=>usablePopover.classList.remove("open");
    usableInfo.addEventListener("mouseenter", openUP);
    usableInfo.addEventListener("mouseleave", closeUP);
    usablePopover.addEventListener("mouseenter", openUP);
    usablePopover.addEventListener("mouseleave", closeUP);
    usableInfo.addEventListener("click",(e)=>{ e.stopPropagation(); usablePopover.classList.toggle("open"); });
    document.addEventListener("click",(e)=>{ if(!usablePopover.contains(e.target) && !usableInfo.contains(e.target)) closeUP(); },{passive:true});

    async function buildLockXDR(){
      const pk = pubkeyEl.value.trim();
      const amt = cleanAmt(amountEl.value.trim());
      if(!isValidG(pk) || !amt) { updatePreviewNow(); return null; }
      try{
        const src = await getServer().loadAccount(pk);
        const now = new Date();
        const end = new Date(now);
        end.setUTCFullYear(end.getUTCFullYear()+1);
        end.setUTCHours(23,59,59,0);
        const endTs = Math.floor(end.getTime()/1000).toString();

        // Update preview chips
        whenStart.textContent = now.toLocaleString();
        whenEnd.textContent   = end.toLocaleString(undefined,{ timeZone:"UTC", timeZoneName:"short" });
        previewLine.textContent = `Locking ${formatDisp(amt)} AQUAmb for 12 months`;

        const claimants = [
          new SDK.Claimant(pk, SDK.Claimant.predicateNot(SDK.Claimant.predicateBeforeAbsoluteTime(endTs))),
          new SDK.Claimant(TRACKER_KEY, SDK.Claimant.predicateBeforeAbsoluteTime("0"))
        ];
        const tx = new SDK.TransactionBuilder(src, { fee: "20000", networkPassphrase: NETWORK })
          .addOperation(SDK.Operation.createClaimableBalance({ asset: AQUAmb, amount: amt, claimants }))
          .setTimeout(180)
          .build();
        return tx.toXDR();
      }catch(e){ console.error(e); return null; }
    }

    attachLiveNumericFormatter(amountEl, {
  maxDp: 7,
  onEdited: ()=>{
    scheduleLockerBuild();
    updatePreviewNow();
  },
  onEmpty: ()=>{
    // When emptied, keep preview placeholders consistent
    updatePreviewNow();
  },
  selectAllOnFirstFocus: true, // optional extra
});

    document.querySelectorAll("#lockerCard [data-p]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const pct = Number(btn.dataset.p)/100;
        const currentUsable = Number(stripCommas(usablePill.textContent || "0"));
        amountEl.value = cleanAmt(currentUsable * pct) || "";
        formatFieldOnBlur(amountEl);
        scheduleLockerBuild();
        updatePreviewNow();
      });
    });

    usablePill.addEventListener("click", ()=>{
      const u = Number(stripCommas(usablePill.textContent || "0"));
      if (u>0){ amountEl.value = plain(u); scheduleLockerBuild(); updatePreviewNow(); }
      formatFieldOnBlur(amountEl);
    });

    function startLockerAutoRefresh(){
      stopLockerAutoRefresh();
      lockerRefreshTimer = setInterval(async ()=>{
        const pk = pubkeyEl.value.trim();
        if(!isValidG(pk)) return;
        try{
          const { balance, selling_liabilities } = await loadAQUAmbBalance(pk);
          const bal = Number(balance||0), liab = Number(selling_liabilities||0);
          const usable = Math.max(bal - liab, 0);
          aquaBalEl.textContent = formatDisp(bal);
          usablePill.textContent = formatDisp(usable);
          hydrateUsablePopover({balance:bal, inOffers:liab, usable});
        }catch(e){ console.warn(e); }
      }, 15000);
    }
    function stopLockerAutoRefresh(){ if(lockerRefreshTimer) clearInterval(lockerRefreshTimer); lockerRefreshTimer = null; }

    async function initForNewAccount(){
      const pk = pubkeyEl.value.trim();
      if(!isValidG(pk)) { aquaBalEl.textContent="Invalid key"; return; }
      try{
        const { balance, selling_liabilities } = await loadAQUAmbBalance(pk);
        const bal = Number(balance||0), liab = Number(selling_liabilities||0);
        const usable = Math.max(bal - liab, 0);
        aquaBalEl.textContent = formatDisp(bal);
        usablePill.textContent = formatDisp(usable);
        swapUsablePill.textContent = formatDisp(usable);
        hydrateUsablePopover({balance:bal, inOffers:liab, usable});
        updatePreviewNow();
        const { items } = await loadAllBalances(pk);
        await fetchDomainsForIssuers(items.map(i=>i.issuer).filter(Boolean).concat([AQUAmb_ISSUER]));
        fillSwapDropdownOnce(items);
        setChipIcon(buyIcon, AQUAmb_CODE, AQUAmb_ISSUER);
        setChipIcon(lockAquaIcon, AQUAmb_CODE, AQUAmb_ISSUER);
        await onValidate();
      }catch(e){ console.error(e); }
    }

    // ---------- Domains for labels ----------
    async function fetchDomainsForIssuers(issuers){
      const unique = [...new Set((issuers||[]).filter(Boolean))];
      const need = unique.filter(i => !DOMAIN_CACHE.has(i));
      await Promise.all(need.map(async (issuer)=>{
        try{
          const r = await fetch(`${HORIZON}/accounts/${issuer}`);
          const j = await r.json();
          const d = (j && j.home_domain) ? j.home_domain : "";
          DOMAIN_CACHE.set(issuer, d);
        }catch(_){ DOMAIN_CACHE.set(issuer, ""); }
      }));
    }
    const labelWithDomain = (code, issuer) => {
      if(!issuer) return `${code} Â· native`;
      const dom = DOMAIN_CACHE.get(issuer) || "";
      const right = dom || shortG(issuer);
      return `${code} Â· ${right}`;
    };

    // ---------- Swap: balances + dropdown ----------
    async function loadAllBalances(pk){
      const acct = await getServer().loadAccount(pk);
      const items = [];
      const xlmBal = acct.balances.find(b=>b.asset_type==="native");
      if (xlmBal && parseFloat(xlmBal.balance) > 0) {
        items.push({ code:"XLM", issuer:null, balance: xlmBal.balance, selling_liabilities: xlmBal.selling_liabilities || "0" });
      }
      for(const b of acct.balances){
        if(b.asset_type==="native") continue;
        if(b.liquidity_pool_id) continue;
        if(parseFloat(b.balance) <= 0) continue;
        items.push({ code:b.asset_code, issuer:b.asset_issuer, balance:b.balance, selling_liabilities: b.selling_liabilities || "0" });
      }
      return { acct, items };
    }

    function getSelectedOption(){ return swapFrom.options[swapFrom.selectedIndex] || null; }

    function setSellChip(code, issuer){
      sellLabel.textContent = code;
      setChipIcon(sellIcon, code, issuer);
    }

    function fillSwapDropdownOnce(items){
      const prev = localStorage.getItem(LS_ASSET_KEY);
      swapFrom.innerHTML = "";
      for(const it of items){
        const opt = document.createElement("option");
        opt.value = it.issuer ? `${it.code}:${it.issuer}` : "XLM";
        opt.textContent = labelWithDomain(it.code, it.issuer);
        opt.dataset.balance = it.balance;
        opt.dataset.selling_liabilities = it.selling_liabilities || "0";
        opt.dataset.code = it.code;
        if(it.issuer) opt.dataset.issuer = it.issuer;
        swapFrom.appendChild(opt);
      }
      const wanted = [...swapFrom.options].find(o=>o.value===prev);
      if (wanted) swapFrom.value = prev;
      else {
        const def = `${AQUA_CODE}:${AQUA_ISSUER}`;
        const found = [...swapFrom.options].find(o=>o.value===def);
        swapFrom.value = found ? def : (swapFrom.options[0]?.value || "");
      }
      updateSelectedAssetUI();
    }

    async function updateSelectedAssetUI(){
      const opt = getSelectedOption();
      if(!opt){ return; }
      const code = opt.dataset.code || (opt.value==="XLM"?"XLM":"ASSET");
      const issuer = opt.dataset.issuer || null;
      setSellChip(code, issuer);

      localStorage.setItem(LS_ASSET_KEY, opt.value);

      const pk = pubkeyEl.value.trim();
      let usable = 0;
      if(isValidG(pk)){
        try { usable = await getAvailableForCurrent(pk); } catch {}
      } else {
        usable = parseFloat(opt.dataset.balance || "0");
      }
      swapUsablePill.textContent = formatDisp(usable);

      onValidate().catch(()=>{});
      refreshAvailPopover().catch(()=>{});
    }

    // ---------- Trustline-aware UI ----------
    function setTrustlineUI(hasTL, forceDisableSwap){
      const notConnected = !pubkey;
      if (hasTL) {
        btnAddTrustline.style.display = "none";
        swapSignSubmit.style.display = "";
        swapCopy.style.display = "";
        swapSignSubmit.disabled = !!forceDisableSwap;
        swapCopy.disabled = !!forceDisableSwap;
        swapSignSubmit.classList.remove("warn");
      } else {
        swapSignSubmit.style.display = "none";
        swapCopy.style.display = "none";
        btnAddTrustline.style.display = "block";
        btnAddTrustline.classList.remove("ghost","small");
        btnAddTrustline.classList.add("primary","warn");
        btnAddTrustline.style.flex = "1";
        btnAddTrustline.textContent = notConnected ? "Connect to add trustline" : "Add AQUAmb Trustline";
      }
    }

    // ---------- Validators ----------
    async function hasTrustline(account, asset){
      if (asset.isNative()) return true;
      const r = await fetch(`${HORIZON}/accounts/${account}`);
      if(!r.ok) throw new Error("Horizon account lookup failed");
      const j = await r.json();
      const bal = (j.balances || []).find(b => b.asset_code === asset.code && b.asset_issuer === asset.issuer);
      return !!bal;
    }
    async function softTokenCheck(asset){
      const probe = { token_in_address:  contractId(asset), token_out_address: contractId(SDK.Asset.native()), amount: "1" };
      const r = await fetch(`${baseApi}/find-path/`, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(probe) });
      const j = await r.json().catch(()=>null);
      return !!j && (typeof j.success === "boolean");
    }
    async function onValidate(){
  const section = document.querySelector('#validationBox').closest('.section');
  try {
    const tokenIn  = getCurrentSendAsset();
    const tokenOut = AQUAmb;

    const [okIn, okOut, tl] = await Promise.all([
      softTokenCheck(tokenIn),
      softTokenCheck(tokenOut),
      pubkey ? hasTrustline(pubkey, tokenOut) : Promise.resolve(false)
    ]);

    const lines = [
      { ok: okIn,  text: "Token In recognized by Aquarius" },
      { ok: okOut, text: "Token Out recognized by Aquarius" },
      { ok: !pubkey ? null : tl, text: "Trustline: OK for output asset" }
    ];

    // Build HTML
    const html = lines.map(l => {
      if (l.ok === null) return `<div>Connect to check trustline</div>`;
      const color = l.ok ? "#57d29a" : "#ff6b6b";
      return `<div style="color:${color}">${l.text}</div>`;
    }).join("");
    validationBox.innerHTML = html;

    // Hide section if all OK
    const allOk = lines.every(l => l.ok === true);
    section.style.display = allOk ? "none" : "";

    // Update trustline-related buttons
    if (pubkey) setTrustlineUI(tl, false);
    else        setTrustlineUI(false, true);

  } catch(e){
    validationBox.innerHTML = `<span style="color:#ff6b6b">${e.message}</span>`;
    section.style.display = ""; // show if error
  }
}

    // ---------- Quotes ----------
    function getCurrentSendAsset(){
      if(!swapFrom.value || swapFrom.value === "XLM") return SDK.Asset.native();
      const [code, issuer] = (swapFrom.value||"").split(":");
      return new SDK.Asset(code, issuer);
    }

    // Exchange rate display with flip
    let rateReversed = false;
    function clearRate(){ rateLine.textContent=""; rateLine.dataset.forward=""; rateLine.dataset.inverse=""; rateLine.dataset.sendCode=""; rateReversed=false; }
function updateRateLine(sendCode, estOutPer1) {
  const rateEl = rateLine;
  if (!isFinite(estOutPer1) || estOutPer1 <= 0) { clearRate(); return; }
  const rate = round7(estOutPer1);
  const invRate = round7(1 / estOutPer1);
  rateEl.dataset.forward = rate;
  rateEl.dataset.inverse = invRate;
  rateEl.dataset.sendCode = sendCode;
  const txt = rateReversed
    ? `1 AQUAmb â‰ˆ ${formatDisp(invRate)} ${sendCode}`
    : `1 ${sendCode} â‰ˆ ${formatDisp(rate)} AQUAmb`;
  rateEl.innerHTML = `<span class="rate-text">${txt}</span><span class="rate-swap" title="Tap to flip rate">â‡„</span>`;
  rateEl.style.cursor = "pointer";
}
    rateLine.addEventListener("click", () => {
      if (!rateLine.dataset.forward) return;
      rateReversed = !rateReversed;
      const sendCode = rateLine.dataset.sendCode || "XLM";
      const rate = parseFloat(rateLine.dataset.forward || "0");
      const invRate = parseFloat(rateLine.dataset.inverse || "0");
const base = rateReversed
  ? `1 AQUAmb â‰ˆ ${formatDisp(invRate)} ${sendCode}`
  : `1 ${sendCode} â‰ˆ ${formatDisp(rate)} AQUAmb`;
      rateLine.innerHTML = `
        <span class="rate-text">${base}</span>
        <span class="rate-swap" title="Tap to flip rate">â‡„</span>
      `;
    });

    async function refreshAvailPopover(){
      const pk = pubkeyEl.value.trim();
      const opt = getSelectedOption();
      if(!opt) { availPopover.innerHTML=""; return; }

      if(opt.value === "XLM"){
        if(!isValidG(pk)){ availPopover.innerHTML=""; return; }
        const b = await getXlmBreakdown(pk);
availPopover.innerHTML = `
  <div class="line"><span class="muted">Base reserve (per entry)</span><span>${formatDisp(b.baseReservePerEntry)} XLM</span></div>
  <div class="line"><span class="muted">Fee reserve</span><span>${formatDisp(b.feeReserve)} XLM</span></div>
  <div class="line"><span class="muted">XLM in active offers</span><span>${formatDisp(b.xlmInOffers)} XLM</span></div>
  <div class="line"><span class="muted">Trustlines</span><span>${formatDisp(b.trustlines)} XLM</span></div>
  ${b.lpTrust?`<div class="line"><span class="muted">My liquidity pool trustlines</span><span>${formatDisp(b.lpTrust)} XLM</span></div>`:""}
  <div class="line"><span class="muted">Offers</span><span>${formatDisp(b.offers)} XLM</span></div>
  <div class="line"><span class="muted">Signers</span><span>${formatDisp(b.signers)} XLM</span></div>
  <div class="line"><span class="muted">Sponsoring entries for others</span><span>${formatDisp(b.sponsoring)} XLM</span></div>
  <div class="line"><span class="muted"><b>Estimated total locked</b></span><span><b>${formatDisp(b.totalLocked)} XLM</b></span></div>
`;
      } else {
  const bal = parseFloat(opt.dataset.balance || "0");
  const liab = parseFloat(opt.dataset.selling_liabilities || "0");
  availPopover.innerHTML = `
    <div class="line"><span class="muted">${opt.dataset.code} balance</span><span>${formatDisp(bal)}</span></div>
    <div class="line"><span class="muted">${opt.dataset.code} in active offers</span><span>${formatDisp(liab)}</span></div>
    <div class="line"><span class="muted"><b>Usable</b></span><span><b>${formatDisp(Math.max(bal - liab, 0))}</b></span></div>
  `;
}
    }

    function needVsAvailToast(need, avail, code){
      const msg = `Amount exceeds usable balance â€” Need: ${formatDisp(need)} ${code}, Available: ${formatDisp(avail)} ${code}`;
      toast(msg, true);
    }

    async function quoteStrictSend(){
      disableSwapButtons();
      xdrSwap.value=""; clearRate();
      const pk = pubkeyEl.value.trim();
      const sendAmt = cleanAmt(swapAmount.value.trim());
      if(!isValidG(pk) || !sendAmt) return;

      const sendAsset = getCurrentSendAsset();
      const sendLabel = toNativeLabel(sendAsset);

      try{
        const available = await getAvailableForCurrent(pk);
        if (parseFloat(sendAmt) > (available + 1e-7)) {
          needVsAvailToast(sendAmt, available, getSelectedOption()?.dataset.code || sendLabel);
          swapAmount.classList.add("error");
          xdrSwap.value = ""; clearRate();
          disableSwapButtons();
          return;
        }

        const body = {
          token_in_address:  contractId(sendAsset),
          token_out_address: contractId(AQUAmb),
          amount: String(Math.round(parseFloat(sendAmt)*1e7))
        };
        const res = await fetch(`${baseApi}/find-path/`, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
        const j = await res.json();
        if(!j?.success) throw new Error("No route from Aquarius AMM");

        lastQuote = j; lastIsSend = true;

        const outStroops = BigInt(j.amount);
        const estOut = Number(outStroops) / 1e7;

        swapEst.value = formatDisp(estOut);

        const perOne = estOut / Number(stripCommas(swapAmount.value || "1"));
        const sendCode = getSelectedOption()?.dataset.code || sendLabel;
        updateRateLine(sendCode, perOne);

        const needTL = !(await hasTrustline(pubkeyEl.value.trim(), AQUAmb));
        setTrustlineUI(!needTL, false);
        if (needTL) { enableSwapButtons(); return; }

        const inStroops = BigInt(Math.round(parseFloat(sendAmt)*1e7));
        const outMin = outStroops - (outStroops * BigInt(slippageBps) / 10000n);

        const tx = await buildSorobanSwapTx({
          account: pubkeyEl.value.trim(), isSend: true, tokenIn: sendAsset,
          inAmountStroops: inStroops,
          limitOutOrExact: outMin,
          swapChainXdr: j.swap_chain_xdr
        });
        xdrSwap.value = tx.toXDR();
        enableSwapButtons();
        onValidate().catch(()=>{});
      }catch(e){
        console.error(e);
        const msg = String(e?.message||"");
        if (msg.includes("Error(Contract, #10)") || msg.includes("resulting balance is not within the allowed range")) {
          needVsAvailToast(sendAmt, await getAvailableForCurrent(pk), getSelectedOption()?.dataset.code || sendLabel);
          swapAmount.classList.add("error");
        } else if (msg.toLowerCase().includes("auth")) {
          toast("Trustline may not be authorized for this asset.", true);
        } else {
          toast(`Aquarius quote failed (strict send). ${msg}`, true);
        }
        lastQuote=null; xdrSwap.value=""; disableSwapButtons();
      }
    }

    async function quoteStrictReceive(){
      disableSwapButtons();
      xdrSwap.value=""; clearRate();
      const pk = pubkeyEl.value.trim();
      const wantOut = cleanAmt(swapEst.value.trim());
      if(!isValidG(pk) || !wantOut) return;

      const sendAsset = getCurrentSendAsset();
      const sendLabel = toNativeLabel(sendAsset);

      try{
        const body = {
          token_in_address:  contractId(sendAsset),
          token_out_address: contractId(AQUAmb),
          amount: String(Math.round(parseFloat(wantOut)*1e7))
        };
        const res = await fetch(`${baseApi}/find-path-strict-receive/`, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
        const j = await res.json();
        if(!j?.success) throw new Error("No route from Aquarius AMM");

        lastQuote = j; lastIsSend = false;

        const inNeeded = BigInt(j.amount);
        const estIn = Number(inNeeded) / 1e7;

        swapAmount.value = formatDisp(estIn);

        const perOne = Number(wantOut) / (estIn || 1);
        const sendCode = getSelectedOption()?.dataset.code || sendLabel;
        updateRateLine(sendCode, perOne);

        // Balance guard (usable)
        const available = await getAvailableForCurrent(pk);
        const inMax = inNeeded + (inNeeded * BigInt(slippageBps) / 10000n);
        if (available * 1e7 < Number(inMax)) {
          needVsAvailToast(Number(inMax)/1e7, available, getSelectedOption()?.dataset.code || sendLabel);
          swapAmount.classList.add("error");
          lastQuote = null; xdrSwap.value = ""; disableSwapButtons();
          return;
        }

        const needTL = !(await hasTrustline(pk, AQUAmb));
        setTrustlineUI(!needTL, false);
        if (needTL) { enableSwapButtons(); return; }

        const outExact = BigInt(Math.round(parseFloat(wantOut)*1e7));
        const tx = await buildSorobanSwapTx({
          account: pk, isSend: false, tokenIn: sendAsset,
          inAmountStroops: inMax,
          limitOutOrExact: outExact,
          swapChainXdr: j.swap_chain_xdr
        });
        xdrSwap.value = tx.toXDR();
        enableSwapButtons();
        onValidate().catch(()=>{});
      }catch(e){
        console.error(e);
        const msg = String(e?.message||"");
        if (msg.includes("Error(Contract, #10)") || msg.includes("resulting balance is not within the allowed range")) {
          needVsAvailToast(swapAmount.value, await getAvailableForCurrent(pk), getSelectedOption()?.dataset.code || sendLabel);
          swapAmount.classList.add("error");
        } else if (msg.toLowerCase().includes("auth")) {
          toast("Trustline may not be authorized for this asset.", true);
        } else {
          toast(`Aquarius quote failed (strict receive). ${msg}`, true);
        }
        lastQuote=null; xdrSwap.value=""; disableSwapButtons();
      }
    }

    // ---------- Build Soroban swap tx ----------
    async function buildSorobanSwapTx({ account, isSend, tokenIn, inAmountStroops, limitOutOrExact, swapChainXdr }){
      const server = rpc();
      const acc = await server.getAccount(account);
      const router = new SDK.Contract(routerContractId);
      const tokenInCid = tokenIn.contractId(NETWORK);
      const addrAccount  = SDK.Address.fromString(account).toScVal();
      const addrTokenIn  = SDK.Address.fromString(tokenInCid).toScVal();
      const u128In       = SDK.nativeToScVal(BigInt(inAmountStroops), { type: "u128" });
      const u128LimOrEx  = SDK.nativeToScVal(BigInt(limitOutOrExact), { type: "u128" });
      const swapChainVal = SDK.xdr.ScVal.fromXDR(swapChainXdr, "base64");
      const op = isSend
        ? router.call("swap_chained", addrAccount, swapChainVal, addrTokenIn, u128In, u128LimOrEx)
        : router.call("swap_chained_strict_receive", addrAccount, swapChainVal, addrTokenIn, u128LimOrEx, u128In);
      let tx = new SDK.TransactionBuilder(acc, { fee: "20000", networkPassphrase })
        .setTimeout(300)
        .addOperation(op)
        .build();
      try { tx = await server.prepareTransaction(tx); }
      catch (e) {
        console.error("prepareTransaction failed:", e);
        const raw = String(
          e?.response?.data?.error?.message ||
          e?.data?.error?.message ||
          e?.message || "unknown"
        );
        if (raw.includes("Error(Contract, #10)") || raw.includes("resulting balance is not within the allowed range")) {
          throw new Error("Sell amount exceeds balance");
        }
        if (raw.toLowerCase().includes("auth")) throw new Error("Authorization failed for asset");
        throw new Error(`prepareTransaction failed: ${raw}`);
      }
      return tx;
    }

    // ---------- Classic trustline helper ----------
    async function buildTrustlineXDR(pk){
      const src = await getServer().loadAccount(pk);
      const tx = new SDK.TransactionBuilder(src, { fee: "10000", networkPassphrase: NETWORK })
        .addOperation(SDK.Operation.changeTrust({ asset: AQUAmb }))
        .setTimeout(180)
        .build();
      return tx.toXDR();
    }

    on(btnAddTrustline, "click", async ()=>{
      if(!pubkey){ openModal(); return; }
      try{
        const pk = pubkeyEl.value.trim();
        if(!isValidG(pk)) { toast("Connect a wallet first.", true); return; }
        if(await hasTrustline(pk, AQUAmb)){ toast("AQUAmb trustline already exists."); await onValidate(); return; }
        toast("Preparing trustline transactionâ€¦");
        const trustXdr = await buildTrustlineXDR(pk);
        toast("Signing trustlineâ€¦");
        const signed = await signCurrent(trustXdr);
        toast("Submitting trustlineâ€¦");
        const hash = await submitToHorizon(signed);
        toast(`Trustline added âœ“ tx: ${hash}`);
        await onValidate();
        await initForNewAccount();

        try {
          if (lastQuote) { if (lastIsSend) await quoteStrictSend(); else await quoteStrictReceive(); }
        } catch(_) {}
      }catch(e){
        console.error(e);
        toast(e.message || "Trustline add failed.", true);
      }
    });

    // ---------- Swap: popover + inputs ----------
    (function(){
      const isHoverCapable = window.matchMedia("(hover: hover)").matches;
      let stickyOpen = false;
      let scrollClosePending = null;

      function openPopover(){ availPopover.classList.add("open"); }
      function closePopover(){ availPopover.classList.remove("open"); stickyOpen = false; }
      function togglePopover(){ 
        const willOpen = !availPopover.classList.contains("open");
        if (willOpen) { openPopover(); stickyOpen = true; } else { closePopover(); }
      }

      if (isHoverCapable) {
        availInfo.addEventListener("mouseenter", openPopover);
        availInfo.addEventListener("mouseleave", closePopover);
        availPopover.addEventListener("mouseenter", openPopover);
        availPopover.addEventListener("mouseleave", closePopover);
        availInfo.addEventListener("click", (e)=>{ e.stopPropagation(); togglePopover(); });
        document.addEventListener("click", (e)=>{
          if (!availPopover.contains(e.target) && !availInfo.contains(e.target)) closePopover();
        });
      } else {
        availInfo.addEventListener("click", (e)=>{ e.stopPropagation(); togglePopover(); });
        document.addEventListener("click", (e)=>{
          if (!availPopover.contains(e.target) && !availInfo.contains(e.target)) closePopover();
        }, { passive:true });
        window.addEventListener("scroll", ()=>{
          if (!stickyOpen) return;
          if (scrollClosePending) return;
          scrollClosePending = setTimeout(()=>{
            closePopover();
            scrollClosePending = null;
          }, 50);
        }, { passive:true });
      }

      ["input","focus"].forEach(ev=>{
        swapAmount.addEventListener(ev, closePopover, { passive:true });
        swapEst.addEventListener(ev, closePopover, { passive:true });
      });
      swapFrom.addEventListener("change", closePopover, { passive:true });
      openPickerBtn.addEventListener("click", closePopover, { passive:true });

      async function ensureFresh(){
        if (availPopover.classList.contains("open")) {
          try { await refreshAvailPopover(); } catch(_) {}
        }
      }
      availInfo.addEventListener("click", ensureFresh);
      if (isHoverCapable){
        availInfo.addEventListener("mouseenter", ensureFresh);
      }
    })();

    function disableSwapButtons(){ [swapSignSubmit,swapCopy].forEach(b=>b.disabled=true); }
    function enableSwapButtons(){ const ok=!!xdrSwap.value.trim(); [swapSignSubmit,swapCopy].forEach(b=>b.disabled=!ok); }
    function debounceQuote(fn){ if(swapTimer) clearTimeout(swapTimer); swapTimer = setTimeout(fn, 400); }

function bindSwapInputListeners(){
  if(!swapAmount || !swapEst) return;

  // SELL -> strict send (live)
  attachLiveNumericFormatter(swapAmount, {
    maxDp: 7,
    onEdited: ()=>{
      swapAmount.classList.remove("error");
      const val = Number(stripCommas(swapAmount.value||"0"));
      if(!(val>0)){
        xdrSwap.value=""; clearRate(); disableSwapButtons(); return;
      }
      debounceQuote(quoteStrictSend);
    },
    onEmpty: ()=>{
      xdrSwap.value=""; clearRate(); disableSwapButtons();
    },
    selectAllOnFirstFocus: true,
  });

  // BUY -> strict receive (live)
  attachLiveNumericFormatter(swapEst, {
    maxDp: 7,
    onEdited: ()=>{
      swapAmount.classList.remove("error");
      const val = Number(stripCommas(swapEst.value||"0"));
      if(!(val>0)){
        xdrSwap.value=""; clearRate(); disableSwapButtons(); return;
      }
      debounceQuote(quoteStrictReceive);
    },
    onEmpty: ()=>{
      xdrSwap.value=""; clearRate(); disableSwapButtons();
    },
    selectAllOnFirstFocus: true,
  });

  // Swap % buttons (keep your logic; just snap display nicely afterwards)
  document.querySelectorAll('[data-sp]').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const pk = pubkeyEl.value.trim();
      if(!isValidG(pk)) { toast("Connect first to auto-fill balance.", true); return; }
      const pct = Number(btn.dataset.sp)/100;
      try{
        const usable = await getAvailableForCurrent(pk);
        const amt = (usable * pct);
        swapAmount.value = cleanAmt(amt) || "";
        // Format visibly and trigger send quote
        formatFieldOnBlur(swapAmount);
        quoteStrictSend();
      }catch(e){ console.error(e); toast("Could not compute balance.", true); }
    });
  });

  swapUsablePill.addEventListener('click', async ()=>{
    const pk = pubkeyEl.value.trim();
    if(!isValidG(pk)) { toast("Connect first to auto-fill balance.", true); return; }
    try{
      const usable = await getAvailableForCurrent(pk);
      swapAmount.value = cleanAmt(usable) || "";
      formatFieldOnBlur(swapAmount);
      quoteStrictSend();
    }catch(e){ console.error(e); toast("Could not compute balance.", true); }
  });

  on(swapFrom,"change", async ()=>{
    await updateSelectedAssetUI();
    swapAmount.value = ""; swapEst.value = ""; xdrSwap.value = ""; clearRate();
    swapAmount.classList.remove("error");
    disableSwapButtons();
  });

  // Toggle XDR, copy, sign, etc. (keep the rest of your original function)
  function toggleEl(el, btn){ const isHidden = el.style.display === "none" || !el.style.display; el.style.display = isHidden ? "block" : "none"; btn.textContent = isHidden ? "Hide XDR" : "Reveal XDR"; }
  on(toggleSwapXdr, "click", ()=> toggleEl(xdrSwap, toggleSwapXdr));
  on(toggleLockerXdr, "click", ()=> toggleEl(xdrOut,  toggleLockerXdr));
  on(swapCopy,"click", async ()=>{ try{ await navigator.clipboard.writeText(xdrSwap.value); swapCopy.textContent="Copied!"; setTimeout(()=>swapCopy.textContent="Copy XDR",1500);}catch(e){console.error(e);} });
  on(copyBtn,"click",  async ()=>{ try{ await navigator.clipboard.writeText(xdrOut.value);  copyBtn.textContent="Copied!";  setTimeout(()=>copyBtn.textContent="Copy XDR",1500);}catch(e){console.error(e);} });

  $("signLobstr").onclick = ()=> { if(latestWcUri) openLobstrApp(latestWcUri); };
  $("signFreighter").onclick = async ()=> {
    if(!latestWcUri) return;
    const links = await getFreighterLinks();
    openFreighterSmart(links, latestWcUri);
  };

    // Swap signing & submit
    on(swapSignSubmit,"click", async ()=>{
      if(!pubkey){ openModal(); return; }
      swapResult.textContent = "";
      try{
        const needTL = !(await hasTrustline(pubkeyEl.value.trim(), AQUAmb));
        if (needTL) { toast("Please add the AQUAmb trustline first.", true); return; }

        let xdrToSubmit = xdrSwap.value.trim();
        if(!xdrToSubmit || !/AAAA/.test(xdrToSubmit)){
          if (lastIsSend) await quoteStrictSend();
          else            await quoteStrictReceive();
          xdrToSubmit = xdrSwap.value.trim();
          if(!xdrToSubmit) throw new Error("No prepared XDR.");
        }

        if (connectionMode === "wc") openSignModal();
        toast("Check your wallet to signâ€¦");

        const signed = await signCurrent(xdrToSubmit);

        const final = await handleSignedSorobanXdr(signed);
        if(final){
          const u = BigInt(final.returnValue?.u128 ?? 0n);
          const msg = lastIsSend
            ? `Amount OUT: ${formatDisp(Number(u)/1e7)} ${AQUAmb_CODE}`
            : `Amount IN spent: ${formatDisp(Number(u)/1e7)} ${(getSelectedOption()?.dataset.code)||"asset"}`;
          swapResult.innerHTML = `Submitted âœ“ hash: ${final.hash}<br/>${msg}<br/>View: https://stellar.expert/explorer/public/tx/${final.hash}`;
          toast("Swap submitted.");
        }
        closeSignModal();

        // Refresh AQUAmb balance after a (non-Vault) swap
        if(final){
          setTimeout(async ()=>{
            const pk = pubkeyEl.value.trim();
            if(isValidG(pk)){
              try{
                const { balance, selling_liabilities } = await loadAQUAmbBalance(pk);
                const bal = Number(balance||0), liab = Number(selling_liabilities||0);
                const usable = Math.max(bal - liab, 0);
                aquaBalEl.textContent = formatDisp(bal);
                usablePill.textContent = formatDisp(usable);
                hydrateUsablePopover({balance:bal, inOffers:liab, usable});
              }catch{}
            }
          }, 1200);
        }
      }catch(e){
        console.error(e);
        closeSignModal();
        toast(e.message || "Sign/submit failed.", true);
      }
    });
}

    // ---------- Picker logic ----------
    function openPicker(){
      pickerBackdrop.classList.add("picker-open");
      assetPicker.classList.add("picker-open");
      pickerBody.innerHTML = `<div class="spinner-wrap"><div class="ring"></div></div>`;
      hydratePicker().catch((e)=>{
        pickerBody.innerHTML = `<div class="small" style="text-align:center;color:#ffb3b3">Failed to load assets: ${e?.message||"unknown"}</div>`;
      });
    }
    function closePicker(){
      pickerBackdrop.classList.remove("picker-open");
      assetPicker.classList.remove("picker-open");
      bindSwapInputListeners();
    }
    on(openPickerBtn,"click", openPicker);
    on(pickerClose,"click", closePicker);
    on(pickerBackdrop,"click", (e)=>{ if(e.target===pickerBackdrop) closePicker(); });

    async function hydratePicker(){
      const pk = pubkeyEl.value.trim();
      if(!isValidG(pk)){
        pickerBody.innerHTML = `<div class="small" style="text-align:center;color:#9db0c6">Connect a wallet to list your assets.</div>`;
        return;
      }
      const { items } = await loadAllBalances(pk);
      await fetchDomainsForIssuers(items.map(i=>i.issuer).filter(Boolean));
      const frag = document.createDocumentFragment();
      for(const it of items){
        const row = document.createElement("div");
        row.className = "asset-row";
        row.setAttribute("role","button");
        row.setAttribute("tabindex","0");
        row.innerHTML = `
          <div class="asset-left">
            <img class="icon" alt="${it.code}" />
            <div class="asset-meta">
              <span class="asset-code">${it.code}</span>
              <span class="asset-domain">${it.issuer? (DOMAIN_CACHE.get(it.issuer)||shortG(it.issuer)) : "native"}</span>
            </div>
          </div>
          <div class="asset-bal">${formatDisp(Math.max(parseFloat(it.balance||0) - parseFloat(it.selling_liabilities||0), 0))}</div>`;
        const img = row.querySelector("img.icon");
        setChipIcon(img, it.code, it.issuer||null);

        const selectValue = ()=> (it.issuer ? `${it.code}:${it.issuer}` : "XLM");

        const choose = async ()=>{
          const value = selectValue();
          swapFrom.value = value;
          await updateSelectedAssetUI();
          swapAmount.value = ""; swapEst.value=""; xdrSwap.value=""; clearRate();
          disableSwapButtons();
          closePicker();
        };

        row.addEventListener("click", choose);
        row.addEventListener("keydown", (ev)=>{ if(ev.key==="Enter"||ev.key===" "){ ev.preventDefault(); choose(); }});
        frag.appendChild(row);
      }
      pickerBody.innerHTML = "";
      pickerBody.appendChild(frag);
    }

    // ---------- Slippage modal logic ----------
    function openSlip(){ slipBackdrop.classList.add('open'); slipModal.classList.add('open'); setSlipUi(); }
    function closeSlip(){ slipBackdrop.classList.remove('open'); slipModal.classList.remove('open'); }
    on(slipBtn,"click", openSlip);
    on(slipClose,"click", closeSlip);
    on(slipBackdrop,"click", (e)=>{ if(e.target===slipBackdrop) closeSlip(); });

    document.querySelectorAll(".slip-opt").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        slippageBps = parseInt(btn.dataset.bps,10);
        setSlipUi();
      });
    });
    on(slipApplyCustom,"click", ()=>{
      const v = Math.max(0, Number(slipCustom.value||"0"));
      slippageBps = Math.round(v*100); // percent -> bps
      setSlipUi();
    });
    on(slipSave,"click", ()=>{
      localStorage.setItem(LS_SLIP_KEY, String(slippageBps));
      setSlipUi();
      toast("Slippage updated.");
      closeSlip();
      if (swapAmount.value) quoteStrictSend();
      else if (swapEst.value) quoteStrictReceive();
    });

    // ---------- First-load ----------
    window.addEventListener("load", async ()=>{
      setChipIcon(buyIcon, AQUAmb_CODE, AQUAmb_ISSUER);
      setChipIcon(lockAquaIcon, AQUAmb_CODE, AQUAmb_ISSUER);
      sellLabel.textContent = "Select asset";
      setSlipUi();
      updatePreviewNow();
      const pk = pubkeyEl.value.trim();
      if(isValidG(pk)){ await initForNewAccount(); startLockerAutoRefresh(); }
      disableLockerButtons();
      disableSwapButtons();
      bindSwapInputListeners();
    });

    // ---------- Sign helpers (shared) ----------
    const wcRequest = (method, xdr) => wcClient.request({
      topic: session.topic, chainId: "stellar:pubnet",
      request: { jsonrpc:"2.0", method, params:{ xdr } }
    });
    async function signCurrent(xdr){
      if(connectionMode==="wc"){
        const r = await wcRequest("stellar_signXDR", xdr);
        if(!r?.signedXDR) throw new Error("WalletConnect: no signedXDR");
        return r.signedXDR;
      }
      if(connectionMode==="freighter"){
        const api = await ensureFreighterApi();
        const res = await api.signTransaction(xdr, { networkPassphrase: NETWORK, accountToSign: pubkey });
        if(res?.error) throw new Error(res.error.message||"Freighter: sign failed");
        return res.signedTxXdr || res.signedXDR || res;
      }
      throw new Error("Not connected");
    }

        // Generic post-sign handler for classic (Horizon) txs
    async function handleSignedClassicXdr(signedXdr, { sourceAccountLabel = "Locker" } = {}){
      const pk = pubkeyEl.value.trim();
      const hasVault = await detectVault(pk);
      if(hasVault){
        // Do NOT submit â€“ Vault will co-sign & submit
        try{ await navigator.clipboard.writeText(signedXdr); }catch{}
        openVaultModal(signedXdr);
        actionResult.textContent = `${sourceAccountLabel} tx signed. This account requires a LOBSTR Vault co-signature â€“ follow the popup to finish.`;
        return null;
      }
      const hash = await submitToHorizon(signedXdr);
      return hash;
    }

        // Locker "Lock AQUAmb" button
    on(signSubmitBtn, "click", async ()=>{
      if (!pubkey) { 
        openModal(); 
        return; 
      }

      actionResult.textContent = "";

      try{
        // Ensure we actually have an XDR to sign
        let xdrToSign = xdrOut.value.trim();
        if (!xdrToSign || !/AAAA/.test(xdrToSign)) {
          const rebuilt = await buildLockXDR();
          if (!rebuilt) {
            toast("Enter an amount to lock first.", true);
            return;
          }
          xdrOut.value = rebuilt;
          xdrToSign    = rebuilt;
          enableLockerButtons();
        }

        // Show WC sign modal (desktop/mobile hint) if using WalletConnect
        if (connectionMode === "wc") {
          openSignModal();
        }

        toast("Check your wallet to signâ€¦");

        // Sign via WC or Freighter
        const signed = await signCurrent(xdrToSign);

        // Vault-aware handling (may submit directly or just copy for Vault)
        const hash = await handleSignedClassicXdr(signed, { sourceAccountLabel: "Locker" });

        // If hash is null, it means Vault flow (user finishes in LOBSTR Vault)
        if (hash) {
          actionResult.innerHTML = `
            Submitted âœ“ hash: ${hash}<br/>
            View: <a href="https://stellar.expert/explorer/public/tx/${hash}" target="_blank" rel="noreferrer">stellar.expert</a>
          `;
          toast("Lock submitted.");

          // Refresh AQUAmb balance / usable pills
          try{
            const { balance, selling_liabilities } = await loadAQUAmbBalance(pubkey);
            const bal  = Number(balance || 0);
            const liab = Number(selling_liabilities || 0);
            const usable = Math.max(bal - liab, 0);
            aquaBalEl.textContent   = formatDisp(bal);
            usablePill.textContent  = formatDisp(usable);
            swapUsablePill.textContent = formatDisp(usable);
            hydrateUsablePopover({ balance: bal, inOffers: liab, usable });
          }catch(e){ console.warn(e); }
        }

        closeSignModal();
      }catch(e){
        console.error(e);
        closeSignModal();
        toast(e.message || "Locker sign/submit failed.", true);
      }
    });

    // For Soroban swap txs
    async function handleSignedSorobanXdr(signedXdr){
      const pk = pubkeyEl.value.trim();
      const hasVault = await detectVault(pk);
      if(hasVault){
        try{ await navigator.clipboard.writeText(signedXdr); }catch{}
        openVaultModal(signedXdr);
        swapResult.textContent = `Swap transaction signed. This account needs a LOBSTR Vault co-signature â€“ follow the popup to complete.`;
        return null;
      }
      const final = await submitToSoroban(signedXdr);
      return final;
    }

    // ---------- Locker submit (classic) ----------
    async function submitToHorizon(signedXdr){
      const resp = await fetch(`${HORIZON}/transactions`,{ method:"POST", headers:{ "Content-Type":"application/x-www-form-urlencoded;charset=UTF-8" }, body:"tx="+encodeURIComponent(signedXdr) });
      const data = await resp.json().catch(()=> ({}));
      if(!resp.ok){
        const code = data?.extras?.result_codes?.transaction || resp.status;
        const op   = data?.extras?.result_codes?.operations || [];
        throw new Error(`Horizon error: ${code}${op.length?` (${op.join(",")})`:""}`);
      }
      return data.hash;
    }

    // Submit Soroban
    async function submitToSoroban(signedXdr){
      const tx = SDK.TransactionBuilder.fromXDR(signedXdr, NETWORK);
      const send = await rpc().sendTransaction(tx);
      if (send.status !== "PENDING" && send.status !== "SUCCESS")
        throw new Error(`Soroban send failed: ${send.status}`);
      let final = await rpc().getTransaction(send.hash);
      let tries = 0;
      while(final.status === "NOT_FOUND" && tries < 10){
        await new Promise(r=>setTimeout(r, 800));
        final = await rpc().getTransaction(send.hash);
        tries++;
      }
      if(final.status !== "SUCCESS") throw new Error(`Tx failed: ${final.status}`);
      return final;
    }

  </script>

  <!-- Freighter UMD fallback -->
  <script>
    if(!window.freighterApi){
      const s = document.createElement('script');
      s.src = "https://cdn.freighter.app/freighter-api-v1.js";
      document.head.appendChild(s);
    }
  </script>
</body>
</html>
