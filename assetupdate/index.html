<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mirrasets – Admin Control Panel (Offer IDs + XDR export)</title>
  <style>
    :root{
      --bg:#0b0f17;
      --card:#111a2b;
      --muted:#8ea0c2;
      --text:#e8eefc;
      --accent:#5eead4;
      --warn:#fbbf24;
      --bad:#fb7185;
      --ok:#34d399;
      --border:rgba(255,255,255,.08);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    body{ margin:0; background:linear-gradient(180deg,#070a10, #0b0f17 40%); color:var(--text); font-family:var(--sans); }
    .wrap{ max-width:1200px; margin:24px auto 80px; padding:0 16px; }
    .top{
      display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      padding:14px 14px; border:1px solid var(--border); border-radius:16px; background:rgba(17,26,43,.65);
      backdrop-filter: blur(6px);
    }
    .title{ display:flex; flex-direction:column; gap:2px; }
    h1{ margin:0; font-size:18px; letter-spacing:.2px; }
    .sub{ color:var(--muted); font-size:13px; line-height:1.35; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
    button{
      cursor:pointer; border:1px solid var(--border); background:#0f1b30; color:var(--text);
      padding:10px 12px; border-radius:12px; font-weight:600; font-size:13px;
    }
    button:hover{ border-color:rgba(94,234,212,.45); }
    button.primary{ background:rgba(94,234,212,.12); border-color:rgba(94,234,212,.35); }
    button.danger{ background:rgba(251,113,133,.10); border-color:rgba(251,113,133,.35); }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    .pill{
      font-family:var(--mono); font-size:12px; color:var(--muted);
      border:1px solid var(--border); background:rgba(255,255,255,.03);
      padding:6px 10px; border-radius:999px;
      max-width: 100%;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .grid{ display:grid; grid-template-columns: 1fr; gap:14px; margin-top:14px; }
    .card{
      border:1px solid var(--border); border-radius:16px; background:rgba(17,26,43,.65);
      padding:14px; overflow:hidden;
    }
    .cardHead{
      display:flex; gap:10px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap;
      margin-bottom:10px;
    }
    .assetName{ display:flex; flex-direction:column; gap:4px; }
    .assetName b{ font-size:16px; }
    .assetName small{ color:var(--muted); font-family:var(--mono); }
    .twoCol{ display:grid; grid-template-columns: 1.2fr .8fr; gap:12px; }
    @media (max-width: 980px){ .twoCol{ grid-template-columns: 1fr; } }
    .box{ border:1px solid var(--border); border-radius:14px; padding:12px; background:rgba(255,255,255,.02); }
    label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    input, textarea{
      width:100%; box-sizing:border-box;
      padding:10px 10px; border-radius:12px; border:1px solid var(--border);
      background:#0a1324; color:var(--text); font-family:var(--mono);
      outline:none;
    }
    input:focus, textarea:focus{ border-color:rgba(94,234,212,.5); }
    textarea{ min-height: 120px; resize: vertical; }
    table{ width:100%; border-collapse:collapse; font-family:var(--mono); font-size:12px; }
    th, td{ border-bottom:1px solid var(--border); padding:8px 6px; text-align:left; vertical-align:top; }
    th{ color:var(--muted); font-weight:700; }
    .hint{ color:var(--muted); font-size:12px; margin-top:6px; line-height:1.35; }
    .status{ font-size:12px; color:var(--muted); }
    .good{ color:var(--ok); }
    .warn{ color:var(--warn); }
    .bad{ color:var(--bad); }
    .mono{ font-family:var(--mono); }
    .actions{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
    .log{
      margin-top:12px; padding:12px; border-radius:14px; border:1px solid var(--border);
      background:#071022; font-family:var(--mono); font-size:12px; color:#cbd5e1;
      white-space:pre-wrap; max-height:220px; overflow:auto;
    }
    .tiny{ font-size:11px; color:var(--muted); }
    .kv{ display:flex; gap:10px; flex-wrap:wrap; }
    .copyRow{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
    .divider{ height:1px; background:var(--border); margin:10px 0; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div class="title">
      <h1>Mirrasets – Mirrored Assets Control Panel</h1>
      <div class="sub">
        Deterministic offer updates via fixed Offer IDs (no offer loading). Builds & signs once in-browser, then export signed XDR for LOBSTR Vault.
        <br><span class="warn">Security note:</span> entering secret keys in a browser is risky — do this only on a trusted machine.
      </div>
    </div>
    <div class="row">
      <span class="pill">Horizon: https://horizon.stellar.org</span>
      <span class="pill">Network: Public</span>
      <button class="primary" id="btnRefresh">Refresh balances</button>
    </div>
  </div>

  <div class="grid" id="cards"></div>

  <div class="card">
    <div class="cardHead">
      <div class="assetName">
        <b>Activity</b>
        <small>Logs</small>
      </div>
      <div class="actions">
        <button class="danger" id="btnClearLog">Clear log</button>
      </div>
    </div>
    <div class="log" id="log"></div>
    <div class="tiny">This panel does not store secrets; it only uses them in memory to sign XDR.</div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/stellar-sdk@12.2.0/dist/stellar-sdk.min.js"></script>

<script>
/**
 * CONFIG — YOUR FINAL DATA
 */
const HORIZON_URL = "https://horizon.stellar.org";
const NETWORK_PASSPHRASE = StellarSdk.Networks.PUBLIC;
const server = new StellarSdk.Horizon.Server(HORIZON_URL);

// Circle USDC (your corrected issuer)
const CIRCLE_USDC_CODE = "USDC";
const CIRCLE_USDC_ISSUER = "GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN";

// Issuer/sales wallets for each mirrored asset (asset code is the key)
const ISSUERS = {
  GBPC: "GDXF6SYWIQOKOZ7BACXHBFBLQZEIH25KOTTLWQK35GO3JKRNIFHHGBPC",
  EURC: "GAP2JFYUBSSY65FIFUN3NTUKP6MQQ52QETQEBDM25PFMQE2EEN2EEURC",
  KRWC: "GA4JBPWVFUT2FETDSMSGBYDGH4FROYB5SYKLVQO7WGNZHCSB63OIKRWC",
  USDC: "GCBYVQH3RZ4JDVFMNWETE3J6U3AW6NNGTIWNVJHNQIIEGQR4K7PLUSDC" // mirrored USDC issuer wallet
};

// Fixed offer IDs (authoritative)
const OFFER_IDS = {
  GBPC: {
    sell_05: "1679115427",
    sell_075: "1679115428",
    sell_10: "1679115429",
    buy: "1679115430"
  },
  EURC: {
    sell_05: "1679202926",
    sell_075: "1679202927",
    sell_10: "1679202928",
    buy: "1679202929"
  },
  KRWC: {
    sell_05: "1679204936",
    sell_075: "1679204937",
    sell_10: "1679204938",
    buy: "1679204939"
  },
  USDC: {
    buy: "1688920720"
  }
};

// Tier sizes & spreads
const RULES = {
  GBPC: { sellAmounts:[40000, 80000, 120000], sellSpreads:[0.005, 0.0075, 0.01], buySpread:0.01 },
  EURC: { sellAmounts:[50000, 100000, 150000], sellSpreads:[0.005, 0.0075, 0.01], buySpread:0.01 },
  KRWC: { sellAmounts:[72000000, 144000000, 216000000], sellSpreads:[0.005, 0.0075, 0.01], buySpread:0.01 },
  // Mirrored USDC: only update BUY at 0.995, leave huge 1:1 sell alone
  USDC: { buyFixedCirclePerMirrored: 0.995 }
};

const state = {
  balances: {
    GBPC: { circleUSDC: null },
    EURC: { circleUSDC: null },
    KRWC: { circleUSDC: null },
    USDC: { circleUSDC: null }
  }
};

const elLog = document.getElementById("log");
function log(msg){
  const t = new Date().toISOString().replace("T"," ").replace("Z","");
  elLog.textContent += `[${t}] ${msg}\n`;
  elLog.scrollTop = elLog.scrollHeight;
}
function fmt(n, dp=7){ return Number(n).toLocaleString(undefined,{maximumFractionDigits:dp}); }
function fmtStrict(n, dp=7){
  const x = Number(n);
  if (!Number.isFinite(x)) throw new Error("Bad number");
  // Stellar amounts/price are strings; avoid locale formatting
  return x.toFixed(dp).replace(/\.?0+$/,"");
}
function makeAsset(code, issuer){ return new StellarSdk.Asset(code, issuer); }
function isNative(b){ return b.asset_type === "native"; }

function findBalance(balances, code, issuer){
  const b = balances.find(x => x.asset_type !== "native" && x.asset_code === code && x.asset_issuer === issuer);
  return b ? Number(b.balance) : 0;
}

async function loadCircleBalance(pubKey){
  const acct = await server.loadAccount(pubKey);
  const balances = acct.balances.map(b => ({
    asset_type: b.asset_type,
    asset_code: b.asset_code || "XLM",
    asset_issuer: b.asset_issuer || "",
    balance: b.balance
  }));
  return findBalance(balances, CIRCLE_USDC_CODE, CIRCLE_USDC_ISSUER);
}

function computeQuotes(code, midCirclePerAsset){
  // midCirclePerAsset = Circle USDC per 1 mirrored unit
  if (code === "USDC"){
    const buyCirclePerMirrored = RULES.USDC.buyFixedCirclePerMirrored; // 0.995
    const buyMirroredPerCircle = 1 / buyCirclePerMirrored;
    return { buyCirclePerMirrored, buyMirroredPerCircle };
  }

  const mid = Number(midCirclePerAsset);
  if (!Number.isFinite(mid) || mid <= 0) throw new Error("Bad XE mid price");

  const r = RULES[code];
  const sellTiers = r.sellSpreads.map((s,i)=>({
    key: i===0 ? "sell_05" : i===1 ? "sell_075" : "sell_10",
    spread:s,
    amount:r.sellAmounts[i],
    priceCirclePerAsset: mid * (1 + s)
  }));

  const buyCirclePerAsset = mid * (1 - r.buySpread);
  const buyAssetPerCircle = 1 / buyCirclePerAsset;

  return { mid, sellTiers, buyCirclePerAsset, buyAssetPerCircle };
}

function buildCards(){
  const root = document.getElementById("cards");
  root.innerHTML = "";

  for (const code of ["GBPC","EURC","KRWC","USDC"]){
    const issuer = ISSUERS[code];
    const isUSDC = code === "USDC";

    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
      <div class="cardHead">
        <div class="assetName">
          <b>${code}</b>
          <small>${issuer}</small>
        </div>
        <div class="kv">
          <span class="pill" id="pill-bal-${code}">Circle USDC reserve: —</span>
          <span class="pill" id="pill-offids-${code}">Offer IDs: ${isUSDC ? OFFER_IDS.USDC.buy : Object.values(OFFER_IDS[code]).join(", ")}</span>
        </div>
      </div>

      <div class="twoCol">
        <div class="box">
          <div style="display:flex; gap:12px; flex-wrap:wrap;">
            <div style="flex:1 1 320px;">
              <label>Secret key for this issuing wallet (starts with S…)</label>
              <input id="inp-sk-${code}" placeholder="S.................................................." autocomplete="off" />
              <div class="hint">Used only to sign the built transaction once. Then you export signed XDR for LOBSTR Vault.</div>
            </div>

            <div style="flex:1 1 240px;">
              <label>${isUSDC ? "Mirrored USDC buy is fixed at 0.995 (Circle USDC per 1 Mirrored USDC)" : "Paste XE mid (Circle USDC per 1 " + code + ")"}</label>
              <input id="inp-mid-${code}" ${isUSDC ? "value='1' disabled" : "placeholder='e.g. 1.27456'"} />
              <div class="hint">
                ${isUSDC
                  ? "This wallet issues Mirrored USDC (asset code USDC, issuer is this wallet). Only updates BUY offer at 0.995 using full Circle USDC reserve."
                  : "SELL tiers: +0.5%, +0.75%, +1.0%. BUY: −1.0% using full Circle USDC reserve."
                }
              </div>
            </div>
          </div>

          <div class="actions" style="margin-top:10px;">
            <button id="btn-preview-${code}">Preview</button>
            <button class="primary" id="btn-build-${code}">Build + sign (export XDR)</button>
          </div>

          <div style="margin-top:12px;">
            <table id="tbl-${code}">
              <thead>
                <tr>
                  <th>Offer</th>
                  <th>Direction</th>
                  <th>Offer ID</th>
                  <th>Amount (selling)</th>
                  <th>Price</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
            <div class="hint" id="hint-${code}"></div>
          </div>

          <div class="divider"></div>

          <div>
            <label>Signed XDR (base64)</label>
            <textarea id="out-xdr-${code}" placeholder="Click Build + sign to generate…" readonly></textarea>
            <div class="copyRow">
              <button id="btn-copy-${code}">Copy XDR</button>
            </div>
            <div class="tiny">Paste into LOBSTR Vault → Transaction XDR. This XDR already has the first signature.</div>
          </div>
        </div>

        <div class="box">
          <label>Reserve snapshot</label>
          <div class="log" id="snap-${code}" style="max-height:330px;"></div>
          <div class="tiny">
            This panel only loads balances/sequence (no offers), so refresh is fast and reliable.
          </div>
        </div>
      </div>
    `;

    root.appendChild(card);

    document.getElementById(`btn-preview-${code}`).addEventListener("click", ()=>preview(code));
    document.getElementById(`btn-build-${code}`).addEventListener("click", ()=>buildAndSign(code));
    document.getElementById(`btn-copy-${code}`).addEventListener("click", ()=>copyXDR(code));
  }
}

function setPillsAndSnapshot(code, circleBal){
  state.balances[code].circleUSDC = circleBal;

  const pill = document.getElementById(`pill-bal-${code}`);
  pill.textContent = `Circle USDC reserve: ${fmt(circleBal, 2)}`;

  const snap = document.getElementById(`snap-${code}`);
  snap.textContent =
`Issuer wallet: ${ISSUERS[code]}
Circle USDC issuer: ${CIRCLE_USDC_ISSUER}
Circle USDC reserve balance: ${circleBal}

Note:
- Buy offer uses FULL Circle USDC reserve as 'amount selling'
- Offer IDs are fixed and edited deterministically`;
}

async function refreshAll(){
  log("Refreshing Circle USDC balances (parallel)…");

  const codes = ["GBPC","EURC","KRWC","USDC"];

  const jobs = codes.map(async (code)=>{
    try{
      const bal = await loadCircleBalance(ISSUERS[code]);
      setPillsAndSnapshot(code, bal);
      preview(code);
      log(`${code}: loaded Circle USDC reserve ${fmt(bal, 2)}`);
      return true;
    }catch(e){
      log(`${code}: failed to load balance: ${e?.message || e}`);
      document.getElementById(`hint-${code}`).innerHTML = `<span class="bad">Failed to load balance: ${e?.message || e}</span>`;
      return false;
    }
  });

  await Promise.all(jobs);
  log("Refresh complete.");
}

function preview(code){
  const tbody = document.querySelector(`#tbl-${code} tbody`);
  const hint = document.getElementById(`hint-${code}`);
  tbody.innerHTML = "";
  hint.textContent = "";

  const circleBal = state.balances[code].circleUSDC;
  if (circleBal === null || circleBal === undefined){
    hint.innerHTML = `<span class="warn">No balance yet. Click “Refresh balances”.</span>`;
    return;
  }

  let q;
  try{
    if (code === "USDC") {
      q = computeQuotes("USDC", 1);
    } else {
      const mid = document.getElementById(`inp-mid-${code}`).value.trim();
      if (!mid) throw new Error("Paste XE mid first.");
      q = computeQuotes(code, mid);
    }
  }catch(e){
    hint.innerHTML = `<span class="bad">${e.message || e}</span>`;
    return;
  }

  const rows = [];
  if (code !== "USDC"){
    rows.push({
      label: `SELL +0.5%`,
      dir: `${code} → Circle USDC`,
      id: OFFER_IDS[code].sell_05,
      amount: RULES[code].sellAmounts[0],
      price: `${fmt(q.sellTiers[0].priceCirclePerAsset, 10)} Circle/${code}`
    });
    rows.push({
      label: `SELL +0.75%`,
      dir: `${code} → Circle USDC`,
      id: OFFER_IDS[code].sell_075,
      amount: RULES[code].sellAmounts[1],
      price: `${fmt(q.sellTiers[1].priceCirclePerAsset, 10)} Circle/${code}`
    });
    rows.push({
      label: `SELL +1.0%`,
      dir: `${code} → Circle USDC`,
      id: OFFER_IDS[code].sell_10,
      amount: RULES[code].sellAmounts[2],
      price: `${fmt(q.sellTiers[2].priceCirclePerAsset, 10)} Circle/${code}`
    });

    rows.push({
      label: `BUY −1.0% (full reserve)`,
      dir: `Circle USDC → ${code}`,
      id: OFFER_IDS[code].buy,
      amount: fmt(circleBal, 2),
      price: `${fmt(q.buyCirclePerAsset, 10)} Circle/${code}  (offer price = ${fmt(q.buyAssetPerCircle, 14)} ${code}/Circle)`
    });

    hint.innerHTML = `<span class="status">Mid: <span class="mono">${fmt(q.mid, 10)}</span> • Buy: <span class="mono">${fmt(q.buyCirclePerAsset, 10)}</span> Circle/${code}</span>`;
  } else {
    rows.push({
      label: `BUY @ 0.995 (full reserve)`,
      dir: `Circle USDC → Mirrored USDC`,
      id: OFFER_IDS.USDC.buy,
      amount: fmt(circleBal, 2),
      price: `${fmt(q.buyCirclePerMirrored, 6)} Circle/MirroredUSDC  (offer price = ${fmt(q.buyMirroredPerCircle, 14)} Mirrored/Circle)`
    });

    hint.innerHTML = `<span class="status">Mirrored USDC: only BUY updated at 0.995. (Huge SELL at 1.000 untouched.)</span>`;
  }

  for (const r of rows){
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${r.label}</td>
      <td>${r.dir}</td>
      <td class="mono">${r.id}</td>
      <td>${r.amount}</td>
      <td>${r.price}</td>
    `;
    tbody.appendChild(tr);
  }
}

async function buildAndSign(code){
  const out = document.getElementById(`out-xdr-${code}`);
  out.value = "";

  const pub = ISSUERS[code];
  const circleBal = state.balances[code].circleUSDC;

  if (circleBal === null || circleBal === undefined){
    alert("No balance yet. Click Refresh balances first.");
    return;
  }

  // secret key
  const skEl = document.getElementById(`inp-sk-${code}`);
  const sk = skEl.value.trim();
  if (!sk || !sk.startsWith("S")){
    alert("Paste the secret key for this issuing wallet (starts with S…).");
    return;
  }

  let kp;
  try{
    kp = StellarSdk.Keypair.fromSecret(sk);
  }catch(e){
    alert("Invalid secret key format.");
    return;
  }
  if (kp.publicKey() !== pub){
    alert(`Secret key does not match issuer address for ${code}.\nExpected: ${pub}\nGot: ${kp.publicKey()}`);
    return;
  }

  // quotes
  let q;
  try{
    if (code === "USDC") {
      q = computeQuotes("USDC", 1);
    } else {
      const mid = document.getElementById(`inp-mid-${code}`).value.trim();
      if (!mid) throw new Error("Paste XE mid first.");
      q = computeQuotes(code, mid);
    }
  }catch(e){
    alert(e.message || e);
    return;
  }

  log(`${code}: building tx (deterministic offerId edits)…`);

  // load fresh account for sequence + base fee
  let acct, baseFee;
  try{
    acct = await server.loadAccount(pub);
    baseFee = await server.fetchBaseFee();
  }catch(e){
    log(`${code}: failed loading account/base fee: ${e?.message || e}`);
    alert(`Failed to load account/base fee: ${e?.message || e}`);
    return;
  }

  const circle = makeAsset(CIRCLE_USDC_CODE, CIRCLE_USDC_ISSUER);
  const mirrored = makeAsset(code, pub);

  const txb = new StellarSdk.TransactionBuilder(acct, {
    fee: (Number(baseFee) * 2).toString(),
    networkPassphrase: NETWORK_PASSPHRASE
  });

  if (code !== "USDC"){
    // 3 SELL tiers: selling mirrored, buying circle
    txb.addOperation(StellarSdk.Operation.manageSellOffer({
      offerId: OFFER_IDS[code].sell_05,
      selling: mirrored,
      buying: circle,
      amount: fmtStrict(RULES[code].sellAmounts[0], 7),
      price: fmtStrict(q.sellTiers[0].priceCirclePerAsset, 12)
    }));
    txb.addOperation(StellarSdk.Operation.manageSellOffer({
      offerId: OFFER_IDS[code].sell_075,
      selling: mirrored,
      buying: circle,
      amount: fmtStrict(RULES[code].sellAmounts[1], 7),
      price: fmtStrict(q.sellTiers[1].priceCirclePerAsset, 12)
    }));
    txb.addOperation(StellarSdk.Operation.manageSellOffer({
      offerId: OFFER_IDS[code].sell_10,
      selling: mirrored,
      buying: circle,
      amount: fmtStrict(RULES[code].sellAmounts[2], 7),
      price: fmtStrict(q.sellTiers[2].priceCirclePerAsset, 12)
    }));

    // BUY offer: selling circle, buying mirrored; amount = full reserve
    txb.addOperation(StellarSdk.Operation.manageSellOffer({
      offerId: OFFER_IDS[code].buy,
      selling: circle,
      buying: mirrored,
      amount: fmtStrict(Math.max(circleBal, 0), 7),
      price: fmtStrict(q.buyAssetPerCircle, 12) // mirrored per circle
    }));
  } else {
    // Mirrored USDC: only BUY at 0.995; do not touch the big sell
    txb.addOperation(StellarSdk.Operation.manageSellOffer({
      offerId: OFFER_IDS.USDC.buy,
      selling: circle,
      buying: mirrored,
      amount: fmtStrict(Math.max(circleBal, 0), 7),
      price: fmtStrict(q.buyMirroredPerCircle, 12) // mirrored per circle
    }));
  }

  const tx = txb.setTimeout(120).build();

  // sign once
  tx.sign(kp);

  const signedXDR = tx.toXDR();
  out.value = signedXDR;

  // wipe input to reduce exposure
  skEl.value = "";

  log(`${code}: ✅ signed XDR generated (${signedXDR.length} chars).`);
}

async function copyXDR(code){
  const out = document.getElementById(`out-xdr-${code}`);
  const v = out.value.trim();
  if (!v){ alert("No XDR yet. Click Build + sign."); return; }
  await navigator.clipboard.writeText(v);
  log(`${code}: XDR copied to clipboard.`);
}

// init
buildCards();
document.getElementById("btnRefresh").addEventListener("click", refreshAll);
document.getElementById("btnClearLog").addEventListener("click", ()=>{ elLog.textContent=""; });

log("Ready. Click “Refresh balances”.");
</script>
</body>
</html>
