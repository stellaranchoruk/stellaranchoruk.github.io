<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mirrasets – Admin Control Panel (Offer IDs + Live-price sequencing + XDR export)</title>
  <style>
    :root{
      --bg:#0b0f17;
      --card:#111a2b;
      --muted:#8ea0c2;
      --text:#e8eefc;
      --accent:#5eead4;
      --warn:#fbbf24;
      --bad:#fb7185;
      --ok:#34d399;
      --border:rgba(255,255,255,.08);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    body{ margin:0; background:linear-gradient(180deg,#070a10, #0b0f17 40%); color:var(--text); font-family:var(--sans); }
    .wrap{ max-width:1200px; margin:24px auto 80px; padding:0 16px; }
    .top{
      display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      padding:14px 14px; border:1px solid var(--border); border-radius:16px; background:rgba(17,26,43,.65);
      backdrop-filter: blur(6px);
    }
    .title{ display:flex; flex-direction:column; gap:2px; }
    h1{ margin:0; font-size:18px; letter-spacing:.2px; }
    .sub{ color:var(--muted); font-size:13px; line-height:1.35; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
    button{
      cursor:pointer; border:1px solid var(--border); background:#0f1b30; color:var(--text);
      padding:10px 12px; border-radius:12px; font-weight:600; font-size:13px;
    }
    button:hover{ border-color:rgba(94,234,212,.45); }
    button.primary{ background:rgba(94,234,212,.12); border-color:rgba(94,234,212,.35); }
    button.danger{ background:rgba(251,113,133,.10); border-color:rgba(251,113,133,.35); }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    .pill{
      font-family:var(--mono); font-size:12px; color:var(--muted);
      border:1px solid var(--border); background:rgba(255,255,255,.03);
      padding:6px 10px; border-radius:999px;
      max-width: 100%;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .grid{ display:grid; grid-template-columns: 1fr; gap:14px; margin-top:14px; }
    .card{
      border:1px solid var(--border); border-radius:16px; background:rgba(17,26,43,.65);
      padding:14px; overflow:hidden;
    }
    .cardHead{
      display:flex; gap:10px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap;
      margin-bottom:10px;
    }
    .assetName{ display:flex; flex-direction:column; gap:4px; }
    .assetName b{ font-size:16px; }
    .assetName small{ color:var(--muted); font-family:var(--mono); }
    .twoCol{ display:grid; grid-template-columns: 1.2fr .8fr; gap:12px; }
    @media (max-width: 980px){ .twoCol{ grid-template-columns: 1fr; } }
    .box{ border:1px solid var(--border); border-radius:14px; padding:12px; background:rgba(255,255,255,.02); }
    label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    input, textarea{
      width:100%; box-sizing:border-box;
      padding:10px 10px; border-radius:12px; border:1px solid var(--border);
      background:#0a1324; color:var(--text); font-family:var(--mono);
      outline:none;
    }
    input:focus, textarea:focus{ border-color:rgba(94,234,212,.5); }
    textarea{ min-height: 120px; resize: vertical; }
    table{ width:100%; border-collapse:collapse; font-family:var(--mono); font-size:12px; }
    th, td{ border-bottom:1px solid var(--border); padding:8px 6px; text-align:left; vertical-align:top; }
    th{ color:var(--muted); font-weight:700; }
    .hint{ color:var(--muted); font-size:12px; margin-top:6px; line-height:1.35; }
    .status{ font-size:12px; color:var(--muted); }
    .good{ color:var(--ok); }
    .warn{ color:var(--warn); }
    .bad{ color:var(--bad); }
    .mono{ font-family:var(--mono); }
    .actions{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
    .log{
      margin-top:12px; padding:12px; border-radius:14px; border:1px solid var(--border);
      background:#071022; font-family:var(--mono); font-size:12px; color:#cbd5e1;
      white-space:pre-wrap; max-height:220px; overflow:auto;
    }
    .tiny{ font-size:11px; color:var(--muted); }
    .kv{ display:flex; gap:10px; flex-wrap:wrap; }
    .copyRow{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
    .divider{ height:1px; background:var(--border); margin:10px 0; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div class="title">
      <h1>Mirrasets – Mirrored Assets Control Panel</h1>
      <div class="sub">
        Deterministic Offer-ID updates + <span class="mono">live offer price check</span> to choose op ordering (prevents self-cross on big up/down moves).
        Builds & signs once in-browser, then export signed XDR for LOBSTR Vault.
        <br><span class="warn">Security note:</span> entering secret keys in a browser is risky — do this only on a trusted machine.
      </div>
    </div>
    <div class="row">
      <span class="pill">Horizon: https://horizon.stellar.org</span>
      <span class="pill">Network: Public</span>
      <button class="primary" id="btnRefresh">Refresh balances</button>
      <button id="btnRefreshLive">Refresh live offer prices</button>
    </div>
  </div>

  <div class="grid" id="cards"></div>

  <div class="card">
    <div class="cardHead">
      <div class="assetName">
        <b>Activity</b>
        <small>Logs</small>
      </div>
      <div class="actions">
        <button class="danger" id="btnClearLog">Clear log</button>
      </div>
    </div>
    <div class="log" id="log"></div>
    <div class="tiny">
      This panel loads balances via Horizon account endpoint, and live offer prices via <span class="mono">/offers/{id}</span>. No offer-list pagination.
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/stellar-sdk@12.2.0/dist/stellar-sdk.min.js"></script>

<script>
/**
 * CONFIG — YOUR FINAL DATA
 */
const HORIZON_URL = "https://horizon.stellar.org";
const NETWORK_PASSPHRASE = StellarSdk.Networks.PUBLIC;
const server = new StellarSdk.Horizon.Server(HORIZON_URL);

// Circle USDC (your corrected issuer)
const CIRCLE_USDC_CODE = "USDC";
const CIRCLE_USDC_ISSUER = "GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN";

// Issuer/sales wallets for each mirrored asset (asset code is the key)
const ISSUERS = {
  GBPC: "GDXF6SYWIQOKOZ7BACXHBFBLQZEIH25KOTTLWQK35GO3JKRNIFHHGBPC",
  EURC: "GAP2JFYUBSSY65FIFUN3NTUKP6MQQ52QETQEBDM25PFMQE2EEN2EEURC",
  KRWC: "GA4JBPWVFUT2FETDSMSGBYDGH4FROYB5SYKLVQO7WGNZHCSB63OIKRWC",
  USDC: "GCBYVQH3RZ4JDVFMNWETE3J6U3AW6NNGTIWNVJHNQIIEGQR4K7PLUSDC" // mirrored USDC issuer wallet
};

// Fixed offer IDs (authoritative)
const OFFER_IDS = {
  GBPC: {
    sell_05: "1679115427",
    sell_075: "1679115428",
    sell_10: "1679115429",
    buy: "1679115430"
  },
  EURC: {
    sell_05: "1679202926",
    sell_075: "1679202927",
    sell_10: "1679202928",
    buy: "1679202929"
  },
  KRWC: {
    sell_05: "1679204936",
    sell_075: "1679204937",
    sell_10: "1679204938",
    buy: "1679204939"
  },
  USDC: {
    buy: "1688920720"
  }
};

// Tier sizes & spreads
const RULES = {
  GBPC: { sellAmounts:[40000, 80000, 120000], sellSpreads:[0.005, 0.0075, 0.01], buySpread:0.01 },
  EURC: { sellAmounts:[50000, 100000, 150000], sellSpreads:[0.005, 0.0075, 0.01], buySpread:0.01 },
  KRWC: { sellAmounts:[72000000, 144000000, 216000000], sellSpreads:[0.005, 0.0075, 0.01], buySpread:0.01 },
  // Mirrored USDC: only update BUY at 0.995, leave huge 1:1 sell alone
  USDC: { buyFixedCirclePerMirrored: 0.995 }
};

const state = {
  balances: { GBPC:{circleUSDC:null}, EURC:{circleUSDC:null}, KRWC:{circleUSDC:null}, USDC:{circleUSDC:null} },
  live: {
    // per code: { fetchedAt, oldSellMinCirclePerAsset, oldBuyCirclePerAsset, raw: {sell_05, buy} }
    GBPC: null,
    EURC: null,
    KRWC: null,
    USDC: null
  }
};

/**
 * Logging / formatting
 */
const elLog = document.getElementById("log");
function log(msg){
  const t = new Date().toISOString().replace("T"," ").replace("Z","");
  elLog.textContent += `[${t}] ${msg}\n`;
  elLog.scrollTop = elLog.scrollHeight;
}
function fmt(n, dp=7){ return Number(n).toLocaleString(undefined,{maximumFractionDigits:dp}); }
function fmtStrict(n, dp=7){
  const x = Number(n);
  if (!Number.isFinite(x)) throw new Error("Bad number");
  return x.toFixed(dp).replace(/\.?0+$/,"");
}
function makeAsset(code, issuer){ return new StellarSdk.Asset(code, issuer); }

function findBalance(balances, code, issuer){
  const b = balances.find(x => x.asset_type !== "native" && x.asset_code === code && x.asset_issuer === issuer);
  return b ? Number(b.balance) : 0;
}

/**
 * Fast balance-only fetch
 */
async function loadCircleBalance(pubKey){
  const acct = await server.loadAccount(pubKey);
  const balances = acct.balances.map(b => ({
    asset_type: b.asset_type,
    asset_code: b.asset_code || "XLM",
    asset_issuer: b.asset_issuer || "",
    balance: b.balance
  }));
  return findBalance(balances, CIRCLE_USDC_CODE, CIRCLE_USDC_ISSUER);
}

/**
 * Offer-by-ID fetch (live)
 */
async function fetchOfferById(offerId){
  const url = `${HORIZON_URL}/offers/${offerId}`;
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error(`Offer ${offerId} fetch failed: HTTP ${res.status}`);
  return await res.json();
}
function offerPriceNumber(offerJson){
  if (offerJson.price) return Number(offerJson.price);
  if (offerJson.price_r && offerJson.price_r.d) return Number(offerJson.price_r.n) / Number(offerJson.price_r.d);
  return NaN;
}

/**
 * Live old prices from offer IDs (in Circle USDC per asset terms)
 */
async function fetchLiveOldPrices(code){
  if (code === "USDC"){
    // buy offer: selling Circle USDC, buying mirrored USDC. Horizon price = mirrored per Circle.
    const o = await fetchOfferById(OFFER_IDS.USDC.buy);
    const p = offerPriceNumber(o);
    if (!Number.isFinite(p) || p <= 0) throw new Error(`USDC buy offer has invalid price`);
    return {
      fetchedAt: Date.now(),
      oldBuyCirclePerAsset: 1 / p,
      raw: { buy: o }
    };
  }

  const ids = OFFER_IDS[code];
  const [sell05, buy] = await Promise.all([
    fetchOfferById(ids.sell_05),
    fetchOfferById(ids.buy),
  ]);

  const oldSellMin = offerPriceNumber(sell05); // Circle per asset (selling asset, buying Circle)
  const oldBuyAssetPerCircle = offerPriceNumber(buy); // asset per Circle (selling Circle, buying asset)
  if (!Number.isFinite(oldSellMin) || oldSellMin <= 0) throw new Error(`${code} sell_05 invalid price`);
  if (!Number.isFinite(oldBuyAssetPerCircle) || oldBuyAssetPerCircle <= 0) throw new Error(`${code} buy invalid price`);

  return {
    fetchedAt: Date.now(),
    oldSellMinCirclePerAsset: oldSellMin,
    oldBuyCirclePerAsset: 1 / oldBuyAssetPerCircle,
    raw: { sell_05: sell05, buy: buy }
  };
}

/**
 * Price math
 */
function computeQuotes(code, midCirclePerAsset){
  if (code === "USDC"){
    const buyCirclePerMirrored = RULES.USDC.buyFixedCirclePerMirrored; // 0.995
    const buyMirroredPerCircle = 1 / buyCirclePerMirrored;
    return { buyCirclePerMirrored, buyMirroredPerCircle };
  }

  const mid = Number(midCirclePerAsset);
  if (!Number.isFinite(mid) || mid <= 0) throw new Error("Bad XE mid price");

  const r = RULES[code];
  const sellTiers = r.sellSpreads.map((s,i)=>({
    key: i===0 ? "sell_05" : i===1 ? "sell_075" : "sell_10",
    spread:s,
    amount:r.sellAmounts[i],
    priceCirclePerAsset: mid * (1 + s)
  }));

  const buyCirclePerAsset = mid * (1 - r.buySpread);
  const buyAssetPerCircle = 1 / buyCirclePerAsset;

  return { mid, sellTiers, buyCirclePerAsset, buyAssetPerCircle };
}

/**
 * Sequencing decision using live offer prices
 * - If new BUY would cross old SELL_05 => do SELL-first
 * - If new SELL_05 would cross old BUY => do BUY-first
 */
function decideOrderFromLive(code, newMid, live){
  const newSellMin = newMid * 1.005;
  const newBuy = newMid * 0.99;

  // BUY-first risk on big UP moves
  if (newBuy >= live.oldSellMinCirclePerAsset){
    return { order:"sell-first", reason:`Up-move: newBuy ${newBuy.toFixed(8)} >= oldSellMin ${live.oldSellMinCirclePerAsset.toFixed(8)}` };
  }
  // SELL-first risk on big DOWN moves
  if (newSellMin <= live.oldBuyCirclePerAsset){
    return { order:"buy-first", reason:`Down-move: newSellMin ${newSellMin.toFixed(8)} <= oldBuy ${live.oldBuyCirclePerAsset.toFixed(8)}` };
  }
  return { order:"buy-first", reason:"No cross risk vs live offers (default buy-first)." };
}

/**
 * UI build
 */
function buildCards(){
  const root = document.getElementById("cards");
  root.innerHTML = "";

  for (const code of ["GBPC","EURC","KRWC","USDC"]){
    const issuer = ISSUERS[code];
    const isUSDC = code === "USDC";

    const idsText = isUSDC
      ? `buy=${OFFER_IDS.USDC.buy}`
      : `sell05=${OFFER_IDS[code].sell_05}, sell075=${OFFER_IDS[code].sell_075}, sell10=${OFFER_IDS[code].sell_10}, buy=${OFFER_IDS[code].buy}`;

    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
      <div class="cardHead">
        <div class="assetName">
          <b>${code}</b>
          <small>${issuer}</small>
        </div>
        <div class="kv">
          <span class="pill" id="pill-bal-${code}">Circle USDC reserve: —</span>
          <span class="pill" id="pill-live-${code}">Live offers: —</span>
          <span class="pill">Offer IDs: ${idsText}</span>
        </div>
      </div>

      <div class="twoCol">
        <div class="box">
          <div style="display:flex; gap:12px; flex-wrap:wrap;">
            <div style="flex:1 1 320px;">
              <label>Secret key for this issuing wallet (starts with S…)</label>
              <input id="inp-sk-${code}" placeholder="S.................................................." autocomplete="off" />
              <div class="hint">Used only to sign the built transaction once. Then you export signed XDR for LOBSTR Vault.</div>
            </div>

            <div style="flex:1 1 240px;">
              <label>${isUSDC ? "Mirrored USDC buy is fixed at 0.995 (Circle USDC per 1 Mirrored USDC)" : "Paste XE mid (Circle USDC per 1 " + code + ")"}</label>
              <input id="inp-mid-${code}" ${isUSDC ? "value='1' disabled" : "placeholder='e.g. 1.27456'"} />
              <div class="hint">
                ${isUSDC
                  ? "Only updates BUY offer at 0.995 using full Circle USDC reserve. (Huge 1:1 sell untouched.)"
                  : "SELL tiers: +0.5%, +0.75%, +1.0%. BUY: −1.0% using full Circle USDC reserve. Op order is chosen automatically using live offer prices."
                }
              </div>
            </div>
          </div>

          <div class="actions" style="margin-top:10px;">
            <button id="btn-preview-${code}">Preview</button>
            <button id="btn-live-${code}">Fetch live prices</button>
            <button class="primary" id="btn-build-${code}">Build + sign (export XDR)</button>
          </div>

          <div style="margin-top:12px;">
            <table id="tbl-${code}">
              <thead>
                <tr>
                  <th>Offer</th>
                  <th>Direction</th>
                  <th>Offer ID</th>
                  <th>Amount (selling)</th>
                  <th>Price</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
            <div class="hint" id="hint-${code}"></div>
          </div>

          <div class="divider"></div>

          <div>
            <label>Signed XDR (base64)</label>
            <textarea id="out-xdr-${code}" placeholder="Click Build + sign to generate…" readonly></textarea>
            <div class="copyRow">
              <button id="btn-copy-${code}">Copy XDR</button>
            </div>
            <div class="tiny">Paste into LOBSTR Vault → Transaction XDR. This XDR already has the first signature.</div>
          </div>
        </div>

        <div class="box">
          <label>Snapshot</label>
          <div class="log" id="snap-${code}" style="max-height:330px;"></div>
          <div class="tiny">Refresh balances to update reserve size. Fetch live prices to update sequencing decision.</div>
        </div>
      </div>
    `;

    root.appendChild(card);

    document.getElementById(`btn-preview-${code}`).addEventListener("click", ()=>preview(code));
    document.getElementById(`btn-live-${code}`).addEventListener("click", ()=>refreshLiveFor(code));
    document.getElementById(`btn-build-${code}`).addEventListener("click", ()=>buildAndSign(code));
    document.getElementById(`btn-copy-${code}`).addEventListener("click", ()=>copyXDR(code));
  }
}

/**
 * UI helpers
 */
function setPillsAndSnapshot(code, circleBal){
  state.balances[code].circleUSDC = circleBal;

  const pill = document.getElementById(`pill-bal-${code}`);
  pill.textContent = `Circle USDC reserve: ${fmt(circleBal, 2)}`;

  renderLivePill(code);

  const snap = document.getElementById(`snap-${code}`);
  const live = state.live[code];
  const liveLine = live
    ? `Live prices fetched: ${new Date(live.fetchedAt).toLocaleString()}`
    : `Live prices: not fetched yet (click "Fetch live prices")`;

  snap.textContent =
`Issuer wallet: ${ISSUERS[code]}
Circle USDC issuer: ${CIRCLE_USDC_ISSUER}
Circle USDC reserve balance: ${circleBal}

${liveLine}

Notes:
- Buy offer sells FULL Circle USDC reserve (amount selling)
- Sequencing uses live offer prices from offer IDs
- No offer list scanning / pagination`;
}

function renderLivePill(code){
  const pill = document.getElementById(`pill-live-${code}`);
  const live = state.live[code];
  if (!pill) return;
  if (!live){
    pill.textContent = `Live offers: —`;
    return;
  }
  const ageSec = Math.max(0, Math.floor((Date.now() - live.fetchedAt)/1000));
  if (code === "USDC"){
    pill.textContent = `Live buy≈${fmt(live.oldBuyCirclePerAsset, 6)} (age ${ageSec}s)`;
  } else {
    pill.textContent = `Live sell05≈${fmt(live.oldSellMinCirclePerAsset, 6)} • buy≈${fmt(live.oldBuyCirclePerAsset, 6)} (age ${ageSec}s)`;
  }
}

/**
 * Refresh balances (parallel)
 */
async function refreshAllBalances(){
  log("Refreshing Circle USDC balances (parallel)…");
  const codes = ["GBPC","EURC","KRWC","USDC"];
  await Promise.all(codes.map(async (code)=>{
    try{
      const bal = await loadCircleBalance(ISSUERS[code]);
      setPillsAndSnapshot(code, bal);
      preview(code);
      log(`${code}: reserve ${fmt(bal, 2)}`);
    }catch(e){
      log(`${code}: balance load failed: ${e?.message || e}`);
      document.getElementById(`hint-${code}`).innerHTML = `<span class="bad">Balance load failed: ${e?.message || e}</span>`;
    }
  }));
  log("Balance refresh complete.");
}

/**
 * Refresh live offer prices
 */
async function refreshLiveFor(code){
  try{
    log(`${code}: fetching live offer prices by ID…`);
    const live = await fetchLiveOldPrices(code);
    state.live[code] = live;
    setPillsAndSnapshot(code, state.balances[code].circleUSDC ?? 0);
    preview(code);
    log(`${code}: live prices fetched.`);
  }catch(e){
    log(`${code}: live price fetch failed: ${e?.message || e}`);
    document.getElementById(`hint-${code}`).innerHTML = `<span class="bad">Live price fetch failed: ${e?.message || e}</span>`;
  }
}

async function refreshAllLive(){
  log("Refreshing live offer prices (parallel)…");
  const codes = ["GBPC","EURC","KRWC","USDC"];
  await Promise.all(codes.map(async (code)=>refreshLiveFor(code)));
  log("Live prices refresh complete.");
}

/**
 * Preview table
 */
function preview(code){
  const tbody = document.querySelector(`#tbl-${code} tbody`);
  const hint = document.getElementById(`hint-${code}`);
  tbody.innerHTML = "";
  hint.textContent = "";

  const circleBal = state.balances[code].circleUSDC;
  if (circleBal === null || circleBal === undefined){
    hint.innerHTML = `<span class="warn">No reserve yet. Click “Refresh balances”.</span>`;
    return;
  }

  let q;
  try{
    if (code === "USDC") q = computeQuotes("USDC", 1);
    else {
      const mid = document.getElementById(`inp-mid-${code}`).value.trim();
      if (!mid) throw new Error("Paste XE mid first.");
      q = computeQuotes(code, mid);
    }
  }catch(e){
    hint.innerHTML = `<span class="bad">${e.message || e}</span>`;
    return;
  }

  const rows = [];
  if (code !== "USDC"){
    rows.push({ label:`SELL +0.5%`, dir:`${code} → Circle USDC`, id:OFFER_IDS[code].sell_05, amount: RULES[code].sellAmounts[0], price:`${fmt(q.sellTiers[0].priceCirclePerAsset, 10)} Circle/${code}` });
    rows.push({ label:`SELL +0.75%`, dir:`${code} → Circle USDC`, id:OFFER_IDS[code].sell_075, amount: RULES[code].sellAmounts[1], price:`${fmt(q.sellTiers[1].priceCirclePerAsset, 10)} Circle/${code}` });
    rows.push({ label:`SELL +1.0%`, dir:`${code} → Circle USDC`, id:OFFER_IDS[code].sell_10, amount: RULES[code].sellAmounts[2], price:`${fmt(q.sellTiers[2].priceCirclePerAsset, 10)} Circle/${code}` });
    rows.push({ label:`BUY −1.0% (full reserve)`, dir:`Circle USDC → ${code}`, id:OFFER_IDS[code].buy, amount: fmt(circleBal, 2), price:`${fmt(q.buyCirclePerAsset, 10)} Circle/${code}  (offer price = ${fmt(q.buyAssetPerCircle, 14)} ${code}/Circle)` });

    // sequencing note (only if live present)
    const live = state.live[code];
    if (live){
      const seq = decideOrderFromLive(code, q.mid, live);
      hint.innerHTML =
        `<span class="status">Mid: <span class="mono">${fmt(q.mid, 10)}</span> • Recommended op order: <span class="mono">${seq.order}</span> — ${seq.reason}</span>`;
    } else {
      hint.innerHTML =
        `<span class="status">Mid: <span class="mono">${fmt(q.mid, 10)}</span> • Fetch live prices to get safe sequencing recommendation.</span>`;
    }
  } else {
    rows.push({
      label:`BUY @ 0.995 (full reserve)`,
      dir:`Circle USDC → Mirrored USDC`,
      id:OFFER_IDS.USDC.buy,
      amount: fmt(circleBal, 2),
      price:`${fmt(q.buyCirclePerMirrored, 6)} Circle/MirroredUSDC  (offer price = ${fmt(q.buyMirroredPerCircle, 14)} Mirrored/Circle)`
    });
    hint.innerHTML = `<span class="status">Mirrored USDC: only BUY updated at 0.995. (Huge 1:1 sell untouched.)</span>`;
  }

  for (const r of rows){
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${r.label}</td>
      <td>${r.dir}</td>
      <td class="mono">${r.id}</td>
      <td>${r.amount}</td>
      <td>${r.price}</td>
    `;
    tbody.appendChild(tr);
  }
}

/**
 * Build + sign
 * - GBPC/EURC/KRWC: choose op order using live offer prices (fetch if missing)
 * - USDC: one op only
 */
async function buildAndSign(code){
  const out = document.getElementById(`out-xdr-${code}`);
  out.value = "";

  const pub = ISSUERS[code];
  const circleBal = state.balances[code].circleUSDC;

  if (circleBal === null || circleBal === undefined){
    alert("No reserve yet. Click Refresh balances first.");
    return;
  }

  // secret key
  const skEl = document.getElementById(`inp-sk-${code}`);
  const sk = skEl.value.trim();
  if (!sk || !sk.startsWith("S")){
    alert("Paste the secret key for this issuing wallet (starts with S…).");
    return;
  }

  let kp;
  try{
    kp = StellarSdk.Keypair.fromSecret(sk);
  }catch(e){
    alert("Invalid secret key format.");
    return;
  }
  if (kp.publicKey() !== pub){
    alert(`Secret key does not match issuer address for ${code}.\nExpected: ${pub}\nGot: ${kp.publicKey()}`);
    return;
  }

  // quotes
  let q;
  try{
    if (code === "USDC") q = computeQuotes("USDC", 1);
    else {
      const mid = document.getElementById(`inp-mid-${code}`).value.trim();
      if (!mid) throw new Error("Paste XE mid first.");
      q = computeQuotes(code, mid);
    }
  }catch(e){
    alert(e.message || e);
    return;
  }

  // ensure live is available (for sequencing) for non-USDC
  if (code !== "USDC" && !state.live[code]){
    try{
      log(`${code}: live prices missing — fetching now for safe sequencing…`);
      state.live[code] = await fetchLiveOldPrices(code);
      renderLivePill(code);
    }catch(e){
      log(`${code}: live fetch failed; cannot safely sequence: ${e?.message || e}`);
      alert(`Failed to fetch live prices for ${code}. Click "Fetch live prices" and try again.\n\n${e?.message || e}`);
      return;
    }
  }

  log(`${code}: building tx (offerId edits + live sequencing)…`);

  // load fresh account for sequence + base fee
  let acct, baseFee;
  try{
    acct = await server.loadAccount(pub);
    baseFee = await server.fetchBaseFee();
  }catch(e){
    log(`${code}: failed loading account/base fee: ${e?.message || e}`);
    alert(`Failed to load account/base fee: ${e?.message || e}`);
    return;
  }

  const circle = makeAsset(CIRCLE_USDC_CODE, CIRCLE_USDC_ISSUER);
  const mirrored = makeAsset(code, pub);

  const txb = new StellarSdk.TransactionBuilder(acct, {
    fee: (Number(baseFee) * 2).toString(),
    networkPassphrase: NETWORK_PASSPHRASE
  });

  if (code === "USDC"){
    // only BUY at 0.995; do not touch big sell
    txb.addOperation(StellarSdk.Operation.manageSellOffer({
      offerId: OFFER_IDS.USDC.buy,
      selling: circle,
      buying: mirrored,
      amount: fmtStrict(Math.max(circleBal, 0), 7),
      price: fmtStrict(q.buyMirroredPerCircle, 12) // mirrored per circle
    }));
  } else {
    // helpers
    const addBuy = () => txb.addOperation(StellarSdk.Operation.manageSellOffer({
      offerId: OFFER_IDS[code].buy,
      selling: circle,
      buying: mirrored,
      amount: fmtStrict(Math.max(circleBal, 0), 7),
      price: fmtStrict(q.buyAssetPerCircle, 12) // asset per circle
    }));

    const addSells = () => {
      txb.addOperation(StellarSdk.Operation.manageSellOffer({
        offerId: OFFER_IDS[code].sell_05,
        selling: mirrored,
        buying: circle,
        amount: fmtStrict(RULES[code].sellAmounts[0], 7),
        price: fmtStrict(q.sellTiers[0].priceCirclePerAsset, 12)
      }));
      txb.addOperation(StellarSdk.Operation.manageSellOffer({
        offerId: OFFER_IDS[code].sell_075,
        selling: mirrored,
        buying: circle,
        amount: fmtStrict(RULES[code].sellAmounts[1], 7),
        price: fmtStrict(q.sellTiers[1].priceCirclePerAsset, 12)
      }));
      txb.addOperation(StellarSdk.Operation.manageSellOffer({
        offerId: OFFER_IDS[code].sell_10,
        selling: mirrored,
        buying: circle,
        amount: fmtStrict(RULES[code].sellAmounts[2], 7),
        price: fmtStrict(q.sellTiers[2].priceCirclePerAsset, 12)
      }));
    };

    const live = state.live[code];
    const seq = decideOrderFromLive(code, q.mid, live);
    log(`${code}: op order = ${seq.order} (${seq.reason})`);

    if (seq.order === "sell-first"){
      addSells();
      addBuy();
    } else {
      addBuy();
      addSells();
    }
  }

  const tx = txb.setTimeout(120).build();

  // sign once
  tx.sign(kp);

  const signedXDR = tx.toXDR();
  out.value = signedXDR;

  // wipe input to reduce exposure
  skEl.value = "";

  log(`${code}: ✅ signed XDR generated (${signedXDR.length} chars).`);
}

/**
 * Copy XDR
 */
async function copyXDR(code){
  const out = document.getElementById(`out-xdr-${code}`);
  const v = out.value.trim();
  if (!v){ alert("No XDR yet. Click Build + sign."); return; }
  await navigator.clipboard.writeText(v);
  log(`${code}: XDR copied to clipboard.`);
}

/**
 * Init
 */
buildCards();

document.getElementById("btnRefresh").addEventListener("click", refreshAllBalances);
document.getElementById("btnRefreshLive").addEventListener("click", refreshAllLive);
document.getElementById("btnClearLog").addEventListener("click", ()=>{ elLog.textContent=""; });

log("Ready. Click “Refresh balances”. Then (recommended) click “Refresh live offer prices”.");
</script>
</body>
</html>
