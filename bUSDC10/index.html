<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>bUSDC Vault UI</title>
  <style>
    :root{
      --bg:#0b0f17; --card:#111a2b; --muted:#8ea0c2; --text:#e8eefc;
      --accent:#5eead4; --warn:#fbbf24; --bad:#fb7185; --ok:#34d399;
      --border:rgba(255,255,255,.10);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); color:var(--text);
      background:
        radial-gradient(1000px 700px at 20% 0%, rgba(94,234,212,.12), transparent 55%),
        radial-gradient(900px 600px at 95% 15%, rgba(251,113,133,.10), transparent 55%),
        var(--bg);
      min-height:100vh;
    }
    .wrap{max-width:1100px; margin:22px auto; padding:0 16px 60px;}
    .top{display:flex; justify-content:space-between; align-items:flex-start; gap:12px; flex-wrap:wrap; margin-bottom:14px;}
    h1{margin:0; font-size:20px; letter-spacing:-.01em}
    .row{display:grid; grid-template-columns: 1fr 1fr; gap:14px;}
    @media (max-width: 940px){ .row{grid-template-columns:1fr;} }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid var(--border);
      border-radius:16px;
      padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.22);
      overflow:hidden;
    }
    .card h2{margin:0 0 10px; font-size:15px}
    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    @media (max-width: 560px){ .grid2{grid-template-columns:1fr;} }
    .kv{
      padding:10px 10px;
      border:1px solid var(--border);
      border-radius:12px;
      background:rgba(0,0,0,.18);
      min-height:56px;
    }
    .k{color:var(--muted); font-size:11px; letter-spacing:.2px; text-transform:uppercase}
    .v{margin-top:4px; font-size:14px; word-break:break-word}
    .v.big{font-size:18px; font-weight:800}
    .mono{font-family:var(--mono)}
    .actions{display:flex; flex-wrap:wrap; gap:10px; margin-top:10px}
    button{
      border:1px solid var(--border);
      background:rgba(0,0,0,.20);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
    }
    button:hover{border-color: rgba(94,234,212,.35)}
    button:disabled{opacity:.5; cursor:not-allowed}
    button.primary{
      background:linear-gradient(180deg, rgba(94,234,212,.22), rgba(94,234,212,.10));
      border-color: rgba(94,234,212,.28);
    }
    button.warn{
      background:linear-gradient(180deg, rgba(251,191,36,.18), rgba(251,191,36,.08));
      border-color: rgba(251,191,36,.30);
    }
    button.ghost{background:transparent}
    .input{display:flex; flex-direction:column; gap:6px; margin-top:10px;}
    input, textarea{
      width:100%;
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 11px;
      background:rgba(0,0,0,.18);
      color:var(--text);
      outline:none;
      font:14px/1.4 var(--mono);
    }
    textarea{min-height:120px; resize:vertical; display:none;}
    .small{color:var(--muted); font-size:12px}
    .hr{height:1px; background:var(--border); margin:12px 0}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:7px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      background:rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;
      align-self:flex-start;
    }
    .pill .dot{width:8px;height:8px;border-radius:50%; background:var(--muted)}
    .pill.ok .dot{background:var(--ok)}
    .pill.warn .dot{background:var(--warn)}
    .pill.bad .dot{background:var(--bad)}
    .status-line{margin-top:8px; color:var(--muted); font-size:12px; word-break:break-word}

    .toast-wrap{
      position:fixed; top:12px; right:12px; z-index:50;
      display:flex; flex-direction:column; gap:10px;
      pointer-events:none;
    }
    .toast{
      pointer-events:auto;
      width:min(380px, calc(100vw - 24px));
      border-radius:14px;
      padding:10px 10px;
      border:1px solid var(--border);
      background:rgba(10,14,22,.86);
      backdrop-filter: blur(8px);
      display:flex; gap:10px; align-items:flex-start;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      animation: tin .16s ease-out forwards;
    }
    .toast .ico{
      width:26px; height:26px; border-radius:10px;
      display:flex; align-items:center; justify-content:center;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      font-weight:900;
    }
    .toast.ok .ico{color:var(--ok)}
    .toast.err .ico{color:var(--bad)}
    .toast.info .ico{color:var(--accent)}
    .toast .body{flex:1}
    .toast .title{font-weight:900; font-size:12px; letter-spacing:.2px}
    .toast .msg{font-size:12px; color:var(--muted); margin-top:2px; white-space:pre-wrap}
    .toast .x{border:none; background:transparent; color:var(--muted); cursor:pointer; font-size:18px; padding:0 6px;}
    @keyframes tin{from{transform:translateY(-6px); opacity:0} to{transform:none; opacity:1}}
    @keyframes tout{from{transform:none; opacity:1} to{transform:translateY(-6px); opacity:0}}

    .backdrop{position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; z-index:40;}
    .backdrop.open{display:block}
    .modal{position:fixed; inset:0; display:none; z-index:41; place-items:center; padding:18px;}
    .modal.open{display:grid}
    .modal-inner{
      width:min(720px, 100%);
      background:rgba(16,22,35,.92);
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow: 0 16px 50px rgba(0,0,0,.5);
      padding:14px;
      backdrop-filter: blur(8px);
    }
    .modal-inner.slim{
      width:min(520px, 100%);
      padding:16px 16px 18px;
    }
    .modal-inner.tiny{
      width:min(520px, 100%);
      padding:16px 16px 18px;
    }
    .modal-inner.vault{
      max-height: calc(100dvh - 32px);
      display:flex;
      flex-direction:column;
      padding:14px;
    }
    .vault-body{
      overflow-y:auto;
      -webkit-overflow-scrolling:touch;
      padding-right:4px;
      margin-top:6px;
    }
    .vault-footer{
      margin-top:10px;
      border-top:1px solid rgba(255,255,255,.08);
      padding-top:10px;
      padding-bottom: env(safe-area-inset-bottom);
    }

    .modal-header{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:6px}
    .modal-header h3{margin:0; font-size:16px}
    .modal-header .x{border:none; background:transparent; color:var(--muted); font-size:20px; cursor:pointer}
    .qr-wrap{margin-top:12px; display:none; gap:12px; align-items:center; flex-direction:column}
    .wallet-choices{display:flex; gap:10px; flex-wrap:wrap; justify-content:center}
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    .two-col{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    @media (max-width:560px){ .two-col{grid-template-columns:1fr} }

    .vault-ta{display:block; min-height:120px;}
    @media (max-width: 600px){
      .vault-ta{ min-height: 84px; max-height: 140px; }
    }

    .muted{color:var(--muted);}

    .fee-box{
      margin-top:8px;
      padding:10px;
      border:1px dashed rgba(255,255,255,.16);
      border-radius:12px;
      background:rgba(0,0,0,.14);
    }
    .fee-row{display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; font-size:12px; color:var(--muted)}
    .fee-row b{color:var(--text)}

    .clickable{
      cursor:pointer;
      display:inline-block;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.14);
      user-select:none;
    }
    .clickable:hover{border-color: rgba(94,234,212,.35)}
    .hintline{display:flex; justify-content:space-between; gap:10px; align-items:center; flex-wrap:wrap; margin-top:6px}

    .warnbox{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid rgba(251,191,36,.28);
      background:rgba(251,191,36,.08);
      color:var(--text);
    }
    .warnbox .small{color:rgba(232,238,252,.78)}
    .ackrow{
      display:flex; gap:10px; align-items:flex-start; margin-top:8px;
      padding:8px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12);
    }
    .ackrow input{width:auto; margin-top:2px}
    .stepPill{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.14);
      color:var(--muted);
      font-size:12px;
    }
    .stepPill.ok{color:var(--ok); border-color: rgba(52,211,153,.25)}
    .stepPill.warn{color:var(--warn); border-color: rgba(251,191,36,.25)}
    .stepPill.bad{color:var(--bad); border-color: rgba(251,113,133,.25)}

    .modal-actions-center{
      display:flex;
      justify-content:center;
      gap:12px;
      flex-wrap:wrap;
      margin-top:12px;
    }
    .modal-actions-center button{ min-width: 220px; }

    .vault-logo{
      display:flex;
      justify-content:center;
      margin:10px 0 6px;
    }
    .vault-logo .inner{
      width:140px;
      max-width:60%;
      opacity:.98;
      filter: drop-shadow(0 10px 22px rgba(0,0,0,.35));
    }
  </style>
</head>
<body>
  <div class="toast-wrap" id="toastWrap" aria-live="polite"></div>

  <div class="wrap">
    <div class="top">
      <div><h1>bUSDC Vault UI</h1></div>
      <div class="pill ok" id="netPill"><span class="dot"></span><span>Pubnet</span></div>
    </div>

    <div class="row">
      <div class="card">
        <h2>Wallet</h2>

        <div class="kv">
          <div class="k">Connection</div>
          <div class="v" style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
            <div>
              <div id="connStatus" class="pill bad" style="display:inline-flex"><span class="dot"></span><span>Not connected</span></div>
              <div class="small" id="connModeLine" style="margin-top:6px">â€”</div>
            </div>
            <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end">
              <button id="connectBtn" class="primary">Connect</button>
              <button id="disconnectBtn" disabled>Disconnect</button>
            </div>
          </div>
        </div>

        <div class="input">
          <div class="small">Public key (G...)</div>
          <input id="pubkeyEl" class="mono" placeholder="G..." />
          <div class="actions">
            <button id="usePubkeyBtn">Use pubkey (read-only)</button>
            <button id="openExplorerBtn">Open in StellarExpert</button>
          </div>
        </div>

        <div class="input">
          <div class="small">Secret key (S...) (optional)</div>
          <input id="seckeyEl" class="mono" placeholder="S... (not stored)" />
          <div class="small">Secret-key mode signs locally in this tab (nothing saved).</div>
          <div class="actions">
            <button id="useSecretBtn">Use secret (local signing)</button>
          </div>
        </div>

        <div class="hr"></div>

        <h2>Balances</h2>
        <div class="grid2">
          <div class="kv">
            <div class="k">Available USDC</div>
            <div class="v big"><span id="usdcAvailOut">â€”</span></div>
          </div>
          <div class="kv">
            <div class="k">Available bUSDC</div>
            <div class="v big"><span id="busdcAvailOut">â€”</span></div>
          </div>
        </div>
        <div class="actions">
          <button id="refreshBalBtn" class="primary">Refresh balances</button>
          <button id="addTrustBtn">Add bUSDC trustline</button>
        </div>
        <div class="status-line" id="balStatus"></div>
      </div>

      <div class="card">
        <h2>Vault Info</h2>

        <div class="grid2">
          <div class="kv">
            <div class="k">Share price</div>
            <div class="v big" id="sharePriceOut">â€”</div>
          </div>

          <div class="kv">
            <div class="k">USDC in Blend</div>
            <div class="v" id="totalAssetsOut">â€”</div>
          </div>
          <div class="kv">
            <div class="k">Total bUSDC supply</div>
            <div class="v" id="totalSupplyOut">â€”</div>
          </div>
        </div>

        <div class="small muted" id="impliedLine" style="margin-top:8px">â€”</div>

        <div class="actions">
          <button class="primary" id="refreshBtn">Refresh</button>
          <button class="ghost" id="toggleLogsBtn">Show logs</button>
        </div>

        <textarea id="logs" spellcheck="false"></textarea>
        <div class="status-line" id="stateStatus"></div>

        <div class="hr"></div>

        <h2>Actions</h2>

        <div class="warnbox">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
            <b>Non-refundable fee</b>
            <span class="stepPill warn">Fee is paid before execution</span>
          </div>
          <div class="small" style="margin-top:6px">
            You must run <b>Preflight</b> first. If you choose to pay the fee, it is <b>not refundable</b> even if your deposit/withdraw fails later due to account state changes, network conditions, or signature requirements.
          </div>
          <label class="ackrow">
            <input type="checkbox" id="feeAck" />
            <div class="small">
              I understand the <b>0.15%</b> fee is <b>non-refundable</b>. I confirm I have checked my balances, trustlines, and will only proceed after a successful Preflight.
            </div>
          </label>
        </div>

        <div class="two-col" style="margin-top:10px">
          <div>
            <div class="input">
              <div class="small">Deposit USDC</div>
              <input id="depositAmt" inputmode="decimal" placeholder="e.g. 1000.00" />
              <div class="hintline small">
                <span>Available: <span id="usdcAvailInline" class="clickable">â€”</span></span>
              </div>
              <div class="fee-box">
                <div class="fee-row"><span>Fee (0.15%)</span><b id="depFeeOut">â€”</b></div>
                <div class="fee-row" style="margin-top:6px"><span>Net deposited</span><b id="depNetOut">â€”</b></div>
              </div>
            </div>

            <div class="actions">
              <button id="depPreflightBtn" class="primary">1) Preflight</button>
              <button id="depPayFeeBtn" class="warn" disabled>2) Pay fee</button>
              <button id="depExecuteBtn" class="primary" disabled>3) Execute deposit</button>
            </div>

            <div class="actions">
              <button id="depositXdrToggle">Reveal XDR</button>
            </div>
            <textarea id="depositXdr" spellcheck="false"></textarea>

            <div class="status-line" id="depositStatus"></div>
          </div>

          <div>
            <div class="input">
              <div class="small">Withdraw bUSDC</div>
              <input id="redeemAmt" inputmode="decimal" placeholder="e.g. 1000.00" />
              <div class="hintline small">
                <span>Available: <span id="busdcAvailInline" class="clickable">â€”</span></span>
              </div>
              <div class="fee-box">
                <div class="fee-row"><span>Fee (0.15%)</span><b id="wdFeeOut">â€”</b></div>
                <div class="fee-row" style="margin-top:6px"><span>Net withdrawn</span><b id="wdNetOut">â€”</b></div>
              </div>
            </div>

            <div class="actions">
              <button id="wdPreflightBtn" class="primary">1) Preflight</button>
              <button id="wdPayFeeBtn" class="warn" disabled>2) Pay fee</button>
              <button id="wdExecuteBtn" class="primary" disabled>3) Execute withdraw</button>
            </div>

            <div class="actions">
              <button id="redeemXdrToggle">Reveal XDR</button>
            </div>
            <textarea id="redeemXdr" spellcheck="false"></textarea>

            <div class="status-line" id="redeemStatus"></div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="small muted">
          Fee: <b style="color:var(--text)">0.15%</b>. The fee contributes towards the development of this bUSDC UI.<br/>
          Minimums: <span class="mono">Deposit â‰¥ 10.015 USDC</span> Â· <span class="mono">Withdraw â‰¥ 10.015 bUSDC</span><br/>
          Fee is taken within the amount you enter (e.g. enter 1000 â†’ fee 1.5 â†’ net 998.5).
        </div>
      </div>
    </div>
  </div>

  <div id="backdrop" class="backdrop"></div>

  <!-- Connect modal -->
  <div id="loginModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="loginTitle">
    <div class="modal-inner slim">
      <div class="modal-header">
        <h3 id="loginTitle">Connect Wallet</h3>
        <button class="x" id="closeModal" aria-label="Close">Ã—</button>
      </div>
      <div class="small">Pick a login method:</div>

      <div class="modal-actions-center">
        <button id="wcBtn">ðŸ”— WalletConnect (mobile)</button>
        <button id="freighterExtBtn">ðŸ§© Freighter (extension)</button>
      </div>

      <div id="qrArea" class="qr-wrap">
        <canvas id="qrCanvas" width="256" height="256" style="background:#fff;border-radius:12px"></canvas>
        <div class="wallet-choices">
          <button id="btnLobstr">Open in LOBSTR</button>
          <button id="btnFreighter">Open in Freighter</button>
        </div>
        <div class="small">
          Scan with your wallet app, or tap above on mobile Â·
          <a id="rawWcLink" href="#" target="_blank" rel="noreferrer">raw wc link</a>
        </div>
        <div id="linkStatus" class="small muted"></div>
      </div>
    </div>
  </div>

  <!-- WC signing prompt modal -->
  <div id="wcSignModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="wcSignTitle">
    <div class="modal-inner tiny">
      <div class="modal-header">
        <h3 id="wcSignTitle">Action required in LOBSTR</h3>
        <button class="x" id="closeWcSignModal" aria-label="Close">Ã—</button>
      </div>
      <div class="warnbox" style="margin-top:8px">
        <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
          <b id="wcSignHeadline">Sign in your wallet</b>
          <span class="stepPill warn">WalletConnect</span>
        </div>
        <div class="small" id="wcSignBody" style="margin-top:6px">
          Please open LOBSTR to approve the signature request.
        </div>
        <div class="actions" style="justify-content:center">
          <button id="wcSignOpenLobstrBtn" class="primary">Open LOBSTR</button>
        </div>
        <div class="small muted" id="wcSignHint" style="margin-top:6px; text-align:center"></div>
      </div>
      <div class="status-line" id="wcSignStatus" style="margin-top:10px"></div>
    </div>
  </div>

  <!-- Step modal -->
  <div id="stepModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="stepTitle">
    <div class="modal-inner tiny">
      <div class="modal-header">
        <h3 id="stepTitle">â€”</h3>
        <button class="x" id="closeStepModal" aria-label="Close">Ã—</button>
      </div>
      <div class="small muted" id="stepBody" style="margin-top:6px">â€”</div>
      <div class="actions" style="justify-content:center; margin-top:14px">
        <button id="stepPrimaryBtn" class="primary">Continue</button>
      </div>
      <div class="actions" id="stepSecondaryRow" style="justify-content:center; margin-top:10px; display:none">
        <button id="stepSecondaryBtn">â€”</button>
      </div>
    </div>
  </div>

  <!-- Vault modal -->
  <div id="vaultModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="vaultTitle">
    <div class="modal-inner vault">
      <div class="modal-header">
        <h3 id="vaultTitle">LOBSTR Vault co-sign</h3>
        <button class="x" id="closeVaultModal" aria-label="Close">Ã—</button>
      </div>

      <div class="vault-body">
        <div class="vault-logo">
          <div class="inner" aria-hidden="true">
            <!-- LOBSTR Vault SVG -->
            <svg width="244" height="244" viewBox="0 0 244 244" fill="none" xmlns="http://www.w3.org/2000/svg">
              <rect x="3" y="3" width="238" height="238" rx="58" fill="url(#paint0_linear_2740_9594)" stroke="#411286" stroke-width="6"/>
              <path d="M151.209 108.487C153.908 71.0573 144.152 52.3425 121.941 52.3425C99.7304 52.3425 89.9744 71.0573 92.6733 108.487H76.6456C72.4688 60.1623 87.5673 36 121.941 36C156.315 36 171.414 60.1623 167.237 108.487H151.209Z" fill="url(#paint1_linear_2740_9594)"/>
              <path d="M121.941 89.7803L181.402 103.237C182.043 128.08 182.043 144.999 181.402 153.994C180.299 169.475 174.492 175.712 168.158 182.304C159.862 190.938 144.457 199.652 121.941 208.448C99.4264 199.652 84.0208 190.938 75.7248 182.304C69.3905 175.712 63.584 169.475 62.4808 153.994C61.8397 144.999 61.8397 128.08 62.4808 103.237L121.941 89.7803Z" fill="url(#paint2_linear_2740_9594)" fill-opacity="0.31"/>
              <path d="M151.039 84.5192C150.667 62.6952 140.947 51.7832 121.88 51.7832C102.813 51.7832 93.1342 62.6952 92.8438 84.5192C96.1 65.1275 105.779 55.4317 121.88 55.4317C137.981 55.4317 147.701 65.1275 151.039 84.5192Z" fill="url(#paint3_linear_2740_9594)"/>
              <path d="M121.941 89.7803L181.402 102.575C182.043 126.193 182.043 142.279 181.402 150.831C180.299 165.55 174.492 171.479 168.158 177.746C159.862 185.954 144.457 194.24 121.941 202.603C99.4264 194.24 84.0208 185.954 75.7248 177.746C69.3905 171.479 63.584 165.55 62.4808 150.831C61.8397 142.279 61.8397 126.193 62.4808 102.575L121.941 89.7803Z" fill="url(#paint4_linear_2740_9594)"/>
              <path d="M121.941 89.7803L181.402 102.575C182.043 126.193 182.043 142.279 181.402 150.831C180.299 165.55 174.492 171.479 168.158 177.746C159.862 185.954 144.457 194.24 121.941 202.603V89.7803Z" fill="url(#paint5_linear_2740_9594)"/>
              <path d="M121.942 89.7803V99.12L62.2803 111.285L62.4808 102.575L121.942 89.7803Z" fill="url(#paint6_linear_2740_9594)"/>
              <path d="M121.941 89.7803V99.12L181.611 111.217L181.416 102.566L121.941 89.7803Z" fill="url(#paint7_linear_2740_9594)"/>
              <defs>
                <linearGradient id="paint0_linear_2740_9594" x1="216.5" y1="24.5" x2="27" y2="220" gradientUnits="userSpaceOnUse">
                  <stop stop-color="#5218A6"/>
                  <stop offset="1" stop-color="#9769FF"/>
                </linearGradient>
                <linearGradient id="paint1_linear_2740_9594" x1="71.5176" y1="51.0569" x2="89.4992" y2="104.069" gradientUnits="userSpaceOnUse">
                  <stop stop-color="#FBF8FF"/>
                  <stop offset="1" stop-color="#D0B1FF"/>
                </linearGradient>
                <linearGradient id="paint2_linear_2740_9594" x1="198.502" y1="150.41" x2="109.64" y2="57.0717" gradientUnits="userSpaceOnUse">
                  <stop/>
                  <stop offset="1" stop-color="#090114" stop-opacity="0.01"/>
                </linearGradient>
                <linearGradient id="paint3_linear_2740_9594" x1="116.076" y1="48.5008" x2="116.076" y2="55.1001" gradientUnits="userSpaceOnUse">
                  <stop stop-color="#EEEEEE"/>
                  <stop offset="1" stop-color="#DAC1FF"/>
                </linearGradient>
                <linearGradient id="paint4_linear_2740_9594" x1="62" y1="165.456" x2="121.941" y2="165.456" gradientUnits="userSpaceOnUse">
                  <stop stop-color="white"/>
                  <stop offset="1" stop-color="#DBC3FF"/>
                </linearGradient>
                <linearGradient id="paint5_linear_2740_9594" x1="139.305" y1="259.014" x2="212.436" y2="236.504" gradientUnits="userSpaceOnUse">
                  <stop stop-color="#B27EFF"/>
                  <stop offset="1" stop-color="#B482FF"/>
                </linearGradient>
                <linearGradient id="paint6_linear_2740_9594" x1="62.2803" y1="104.205" x2="92.1109" y2="104.205" gradientUnits="userSpaceOnUse">
                  <stop stop-color="white"/>
                  <stop offset="1" stop-color="#E8D8FF"/>
                </linearGradient>
                <linearGradient id="paint7_linear_2740_9594" x1="165.912" y1="117.499" x2="141.688" y2="82.0186" gradientUnits="userSpaceOnUse">
                  <stop stop-color="#C7A1FF"/>
                  <stop offset="1" stop-color="#BE92FF"/>
                </linearGradient>
              </defs>
            </svg>
          </div>
        </div>

        <div class="warnbox" style="margin-top:8px">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
            <b>Donâ€™t close this modal yet</b>
            <span class="stepPill warn" id="vaultAutoPill">Waitingâ€¦</span>
          </div>
          <div class="small" style="margin-top:6px">
            After you submit in Vault, this screen will auto-check for <b>2 minutes</b>.
            If it times out, use <b>Check status</b>.
          </div>
        </div>

        <div class="small" style="margin-top:10px">
          Steps:
          <ol class="muted" style="margin:8px 0 0 18px">
            <li>Go to <b>LOBSTR Vault</b> to sign and submit the transaction.</li>
            <li>Come back here â€” <b>confirmation will be checked automatically</b>.</li>
          </ol>
        </div>

        <div class="small muted" id="vaultSentLine" style="margin-top:10px">â€”</div>

        <div class="input" style="margin-top:10px">
          <div class="small">XDR (optional)</div>
          <textarea id="vaultXdrToVault" class="vault-ta" spellcheck="false" style="display:none"></textarea>
          <div class="actions">
            <button id="toggleVaultXdrBtn" class="ghost">Show XDR</button>
            <button id="copyVaultXdrBtn" style="display:none">Copy XDR</button>
          </div>
        </div>

        <div class="small muted" id="vaultAutoLine" style="margin-top:6px">â€”</div>
        <div class="status-line" id="vaultStatus" style="margin-top:8px"></div>
      </div>

      <div class="vault-footer">
        <div class="actions" style="justify-content:space-between; width:100%; gap:10px">
          <button id="vaultCheckBtn" class="primary">Check status</button>
          <button id="vaultOpenSiteBtn">Open Vault</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // -----------------------
    // CONFIG
    // -----------------------
    const CONTRACT_ID = "CCR63UWZKPVR2OAZJEBHT4OKBLHX2OAMUYZ63JLO2V72FY3SKAXQTGF6";

    const NETWORK_PASSPHRASE = "Public Global Stellar Network ; September 2015";
    const HORIZON = "https://horizon.stellar.org";
    const SOROBAN_RPC = "https://rpc.lightsail.network/";

    const PROJECT_ID = "f658ce3a7c8a185214974f71539fea39";
    const EXPLORER   = "https://explorer-api.walletconnect.com/v3/wallets";

    const VAULT_SIGNER_KEY = "GA2T6GR7VXXXBETTERSAFETHANSORRYXXXPROTECTEDBYLOBSTRVAULT";

    // âœ… Set this to the endpoint you already tested (HTTP 201 OK)
    // It must accept JSON { xdr: "<base64-xdr>", network_passphrase: "<passphrase>" }
    // and return JSON with { xdr, network_passphrase, hash }.
    const LOBSTR_VAULT_CREATE_URL = "https://vault.lobstr.co/api/transactions/";

    // Fee: 0.15%
    const FEE_BPS_NUM = 15n;
    const FEE_BPS_DEN = 10000n;

    const COLLECTION_WALLET = "GCZWVRELD5V426NZ23LXG7BBZRDB4QRS2JRMPS5S7Z6LOFPWPPFYVMMB";

    const USDC_CODE   = "USDC";
    const USDC_ISSUER = "GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN";

    const BUSDC_CODE   = "bUSDC";
    const BUSDC_ISSUER = "GA57KXF2UAGURRYK4LKTO4BO2JASL2PQCO2C53XUNK5G4CXX6QAL6QNR";

    const DECIMALS = 7;
    const MIN_NET = 10;
    const MIN_GROSS_DISPLAY = "10.015";

    // Force tx fee to 20,000 (classic + soroban)
    const TX_FEE = "20000";

    // Vault auto-check: every 2.5s for 2 mins = 48 tries
    const VAULT_AUTO_DELAY_MS = 2500;
    const VAULT_AUTO_TRIES = 48;

    // -----------------------
    // Imports
    // -----------------------
    import * as StellarSdkNS from "https://esm.sh/stellar-sdk@12.2.0?target=es2022";
    const StellarSdk = StellarSdkNS.default ?? StellarSdkNS;

    import SignClient from "https://esm.sh/@walletconnect/sign-client@2.21.8?target=es2022";

    // QRCode helper (lazy)
    let _qrLib = null;
    async function ensureQrLib(){
      if (_qrLib) return _qrLib;
      if (window.QRCode && typeof window.QRCode.toCanvas === "function") { _qrLib = window.QRCode; return _qrLib; }
      const mod = await import("https://esm.sh/qrcode@1.5.3?target=es2022");
      _qrLib = mod.default ?? mod;
      if (typeof _qrLib.toCanvas !== "function") throw new Error("QRCode toCanvas missing");
      return _qrLib;
    }

    // -----------------------
    // DOM helpers
    // -----------------------
    const $ = (id)=>document.getElementById(id);
    const toastWrap = $("toastWrap");
    const logsEl = $("logs");

    function toast({ type="info", title="", message="", timeout=2600 } = {}){
      const el = document.createElement("div");
      el.className = `toast ${type}`;
      const icon = type==="ok" ? "âœ“" : type==="err" ? "!" : "â„¹ï¸Ž";
      el.innerHTML = `
        <div class="ico">${icon}</div>
        <div class="body">${title?`<div class="title">${title}</div>`:""}<div class="msg">${message||""}</div></div>
        <button class="x" aria-label="Close">Ã—</button>`;
      toastWrap.appendChild(el);
      const close = ()=>{ el.style.animation="tout .16s ease-in forwards"; setTimeout(()=>el.remove(), 180); };
      el.querySelector(".x").onclick = close;
      if(timeout) setTimeout(close, timeout);
    }

    const jsonBig = (obj)=>JSON.stringify(obj, (_k,v)=> typeof v==="bigint" ? v.toString() : v, 2);
    function logLine(...args){
      const line = args.map(a=>{
        if(typeof a==="string") return a;
        try{ return jsonBig(a); }catch{ return String(a); }
      }).join(" ");
      logsEl.value += line + "\n";
      logsEl.scrollTop = logsEl.scrollHeight;
    }

    function toggleTextarea(el, btn){
      const hidden = el.style.display === "none" || !el.style.display;
      el.style.display = hidden ? "block" : "none";
      btn.textContent = hidden ? "Hide XDR" : "Show XDR";
    }

    function fmtScaledBigint(x, decimals=DECIMALS){
      if(typeof x !== "bigint") return String(x);
      const neg = x < 0n;
      const v = neg ? -x : x;
      const s = v.toString().padStart(decimals + 1, "0");
      const whole = s.slice(0, -decimals);
      const frac = s.slice(-decimals).replace(/0+$/,"");
      return (neg ? "-" : "") + whole + (frac ? "." + frac : "");
    }
    function parseDecimalToBigint(amountStr, decimals=DECIMALS){
      const s = String(amountStr||"").trim().replace(/,/g,"");
      if(!s) return 0n;
      if(!/^\d+(\.\d+)?$/.test(s)) throw new Error("Enter a positive number (e.g. 10 or 10.25)");
      const [i, dRaw=""] = s.split(".");
      const d = (dRaw + "0".repeat(decimals)).slice(0, decimals);
      return BigInt(i) * (10n ** BigInt(decimals)) + BigInt(d || "0");
    }

    function feeFromGross(grossScaled){
      const num = grossScaled * FEE_BPS_NUM;
      return (num + (FEE_BPS_DEN - 1n)) / FEE_BPS_DEN;
    }

    const sleep = (ms)=>new Promise(r=>setTimeout(r, ms));

    function txHashHexFromXdr(xdr){
      const tx = StellarSdk.TransactionBuilder.fromXDR(xdr, NETWORK_PASSPHRASE);
      const h = tx.hash();
      return Array.from(h).map(b => b.toString(16).padStart(2,"0")).join("");
    }

    async function waitHorizonTx(hash, { tries=40, delayMs=1200 } = {}){
      for(let i=0;i<tries;i++){
        const r = await fetch(`${HORIZON}/transactions/${hash}`);
        if(r.ok) return await r.json();
        await sleep(delayMs);
      }
      throw new Error("Timed out waiting for transaction confirmation on Horizon.");
    }

    async function rawRpc(method, params){
      const r = await fetch(SOROBAN_RPC, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ jsonrpc: "2.0", id: 1, method, params })
      });
      const j = await r.json();
      if(j.error) throw new Error(`${method} RPC error: ${j.error.message || JSON.stringify(j.error)}`);
      return j.result;
    }

    async function waitSorobanTx(hash, { tries=45, delayMs=1200 } = {}){
      for(let i=0;i<tries;i++){
        const res = await rawRpc("getTransaction", { hash });
        if(res.status === "SUCCESS") return res;
        if(res.status && res.status !== "NOT_FOUND") throw new Error(`Soroban status: ${res.status}`);
        await sleep(delayMs);
      }
      throw new Error("Timed out waiting for Soroban transaction confirmation.");
    }

    // Servers
    function makeSorobanServer(url){
      if (StellarSdk.SorobanRpc?.Server) return new StellarSdk.SorobanRpc.Server(url, { allowHttp: url.startsWith("http://") });
      if (StellarSdk.rpc?.Server) return new StellarSdk.rpc.Server(url, { allowHttp: url.startsWith("http://") });
      throw new Error("No Soroban RPC Server constructor found in stellar-sdk build.");
    }
    function makeHorizonServer(url){
      if (StellarSdk.Horizon?.Server) return new StellarSdk.Horizon.Server(url);
      if (StellarSdk.Server) return new StellarSdk.Server(url);
      throw new Error("No Horizon Server constructor found in stellar-sdk build.");
    }

    const contract = new StellarSdk.Contract(CONTRACT_ID);
    const USDC_ASSET = new StellarSdk.Asset(USDC_CODE, USDC_ISSUER);
    const BUSDC_ASSET = new StellarSdk.Asset(BUSDC_CODE, BUSDC_ISSUER);

    // -----------------------
    // Wallet state
    // -----------------------
    let mode = "none"; // none | wc | freighter | pubkey | secret
    let pubkey = null;
    let secret = null;

    let wcClient = null;
    let wcSession = null;
    let latestWcUri = null;

    // Vault routing
    let pendingVaultSubmitKind = null; // "classic" | "soroban"
    let pendingAfterVault = null;      // callback
    let pendingVaultHash = null;
    let pendingVaultAutoTimer = null;
    let pendingVaultAutoStop = false;

    // Per-action cached state
    const actionState = {
      deposit: { preflightOk:false, feePaid:false, invokeXdr:null, feeXdr:null, feeBig:0n, netBig:0n },
      redeem:  { preflightOk:false, feePaid:false, invokeXdr:null, feeXdr:null, feeBig:0n, netBig:0n },
    };

    // -----------------------
    // UI refs
    // -----------------------
    const refreshBtn = $("refreshBtn");
    const toggleLogsBtn = $("toggleLogsBtn");
    const stateStatus = $("stateStatus");

    const sharePriceOut = $("sharePriceOut");
    const impliedLine = $("impliedLine");
    const totalAssetsOut = $("totalAssetsOut");
    const totalSupplyOut = $("totalSupplyOut");

    const connStatus = $("connStatus");
    const connModeLine = $("connModeLine");
    const connectBtn = $("connectBtn");
    const disconnectBtn = $("disconnectBtn");

    const pubkeyEl = $("pubkeyEl");
    const seckeyEl = $("seckeyEl");
    const usePubkeyBtn = $("usePubkeyBtn");
    const useSecretBtn = $("useSecretBtn");
    const openExplorerBtn = $("openExplorerBtn");

    const usdcAvailOut = $("usdcAvailOut");
    const busdcAvailOut = $("busdcAvailOut");
    const usdcAvailInline = $("usdcAvailInline");
    const busdcAvailInline = $("busdcAvailInline");

    const refreshBalBtn = $("refreshBalBtn");
    const addTrustBtn = $("addTrustBtn");
    const balStatus = $("balStatus");

    const depositAmt = $("depositAmt");
    const redeemAmt = $("redeemAmt");

    const depFeeOut = $("depFeeOut");
    const depNetOut = $("depNetOut");
    const wdFeeOut = $("wdFeeOut");
    const wdNetOut = $("wdNetOut");

    const depPreflightBtn = $("depPreflightBtn");
    const depPayFeeBtn = $("depPayFeeBtn");
    const depExecuteBtn = $("depExecuteBtn");

    const wdPreflightBtn = $("wdPreflightBtn");
    const wdPayFeeBtn = $("wdPayFeeBtn");
    const wdExecuteBtn = $("wdExecuteBtn");

    const depositXdr = $("depositXdr");
    const redeemXdr = $("redeemXdr");
    const depositXdrToggle = $("depositXdrToggle");
    const redeemXdrToggle = $("redeemXdrToggle");

    const depositStatus = $("depositStatus");
    const redeemStatus = $("redeemStatus");

    const feeAck = $("feeAck");

    const backdrop = $("backdrop");
    const loginModal = $("loginModal");
    const closeModal = $("closeModal");
    const wcBtn = $("wcBtn");
    const freighterExtBtn = $("freighterExtBtn");
    const qrArea = $("qrArea");
    const qrCanvas = $("qrCanvas");
    const btnLobstr = $("btnLobstr");
    const btnFreighter = $("btnFreighter");
    const rawWcLink = $("rawWcLink");
    const linkStatus = $("linkStatus");

    // Vault modal
    const vaultModal = $("vaultModal");
    const closeVaultModal = $("closeVaultModal");
    const vaultXdrToVault = $("vaultXdrToVault");
    const copyVaultXdrBtn = $("copyVaultXdrBtn");
    const toggleVaultXdrBtn = $("toggleVaultXdrBtn");
    const vaultStatus = $("vaultStatus");
    const vaultCheckBtn = $("vaultCheckBtn");
    const vaultOpenSiteBtn = $("vaultOpenSiteBtn");
    const vaultAutoLine = $("vaultAutoLine");
    const vaultAutoPill = $("vaultAutoPill");
    const vaultSentLine = $("vaultSentLine");

    // Step modal
    const stepModal = $("stepModal");
    const closeStepModal = $("closeStepModal");
    const stepTitle = $("stepTitle");
    const stepBody = $("stepBody");
    const stepPrimaryBtn = $("stepPrimaryBtn");
    const stepSecondaryRow = $("stepSecondaryRow");
    const stepSecondaryBtn = $("stepSecondaryBtn");

    // WC sign modal
    const wcSignModal = $("wcSignModal");
    const closeWcSignModal = $("closeWcSignModal");
    const wcSignHeadline = $("wcSignHeadline");
    const wcSignBody = $("wcSignBody");
    const wcSignHint = $("wcSignHint");
    const wcSignStatus = $("wcSignStatus");
    const wcSignOpenLobstrBtn = $("wcSignOpenLobstrBtn");

    let availableUSDCScaled = null;
    let availableBUSDCScaled = null;

    function setConnPill(kind, label){
      connStatus.classList.remove("ok","warn","bad");
      connStatus.classList.add(kind);
      connStatus.querySelector("span:last-child").textContent = label;
    }

    function setConnected(address, newMode){
      pubkey = address || null;
      mode = newMode || "none";
      disconnectBtn.disabled = !pubkey;
      if(pubkey) pubkeyEl.value = pubkey;

      actionState.deposit = { preflightOk:false, feePaid:false, invokeXdr:null, feeXdr:null, feeBig:0n, netBig:0n };
      actionState.redeem  = { preflightOk:false, feePaid:false, invokeXdr:null, feeXdr:null, feeBig:0n, netBig:0n };
      syncActionButtons();

      if(!pubkey){
        setConnPill("bad","Not connected");
        connModeLine.textContent = "â€”";
        return;
      }

      setConnPill("ok","Connected");
      connModeLine.textContent = `Mode: ${mode}`;
      refreshBalance().catch(()=>{});
    }

    function syncActionButtons(){
      depPayFeeBtn.disabled   = !(feeAck.checked && actionState.deposit.preflightOk && !actionState.deposit.feePaid);
      depExecuteBtn.disabled  = !(actionState.deposit.feePaid && !!actionState.deposit.netBig && actionState.deposit.netBig > 0n);

      wdPayFeeBtn.disabled    = !(feeAck.checked && actionState.redeem.preflightOk && !actionState.redeem.feePaid);
      wdExecuteBtn.disabled   = !(actionState.redeem.feePaid && !!actionState.redeem.netBig && actionState.redeem.netBig > 0n);
    }
    feeAck.addEventListener("change", syncActionButtons);

    function clearActionUI(which){
      if(which === "deposit"){
        depositAmt.value = "";
        depositXdr.value = "";
        depFeeOut.textContent = "â€”";
        depNetOut.textContent = "â€”";
        depositXdr.style.display = "none";
        depositXdrToggle.textContent = "Reveal XDR";
      }else{
        redeemAmt.value = "";
        redeemXdr.value = "";
        wdFeeOut.textContent = "â€”";
        wdNetOut.textContent = "â€”";
        redeemXdr.style.display = "none";
        redeemXdrToggle.textContent = "Reveal XDR";
      }
    }

    // -----------------------
    // Modals (generic)
    // -----------------------
    function openModal(modalEl){
      backdrop.classList.add("open");
      modalEl.classList.add("open");
    }
    function closeModalEl(modalEl){
      modalEl.classList.remove("open");
      if(!loginModal.classList.contains("open") &&
         !vaultModal.classList.contains("open") &&
         !stepModal.classList.contains("open") &&
         !wcSignModal.classList.contains("open")){
        backdrop.classList.remove("open");
      }
    }

    function openConnectModal(){ openModal(loginModal); }
    function closeConnectModal(){
      loginModal.classList.remove("open");
      qrArea.style.display="none";
      if(!vaultModal.classList.contains("open") && !stepModal.classList.contains("open") && !wcSignModal.classList.contains("open")){
        backdrop.classList.remove("open");
      }
    }

    function openStepModal({ title, body, primaryText="Continue", onPrimary=null, secondaryText=null, onSecondary=null }){
      stepTitle.textContent = title || "â€”";
      stepBody.textContent = body || "";
      stepPrimaryBtn.textContent = primaryText || "Continue";
      stepPrimaryBtn.onclick = ()=>{
        closeModalEl(stepModal);
        if(typeof onPrimary === "function") onPrimary();
      };
      if(secondaryText){
        stepSecondaryRow.style.display = "flex";
        stepSecondaryBtn.textContent = secondaryText;
        stepSecondaryBtn.onclick = ()=>{
          closeModalEl(stepModal);
          if(typeof onSecondary === "function") onSecondary();
        };
      } else {
        stepSecondaryRow.style.display = "none";
        stepSecondaryBtn.onclick = null;
      }
      openModal(stepModal);
    }

    function openWcSignModal({ headline="Sign in your wallet", body="Please open LOBSTR to approve the signature request.", hint="" }){
      wcSignHeadline.textContent = headline;
      wcSignBody.textContent = body;
      wcSignHint.textContent = hint;
      wcSignStatus.textContent = "";
      openModal(wcSignModal);
    }
    function closeWcSignModalFn(){ closeModalEl(wcSignModal); }

    // -----------------------
    // LOBSTR Vault POST helper
    // -----------------------
    async function pushToLobstrVault({ signedXdr }){
      if(!LOBSTR_VAULT_CREATE_URL || LOBSTR_VAULT_CREATE_URL.includes("PASTE_YOUR_WORKING")){
        throw new Error("LOBSTR_VAULT_CREATE_URL not set.");
      }

      const r = await fetch(LOBSTR_VAULT_CREATE_URL, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({
          xdr: signedXdr,
          network_passphrase: NETWORK_PASSPHRASE
        })
      });

      // Your test said "HTTP 201 (OK)" so treat any 2xx as success.
      if(!r.ok){
        const txt = await r.text().catch(()=> "");
        throw new Error(`Vault POST failed (${r.status}). ${txt}`);
      }

      const j = await r.json();
      if(!j?.hash) throw new Error("Vault POST returned no hash.");
      return {
        hash: String(j.hash),
        xdr: String(j.xdr || signedXdr),
        network_passphrase: String(j.network_passphrase || NETWORK_PASSPHRASE),
      };
    }

    // -----------------------
    // Vault modal
    // -----------------------
    function stopVaultAutoCheck(){
      pendingVaultAutoStop = true;
      if(pendingVaultAutoTimer){
        clearTimeout(pendingVaultAutoTimer);
        pendingVaultAutoTimer = null;
      }
    }

    async function runVaultAutoCheck(){
      stopVaultAutoCheck();
      pendingVaultAutoStop = false;

      vaultAutoPill.textContent = "Auto-checkingâ€¦";
      vaultAutoPill.classList.remove("ok","warn","bad");
      vaultAutoPill.classList.add("warn");
      vaultStatus.textContent = "";
      vaultCheckBtn.disabled = true;

      for(let i=1; i<=VAULT_AUTO_TRIES && !pendingVaultAutoStop; i++){
        vaultAutoLine.textContent = `Auto-checking confirmationâ€¦ (${i}/${VAULT_AUTO_TRIES})`;
        try{
          if(pendingVaultSubmitKind === "classic"){
            const r = await fetch(`${HORIZON}/transactions/${pendingVaultHash}`);
            if(r.ok){
              const j = await r.json();
              vaultAutoPill.textContent = "Confirmed âœ“";
              vaultAutoPill.classList.remove("warn"); vaultAutoPill.classList.add("ok");
              vaultStatus.innerHTML = `Confirmed âœ“ tx: <span class="mono">${j.hash}</span>`;
              toast({type:"ok", title:"Confirmed", message:"Vault submission confirmed on-chain.", timeout:3400});
              vaultCheckBtn.disabled = false;

              const cb = pendingAfterVault;
              closeVaultModalFn();
              if(typeof cb === "function") cb();
              refreshState().catch(()=>{});
              refreshBalance().catch(()=>{});
              return;
            }
          } else {
            const res = await rawRpc("getTransaction", { hash: pendingVaultHash });
            if(res.status === "SUCCESS"){
              vaultAutoPill.textContent = "Confirmed âœ“";
              vaultAutoPill.classList.remove("warn"); vaultAutoPill.classList.add("ok");
              vaultStatus.innerHTML = `Confirmed âœ“ hash: <span class="mono">${pendingVaultHash}</span>`;
              toast({type:"ok", title:"Confirmed", message:"Vault submission confirmed on-chain.", timeout:3400});
              vaultCheckBtn.disabled = false;

              const cb = pendingAfterVault;
              closeVaultModalFn();
              if(typeof cb === "function") cb();
              refreshState().catch(()=>{});
              refreshBalance().catch(()=>{});
              return;
            }
            if(res.status && res.status !== "NOT_FOUND"){
              vaultAutoPill.textContent = "Error";
              vaultAutoPill.classList.remove("warn"); vaultAutoPill.classList.add("bad");
              vaultStatus.textContent = `Error: Soroban status ${res.status}`;
              vaultCheckBtn.disabled = false;
              return;
            }
          }
        }catch(e){
          vaultStatus.textContent = `Waitingâ€¦ (${e?.message || e})`;
        }
        await sleep(VAULT_AUTO_DELAY_MS);
      }

      if(!pendingVaultAutoStop){
        vaultAutoPill.textContent = "Timed out";
        vaultAutoPill.classList.remove("warn"); vaultAutoPill.classList.add("bad");
        vaultAutoLine.textContent = "Auto-check maxed. Please tap â€œCheck statusâ€.";
        vaultCheckBtn.disabled = false;
      }
    }

    function openVaultModalCore({ kind, afterCb, hash, xdrForOptionalReveal, sentMsg }){
      pendingVaultSubmitKind = kind;
      pendingAfterVault = afterCb || null;

      pendingVaultHash = hash || null;

      // XDR hidden by default
      vaultXdrToVault.value = xdrForOptionalReveal || "";
      vaultXdrToVault.style.display = "none";
      toggleVaultXdrBtn.textContent = "Show XDR";
      copyVaultXdrBtn.style.display = "none";

      vaultSentLine.textContent = sentMsg || "Transaction prepared for Vault.";
      vaultAutoLine.textContent = "Auto-checking will start nowâ€¦";

      vaultAutoPill.textContent = "Waitingâ€¦";
      vaultAutoPill.classList.remove("ok","warn","bad");
      vaultAutoPill.classList.add("warn");

      openModal(vaultModal);
      runVaultAutoCheck().catch(()=>{});
    }

    async function openVaultModalWithPush(signedXdr, kind, afterCb){
      // Show modal immediately with "sending" state, then update once POST succeeds
      openVaultModalCore({
        kind,
        afterCb,
        hash: txHashHexFromXdr(signedXdr), // fallback
        xdrForOptionalReveal: signedXdr,
        sentMsg: "Sending transaction to LOBSTR Vaultâ€¦"
      });

      try{
        const created = await pushToLobstrVault({ signedXdr });
        pendingVaultHash = created.hash;

        // Update UI line + keep XDR optional
        vaultSentLine.textContent = "Sent to LOBSTR Vault âœ“ Now open Vault to sign & submit.";
        // leave auto-check running (it will now check using pendingVaultHash)
      }catch(e){
        // If POST fails, we fall back to manual flow (XDR toggle + copy)
        vaultSentLine.textContent = "Could not auto-send to Vault. Use Show XDR â†’ copy/paste into Vault manually.";
        toast({type:"err", title:"Vault POST failed", message: e?.message || String(e), timeout:4500});
      }
    }

    function closeVaultModalFn(){
      stopVaultAutoCheck();
      closeModalEl(vaultModal);
      pendingVaultSubmitKind = null;
      pendingAfterVault = null;
      pendingVaultHash = null;
      vaultAutoLine.textContent = "â€”";
      vaultStatus.textContent = "";
      vaultSentLine.textContent = "â€”";
    }

    // -----------------------
    // WalletConnect
    // -----------------------
    const isIOS = ()=> /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    function openLobstrApp(uri){
      const scheme = `lobstr://wc?uri=${encodeURIComponent(uri)}`;
      const store  = isIOS()
        ? "https://apps.apple.com/app/id1404357892"
        : "https://play.google.com/store/apps/details?id=com.lobstr.client";
      const t0 = Date.now();
      window.location.href = scheme;
      setTimeout(()=>{ if(!document.hidden && Date.now()-t0<2000){ window.open(store, "_blank", "noopener"); } }, 1800);
    }

    function openLobstrForSigning(){
      if(latestWcUri){
        openLobstrApp(latestWcUri);
        return;
      }
      const store  = isIOS()
        ? "https://apps.apple.com/app/id1404357892"
        : "https://play.google.com/store/apps/details?id=com.lobstr.client";
      const t0 = Date.now();
      window.location.href = "lobstr://";
      setTimeout(()=>{ if(!document.hidden && Date.now()-t0<2000){ window.open(store, "_blank", "noopener"); } }, 1800);
    }

    async function purgeWcStorage(){
      try{
        Object.keys(localStorage).forEach(k=>{
          if(k.startsWith("wc@2")) localStorage.removeItem(k);
        });
      }catch{}
    }

    async function ensureWcClient({ retry=false } = {}){
      if(wcClient) return wcClient;
      try{
        wcClient = await SignClient.init({
          projectId: PROJECT_ID,
          relayUrl: "wss://relay.walletconnect.com",
          metadata: {
            name: "bUSDC Vault UI",
            description: "Vault UI for bUSDC contract",
            url: location.origin,
            icons: ["https://walletconnect.com/walletconnect-logo.png"]
          }
        });

        // silence "emitting session_request ... without any listeners"
        try{ wcClient.on("session_request", ()=>{}); }catch{}

        return wcClient;
      }catch(e){
        if(!retry && /No matching key/i.test(String(e?.message||e))){
          await purgeWcStorage();
          wcClient = null;
          return ensureWcClient({ retry:true });
        }
        throw e;
      }
    }

    async function getFreighterLinks(){
      try{
        const url = `${EXPLORER}?projectId=${encodeURIComponent(PROJECT_ID)}&entries=200&page=1`;
        const res = await fetch(url);
        const data = await res.json();
        const list = data?.listings ?? data?.data ?? [];
        const arr = Array.isArray(list) ? list : Object.values(list);
        const w = arr.find(it => ((it.name||it.app?.name||"").toLowerCase()).includes("freighter"));
        const mobile = w?.mobile || w?.app?.mobile || {};
        return { native: mobile.native||mobile.nativeLink||null, universal: mobile.universal||mobile.universalLink||null, found: !!w };
      }catch{
        return { native:null, universal:null, found:false };
      }
    }
    function buildCandidates(base, wcUri){
      if(!base) return [];
      const enc = encodeURIComponent(wcUri);
      if (base.includes("{wc}") || base.includes("{URI}")) return [ base.replace("{wc}",enc).replace("{URI}",enc) ];
      const j = base.includes("?") ? "&" : "?";
      return [ `${base}${j}wc=${enc}`, `${base}${j}uri=${enc}` ];
    }
    function openFreighterSmart(links, wcUri){
      const store = isIOS()
        ? "https://apps.apple.com/app/freighter/id6743947720"
        : "https://play.google.com/store/apps/details?id=org.stellar.freighterwallet&pli=1";
      const natives = buildCandidates(links.native, wcUri);
      const universals = buildCandidates(links.universal, wcUri);
      let attempted=false;
      if(natives.length){ attempted=true; window.location.href = natives[0]; }
      else if(universals.length){ attempted=true; window.open(universals[0], "_blank", "noopener"); }
      if(!attempted){ window.open(store, "_blank", "noopener"); }
    }

    // -----------------------
    // Freighter API
    // -----------------------
    async function ensureFreighterApi(){
      if (window.freighterApi) return window.freighterApi;
      try{
        const mod = await import("https://esm.sh/@stellar/freighter-api@5.0.0?target=es2022");
        window.freighterApi = mod?.default ?? mod;
        return window.freighterApi;
      }catch{
        return null;
      }
    }
    async function ensureFreighterApiSafe(){
      const api = await ensureFreighterApi();
      if(!api) throw new Error("Freighter extension not detected.");
      return api;
    }

    // -----------------------
    // Signing + submit
    // -----------------------
    async function signXdr(xdr){
      if(mode==="pubkey" || mode==="none") throw new Error("Read-only. Connect WalletConnect/Freighter or use secret key.");
      if(mode==="secret"){
        const tx = StellarSdk.TransactionBuilder.fromXDR(xdr, NETWORK_PASSPHRASE);
        tx.sign(StellarSdk.Keypair.fromSecret(secret));
        return tx.toXDR();
      }
      if(mode==="freighter"){
        const api = await ensureFreighterApiSafe();
        const res = await api.signTransaction(xdr, { networkPassphrase: NETWORK_PASSPHRASE, accountToSign: pubkey });
        if(res?.error) throw new Error(res.error.message || "Freighter: sign failed");
        return res.signedTxXdr || res.signedXDR || res;
      }
      if(mode==="wc"){
        if(!wcClient || !wcSession) throw new Error("WalletConnect not ready.");
        const r = await wcClient.request({
          topic: wcSession.topic,
          chainId: "stellar:pubnet",
          request: { jsonrpc:"2.0", method:"stellar_signXDR", params:{ xdr } }
        });
        if(!r?.signedXDR) throw new Error("WalletConnect: no signedXDR");
        return r.signedXDR;
      }
      throw new Error("Unsupported signing mode.");
    }

    async function signWithUserPrompt(xdr, { headline, body }){
      if(mode !== "wc") return await signXdr(xdr);

      openWcSignModal({
        headline: headline || "Sign in your wallet",
        body: body || "Please open LOBSTR to approve the signature request.",
        hint: "If nothing pops up, tap â€œOpen LOBSTRâ€ again."
      });
      wcSignOpenLobstrBtn.onclick = openLobstrForSigning;

      wcSignStatus.textContent = "Waiting for signatureâ€¦";
      try{
        const signed = await signXdr(xdr);
        wcSignStatus.textContent = "Signature received âœ“";
        closeWcSignModalFn();
        return signed;
      }catch(e){
        wcSignStatus.textContent = `Error: ${e?.message || e}`;
        throw e;
      }
    }

    async function submitClassicTxXdrToHorizon(signedXdr){
      const srv = makeHorizonServer(HORIZON);
      const tx = StellarSdk.TransactionBuilder.fromXDR(signedXdr, NETWORK_PASSPHRASE);
      return await srv.submitTransaction(tx);
    }

    async function submitSorobanSignedXdr(signedXdr){
      const server = makeSorobanServer(SOROBAN_RPC);
      const tx = StellarSdk.TransactionBuilder.fromXDR(signedXdr, NETWORK_PASSPHRASE);

      const send = await server.sendTransaction(tx);
      if(send.status !== "PENDING" && send.status !== "SUCCESS"){
        throw new Error(`sendTransaction: ${send.status}`);
      }

      let res = await rawRpc("getTransaction", { hash: send.hash });
      for(let i=0; i<25 && res.status==="NOT_FOUND"; i++){
        await sleep(900);
        res = await rawRpc("getTransaction", { hash: send.hash });
      }
      if(res.status !== "SUCCESS") throw new Error(`Tx status: ${res.status}`);

      return { hash: send.hash, ...res };
    }

    // -----------------------
    // Account + trustline helpers
    // -----------------------
    async function getAccountJson(pk){
      const r = await fetch(`${HORIZON}/accounts/${pk}`);
      if(!r.ok) throw new Error(`Horizon account fetch failed (${r.status})`);
      return await r.json();
    }

    async function hasBUSDCTrustline(pk){
      const j = await getAccountJson(pk);
      const bal = (j.balances || []).find(b => b.asset_code===BUSDC_CODE && b.asset_issuer===BUSDC_ISSUER);
      return !!bal;
    }

    async function hasVault(account){
      if(!VAULT_SIGNER_KEY) return false;
      try{
        const j = await getAccountJson(account);
        const ks = (j.signers || []).map(s=>s.key);
        return ks.includes(VAULT_SIGNER_KEY);
      }catch{
        return false;
      }
    }

    async function buildChangeTrustXdr(limit=null){
      if(!pubkey) throw new Error("Connect a wallet first.");
      const srv = makeHorizonServer(HORIZON);
      const acc = await srv.loadAccount(pubkey);

      const op = StellarSdk.Operation.changeTrust({
        asset: BUSDC_ASSET,
        limit: limit ?? undefined
      });

      const tx = new StellarSdk.TransactionBuilder(acc, {
        fee: TX_FEE,
        networkPassphrase: NETWORK_PASSPHRASE
      })
        .addOperation(op)
        .setTimeout(120)
        .build();

      return tx.toXDR();
    }

    async function ensureBUSDCTrustline({ interactive=true } = {}){
      if(!pubkey) throw new Error("Connect a wallet first.");
      const ok = await hasBUSDCTrustline(pubkey);
      if(ok) return true;
      if(!interactive) return false;

      toast({type:"info", title:"Trustline needed", message:"You need a bUSDC trustline before deposit. Creating it nowâ€¦", timeout:3500});
      balStatus.textContent = "Creating bUSDC trustlineâ€¦";

      const xdr = await buildChangeTrustXdr(null);
      const signed = await signWithUserPrompt(xdr, { headline:"Sign trustline", body:"Open LOBSTR to approve the trustline transaction." });
      const res = await submitClassicTxXdrToHorizon(signed);

      balStatus.textContent = `Trustline added âœ“ tx: ${res.hash}`;
      toast({type:"ok", title:"Trustline added", message:"bUSDC trustline created.", timeout:4200});
      await refreshBalance();
      return true;
    }

    // -----------------------
    // Balances
    // -----------------------
    function strToScaledBigint(amountStr){
      return parseDecimalToBigint(amountStr || "0", DECIMALS);
    }

    async function refreshBalance(){
      const pk = pubkeyEl.value.trim();
      if(!StellarSdk.StrKey.isValidEd25519PublicKey(pk)){
        usdcAvailOut.textContent = "â€”";
        busdcAvailOut.textContent = "â€”";
        usdcAvailInline.textContent = "â€”";
        busdcAvailInline.textContent = "â€”";
        availableUSDCScaled = null;
        availableBUSDCScaled = null;
        return;
      }
      balStatus.textContent = "Loading balancesâ€¦";
      try{
        const j = await getAccountJson(pk);

        const usdc = (j.balances || []).find(b => b.asset_code===USDC_CODE && b.asset_issuer===USDC_ISSUER);
        const busdc = (j.balances || []).find(b => b.asset_code===BUSDC_CODE && b.asset_issuer===BUSDC_ISSUER);

        if(usdc){
          const bal = strToScaledBigint(usdc.balance);
          const liab = strToScaledBigint(usdc.selling_liabilities || "0");
          const avail = bal > liab ? (bal - liab) : 0n;
          availableUSDCScaled = avail;
          const s = fmtScaledBigint(avail);
          usdcAvailOut.textContent = s;
          usdcAvailInline.textContent = s;
        } else {
          availableUSDCScaled = 0n;
          usdcAvailOut.textContent = "NO TRUSTLINE";
          usdcAvailInline.textContent = "NO TRUSTLINE";
        }

        if(busdc){
          const bal = strToScaledBigint(busdc.balance);
          const liab = strToScaledBigint(busdc.selling_liabilities || "0");
          const avail = bal > liab ? (bal - liab) : 0n;
          availableBUSDCScaled = avail;
          const s = fmtScaledBigint(avail);
          busdcAvailOut.textContent = s;
          busdcAvailInline.textContent = s;
        } else {
          availableBUSDCScaled = 0n;
          busdcAvailOut.textContent = "NO TRUSTLINE";
          busdcAvailInline.textContent = "NO TRUSTLINE";
        }

        balStatus.textContent = "";
      }catch(e){
        availableUSDCScaled = null;
        availableBUSDCScaled = null;
        balStatus.textContent = "Could not load balances.";
      }
    }

    // -----------------------
    // Soroban reads
    // -----------------------
    function scvToNativeFromSim(sim){
      const r0 = sim?.result?.results?.[0]?.xdr;
      if(r0) return StellarSdk.scValToNative(r0);
      const rv = sim?.result?.retval;
      if(rv) return StellarSdk.scValToNative(rv);
      return null;
    }

    async function simulate(method, argsScv=[]){
      const server = makeSorobanServer(SOROBAN_RPC);
      const acc = await server.getAccount("GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF");
      const tx = new StellarSdk.TransactionBuilder(acc, { fee: TX_FEE, networkPassphrase: NETWORK_PASSPHRASE })
        .addOperation(contract.call(method, ...argsScv))
        .setTimeout(60)
        .build();

      logLine(`â†’ simulate ${method}`);
      const sim = await server.simulateTransaction(tx);
      if (StellarSdk.SorobanRpc?.Api?.isSimulationError?.(sim)) {
        throw new Error("Simulation error: " + jsonBig(sim));
      }
      return sim;
    }

    async function refreshState(){
      stateStatus.textContent = "Refreshingâ€¦";
      try{
        const [spSim, taSim, tsSim] = await Promise.all([
          simulate("share_price"),
          simulate("total_assets"),
          simulate("total_supply"),
        ]);

        const sharePrice = scvToNativeFromSim(spSim);
        const totalAssets = scvToNativeFromSim(taSim);
        const totalSupply = scvToNativeFromSim(tsSim);

        if (typeof sharePrice === "bigint"){
          sharePriceOut.textContent = fmtScaledBigint(sharePrice);
          impliedLine.textContent = `1 bUSDC â‰ˆ ${fmtScaledBigint(sharePrice)} USDC`;
        } else {
          sharePriceOut.textContent = String(sharePrice ?? "â€”");
          impliedLine.textContent = "â€”";
        }

        totalAssetsOut.textContent = (typeof totalAssets==="bigint") ? fmtScaledBigint(totalAssets) : String(totalAssets ?? "â€”");
        totalSupplyOut.textContent = (typeof totalSupply==="bigint") ? fmtScaledBigint(totalSupply) : String(totalSupply ?? "â€”");

        stateStatus.textContent = "Updated.";
      }catch(e){
        console.error(e);
        stateStatus.textContent = `Error: ${e.message || e}`;
        toast({type:"err", title:"Error", message:e.message || "Refresh failed"});
      }
    }

    // -----------------------
    // Fee boxes
    // -----------------------
    function updateFeeBoxes(){
      try{
        const gross = parseDecimalToBigint(depositAmt.value, DECIMALS);
        if(gross > 0n){
          const fee = feeFromGross(gross);
          const net = gross > fee ? (gross - fee) : 0n;
          depFeeOut.textContent = `${fmtScaledBigint(fee)} ${USDC_CODE}`;
          depNetOut.textContent = `${fmtScaledBigint(net)} ${USDC_CODE}`;
        } else { depFeeOut.textContent = "â€”"; depNetOut.textContent = "â€”"; }
      }catch{ depFeeOut.textContent = "â€”"; depNetOut.textContent = "â€”"; }

      try{
        const gross = parseDecimalToBigint(redeemAmt.value, DECIMALS);
        if(gross > 0n){
          const fee = feeFromGross(gross);
          const net = gross > fee ? (gross - fee) : 0n;
          wdFeeOut.textContent = `${fmtScaledBigint(fee)} ${BUSDC_CODE}`;
          wdNetOut.textContent = `${fmtScaledBigint(net)} ${BUSDC_CODE}`;
        } else { wdFeeOut.textContent = "â€”"; wdNetOut.textContent = "â€”"; }
      }catch{ wdFeeOut.textContent = "â€”"; wdNetOut.textContent = "â€”"; }
    }

    function resetAction(which){
      actionState[which].preflightOk = false;
      actionState[which].feePaid = false;
      actionState[which].invokeXdr = null;
      actionState[which].feeXdr = null;
      actionState[which].feeBig = 0n;
      actionState[which].netBig = 0n;
      syncActionButtons();
    }

    // -----------------------
    // Minimum checks
    // -----------------------
    const MIN_NET_BI = parseDecimalToBigint(String(MIN_NET), DECIMALS);
    const MIN_GROSS_BI = parseDecimalToBigint(MIN_GROSS_DISPLAY, DECIMALS);

    function enforceGrossAndNet({ gross, net, label }){
      if(gross < MIN_GROSS_BI) throw new Error(`${label} minimum is ${MIN_GROSS_DISPLAY}.`);
      if(net < MIN_NET_BI) throw new Error(`${label} net amount must be â‰¥ ${MIN_NET}.`);
    }

    // -----------------------
    // Build tx helpers
    // -----------------------
    async function buildFeePaymentXdr({ asset, amountScaled }){
      const srv = makeHorizonServer(HORIZON);
      const acc = await srv.loadAccount(pubkey);

      const tx = new StellarSdk.TransactionBuilder(acc, {
        fee: TX_FEE,
        networkPassphrase: NETWORK_PASSPHRASE
      })
        .addOperation(StellarSdk.Operation.payment({
          destination: COLLECTION_WALLET,
          asset,
          amount: fmtScaledBigint(amountScaled),
        }))
        .setTimeout(120)
        .build();

      return tx.toXDR();
    }

    async function buildAssembledInvokeXdr({ method, netScaled }){
      const rpc = makeSorobanServer(SOROBAN_RPC);
      const acc = await rpc.getAccount(pubkey);

      const addrScv = new StellarSdk.Address(pubkey).toScVal();
      const netScv  = StellarSdk.nativeToScVal(netScaled, { type: "i128" });

      const tx = new StellarSdk.TransactionBuilder(acc, {
        fee: TX_FEE,
        networkPassphrase: NETWORK_PASSPHRASE
      })
        .addOperation(contract.call(method, netScv, addrScv, addrScv, addrScv))
        .setTimeout(180)
        .build();

      const sim = await (async ()=>{
        try { return await rpc.simulateTransaction(tx); }
        catch (e){ console.error("simulateTransaction threw:", e); throw new Error("simulateTransaction threw: " + (e?.message || String(e))); }
      })();

      if (StellarSdk.SorobanRpc?.Api?.isSimulationError?.(sim)) {
        console.error("Simulation error payload:", sim);
        throw new Error("Simulation error (see console).");
      }

      const assembled = StellarSdk.SorobanRpc.assembleTransaction(tx, sim).build();
      return assembled.toXDR();
    }

    // -----------------------
    // Preflight / Fee / Execute
    // -----------------------
    async function preflight(which, inputEl, statusEl){
      statusEl.textContent = "";
      try{
        if(!pubkey){ openConnectModal(); return; }
        if(mode==="pubkey" || mode==="none") throw new Error("Read-only. Connect WalletConnect/Freighter or use secret key.");

        await refreshBalance();

        const gross = parseDecimalToBigint(inputEl.value, DECIMALS);
        if(!(gross > 0n)) throw new Error("Enter an amount.");

        const feeBig = feeFromGross(gross);
        const netBig = gross > feeBig ? (gross - feeBig) : 0n;

        enforceGrossAndNet({ gross, net: netBig, label: which==="deposit" ? "Deposit" : "Withdraw" });

        if(which==="deposit"){
          if(typeof availableUSDCScaled !== "bigint") throw new Error("Could not read USDC balance.");
          if(availableUSDCScaled < gross) throw new Error("Insufficient available USDC for the gross amount you entered.");
          const ok = await ensureBUSDCTrustline({ interactive:true });
          if(!ok) throw new Error("Missing bUSDC trustline.");
        }else{
          if(typeof availableBUSDCScaled !== "bigint") throw new Error("Could not read bUSDC balance.");
          if(availableBUSDCScaled < gross) throw new Error("Insufficient available bUSDC for the gross amount you entered.");
        }

        statusEl.textContent = "Preflight: simulating Sorobanâ€¦";
        const invokeXdr = await buildAssembledInvokeXdr({
          method: which==="deposit" ? "deposit" : "redeem",
          netScaled: netBig
        });

        actionState[which].preflightOk = true;
        actionState[which].feePaid = false;
        actionState[which].invokeXdr = invokeXdr;
        actionState[which].feeBig = feeBig;
        actionState[which].netBig = netBig;

        const feeAsset = (which==="deposit" ? USDC_ASSET : BUSDC_ASSET);
        actionState[which].feeXdr = await buildFeePaymentXdr({ asset: feeAsset, amountScaled: feeBig });

        if(which==="deposit") depositXdr.value = invokeXdr;
        else redeemXdr.value = invokeXdr;

        statusEl.textContent = `Preflight âœ“ Ready. Net: ${fmtScaledBigint(netBig)} Â· Fee: ${fmtScaledBigint(feeBig)}`;
        toast({type:"ok", title:"Preflight OK", message:`${which} ready Â· net ${fmtScaledBigint(netBig)} Â· fee ${fmtScaledBigint(feeBig)}`});
        syncActionButtons();

        openStepModal({
          title: "Preflight successful âœ…",
          body: `Everything checks out.\nNext step: pay the non-refundable 0.15% fee to continue.`,
          primaryText: "Continue â†’ Pay fee",
          onPrimary: ()=>{
            const btn = (which==="deposit") ? $("depPayFeeBtn") : $("wdPayFeeBtn");
            if(btn?.disabled){
              toast({type:"info", title:"Next step not ready", message:"Please tick the fee acknowledgement first."});
              return;
            }
            btn.click();
          }
        });

      }catch(e){
        console.error(e);
        actionState[which].preflightOk = false;
        actionState[which].feePaid = false;
        actionState[which].invokeXdr = null;
        actionState[which].feeXdr = null;
        syncActionButtons();
        statusEl.textContent = `Preflight failed: ${e.message || e}`;
        toast({type:"err", title:"Preflight failed", message:e.message || String(e)});
      }
    }

    async function payFee(which, statusEl){
      statusEl.textContent = "";
      try{
        if(!feeAck.checked) throw new Error("Tick the non-refundable fee acknowledgement first.");
        if(!actionState[which].preflightOk || !actionState[which].feeXdr) throw new Error("Run Preflight first.");

        const feeXdr = actionState[which].feeXdr;

        if(await hasVault(pubkey)){
          statusEl.textContent = "Signing (your signature)â€¦";
          const signedByUser = await signWithUserPrompt(feeXdr, {
            headline: "Sign fee transaction",
            body: "Open LOBSTR to approve the fee transaction signature request."
          });

          statusEl.textContent = "Sending to Vault + opening co-signâ€¦";
          await openVaultModalWithPush(signedByUser, "classic", ()=>{
            actionState[which].feePaid = true;
            syncActionButtons();
            statusEl.textContent = `Fee confirmed âœ“ Now execute ${which}.`;
            actionState[which].invokeXdr = null;
            refreshBalance().catch(()=>{});

            openStepModal({
              title: "Fee paid successfully âœ…",
              body: `The fee has been confirmed on-chain.\nNext step: execute your ${which==="deposit"?"deposit":"withdrawal"}.`,
              primaryText: which==="deposit" ? "Execute Deposit" : "Execute Withdrawal",
              onPrimary: ()=>{
                if(which==="deposit") $("depExecuteBtn").click();
                else $("wdExecuteBtn").click();
              }
            });
          });
          return;
        }

        statusEl.textContent = "Signing fee txâ€¦";
        const signed = await signWithUserPrompt(feeXdr, {
          headline: "Sign fee transaction",
          body: "Open LOBSTR to approve the fee transaction signature request."
        });
        statusEl.textContent = "Submitting fee txâ€¦";
        const res = await submitClassicTxXdrToHorizon(signed);

        actionState[which].feePaid = true;
        syncActionButtons();
        statusEl.textContent = `Fee paid âœ“ tx: ${res.hash}`;
        toast({type:"ok", title:"Fee paid", message:`tx ${res.hash}`});
        refreshBalance().catch(()=>{});

        openStepModal({
          title: "Fee paid successfully âœ…",
          body: `The fee has been confirmed on-chain.\nNext step: execute your ${which==="deposit"?"deposit":"withdrawal"}.`,
          primaryText: which==="deposit" ? "Execute Deposit" : "Execute Withdrawal",
          onPrimary: ()=>{
            if(which==="deposit") $("depExecuteBtn").click();
            else $("wdExecuteBtn").click();
          }
        });

      }catch(e){
        console.error(e);
        statusEl.textContent = `Fee step failed: ${e.message || e}`;
        toast({type:"err", title:"Fee failed", message:e.message || String(e)});
      }
    }

    async function executeInvoke(which, statusEl){
      statusEl.textContent = "";
      try{
        if(!actionState[which].feePaid) throw new Error("Pay the fee first.");
        if(!actionState[which].netBig || actionState[which].netBig <= 0n) {
          throw new Error("Missing cached net amount. Run Preflight again.");
        }

        const method = which==="deposit" ? "deposit" : "redeem";

        statusEl.textContent = "Rebuilding Soroban tx (fresh sequence)â€¦";
        const freshInvokeXdr = await buildAssembledInvokeXdr({
          method,
          netScaled: actionState[which].netBig
        });

        actionState[which].invokeXdr = freshInvokeXdr;
        if(which==="deposit") depositXdr.value = freshInvokeXdr;
        else redeemXdr.value = freshInvokeXdr;

        if(await hasVault(pubkey)){
          statusEl.textContent = "Signing (your signature)â€¦";
          const signedByUser = await signWithUserPrompt(freshInvokeXdr, {
            headline: "Sign execution transaction",
            body: "Open LOBSTR to approve the execution transaction signature request."
          });

          statusEl.textContent = "Sending to Vault + opening co-signâ€¦";
          await openVaultModalWithPush(signedByUser, "soroban", ()=>{
            clearActionUI(which);
            resetAction(which);
            statusEl.textContent = `${which==="deposit"?"Deposit":"Withdrawal"} submitted âœ“`;
            refreshState().catch(()=>{});
            refreshBalance().catch(()=>{});

            openStepModal({
              title: (which==="deposit" ? "Deposit successful ðŸŽ‰" : "Withdrawal successful ðŸŽ‰"),
              body: "Your transaction has been confirmed on-chain.\nBalances will update shortly.",
              primaryText: "Done",
              onPrimary: ()=>{}
            });
          });
          return;
        }

        statusEl.textContent = "Signing invoke txâ€¦";
        const signed = await signWithUserPrompt(freshInvokeXdr, {
          headline: "Sign execution transaction",
          body: "Open LOBSTR to approve the execution transaction signature request."
        });

        statusEl.textContent = "Submitting invoke txâ€¦";
        const res = await submitSorobanSignedXdr(signed);

        clearActionUI(which);
        resetAction(which);

        statusEl.innerHTML = `Submitted âœ“ hash: <span class="mono">${res.hash}</span>`;
        toast({type:"ok", title:"Success", message:`${which} complete Â· hash ${res.hash}`});

        refreshState().catch(()=>{});
        refreshBalance().catch(()=>{});

        openStepModal({
          title: (which==="deposit" ? "Deposit successful ðŸŽ‰" : "Withdrawal successful ðŸŽ‰"),
          body: "Your transaction has been confirmed on-chain.\nBalances will update shortly.",
          primaryText: "Done",
          onPrimary: ()=>{}
        });

      }catch(e){
        console.error(e);
        statusEl.textContent = `Execute failed: ${e.message || e}`;
        toast({type:"err", title:"Execute failed", message:e.message || String(e)});
      }
    }

    // -----------------------
    // Wire UI events
    // -----------------------
    connectBtn.onclick = openConnectModal;
    closeModal.onclick = closeConnectModal;
    closeVaultModal.onclick = closeVaultModalFn;
    closeStepModal.onclick = ()=>closeModalEl(stepModal);
    closeWcSignModal.onclick = closeWcSignModalFn;

    backdrop.addEventListener("click", ()=>{
      if(loginModal.classList.contains("open")) closeConnectModal();
      if(stepModal.classList.contains("open")) closeModalEl(stepModal);
      if(wcSignModal.classList.contains("open")) closeWcSignModalFn();
      if(vaultModal.classList.contains("open")) closeVaultModalFn();
    });

    // Vault buttons
    toggleVaultXdrBtn.onclick = ()=>{
      const willShow = (vaultXdrToVault.style.display === "none" || !vaultXdrToVault.style.display);
      vaultXdrToVault.style.display = willShow ? "block" : "none";
      toggleVaultXdrBtn.textContent = willShow ? "Hide XDR" : "Show XDR";
      copyVaultXdrBtn.style.display = willShow ? "inline-flex" : "none";
    };

    copyVaultXdrBtn.onclick = async ()=>{
      try{
        await navigator.clipboard.writeText(vaultXdrToVault.value || "");
        toast({type:"ok", title:"Copied", message:"XDR copied to clipboard."});
      }catch{
        toast({type:"err", title:"Error", message:"Could not copy (clipboard blocked)."});
      }
    };

    vaultOpenSiteBtn.onclick = ()=>{
      window.open("https://lobstr.co/vault/", "_blank", "noopener,noreferrer");
    };

    vaultCheckBtn.onclick = async ()=>{
      try{
        if(!pendingVaultHash) throw new Error("Missing tx hash.");
        vaultStatus.textContent = "Checkingâ€¦";
        if(pendingVaultSubmitKind === "classic"){
          const j = await waitHorizonTx(pendingVaultHash, { tries: 3, delayMs: 800 });
          vaultStatus.innerHTML = `Confirmed âœ“ tx: <span class="mono">${j.hash}</span>`;
        } else {
          const res = await waitSorobanTx(pendingVaultHash, { tries: 3, delayMs: 800 });
          vaultStatus.innerHTML = `Confirmed âœ“ hash: <span class="mono">${res.hash}</span>`;
        }
        toast({type:"ok", title:"Confirmed", message:"Vault submission confirmed on-chain.", timeout:3400});

        const cb = pendingAfterVault;
        closeVaultModalFn();
        if(typeof cb === "function") cb();
        refreshState().catch(()=>{});
        refreshBalance().catch(()=>{});
      }catch(e){
        vaultStatus.textContent = `Not confirmed yet. If you just submitted in Vault, wait a moment and try again.`;
        toast({type:"info", title:"Not confirmed yet", message:"Wait a moment and try again.", timeout:2600});
      }
    };

    // Login / connect flows
    freighterExtBtn.onclick = async ()=>{
      try{
        const freighter = await ensureFreighterApi();
        if(!freighter){ toast({type:"err", title:"Error", message:"Freighter extension not detected."}); return; }
        let address = "";
        try { address = await freighter.getPublicKey(); } catch {}
        if(!address && freighter.getAddress){ const r=await freighter.getAddress(); address=r?.address||""; }
        if(!address && freighter.requestAccess){ const r=await freighter.requestAccess(); address=r?.address||""; }
        if(!address){ toast({type:"err", title:"Error", message:"Freighter connect denied/failed."}); return; }
        secret = null;
        closeConnectModal();
        setConnected(address, "freighter");
        toast({type:"ok", title:"Connected", message:"Freighter connected."});
      }catch(e){
        console.error(e);
        toast({type:"err", title:"Error", message:"Freighter connect failed."});
      }
    };

    wcBtn.onclick = async ()=>{
      try{
        const sc = await ensureWcClient();
        const { uri, approval } = await sc.connect({
          optionalNamespaces: {
            stellar: { chains:["stellar:pubnet"], methods:["stellar_signXDR","stellar_signAndSubmitXDR"], events:[] }
          }
        });
        if(!uri) throw new Error("No WalletConnect URI");
        latestWcUri = uri;

        const QR = await ensureQrLib();
        await QR.toCanvas(qrCanvas, uri, { width:256, margin:1 });

        qrArea.style.display = "flex";
        rawWcLink.href = uri;

        linkStatus.textContent = "Loading Freighter deep linkâ€¦";
        const freighterLinks = await getFreighterLinks();
        linkStatus.textContent = freighterLinks.found ? "" : "Freighter link not found â€” store fallback.";

        btnLobstr.onclick = ()=> openLobstrApp(latestWcUri);
        btnFreighter.onclick = async ()=>{
          const links = await getFreighterLinks();
          openFreighterSmart(links, latestWcUri);
        };

        wcSession = await approval();

        const accounts = wcSession.namespaces?.stellar?.accounts || [];
        const first = accounts.find(a=>a.startsWith("stellar:pubnet")) || accounts[0] || "";
        const address = first.split(":")[2] || "";
        if(!StellarSdk.StrKey.isValidEd25519PublicKey(address)) throw new Error("WC returned invalid address.");

        wcClient = sc;
        secret = null;
        qrArea.style.display="none";
        closeConnectModal();
        setConnected(address, "wc");
        toast({type:"ok", title:"Connected", message:"WalletConnect connected."});
      }catch(e){
        console.error(e);
        toast({type:"err", title:"Error", message:String(e?.message || "WalletConnect canceled/failed.")});
      }
    };

    disconnectBtn.onclick = async ()=>{
      try{
        if(mode==="wc" && wcClient && wcSession){
          await wcClient.disconnect({ topic: wcSession.topic, reason:{ code:6000, message:"User disconnected" }});
        }
      }catch{}
      wcSession = null;
      wcClient = null;
      secret = null;
      setConnected("", "none");
      toast({type:"ok", title:"Done", message:"Disconnected."});
    };

    usePubkeyBtn.onclick = ()=>{
      const pk = pubkeyEl.value.trim();
      if(!StellarSdk.StrKey.isValidEd25519PublicKey(pk)){
        toast({type:"err", title:"Error", message:"Invalid public key."}); return;
      }
      secret = null;
      setConnected(pk, "pubkey");
      toast({type:"ok", title:"Done", message:"Pubkey set (read-only)."});
    };

    useSecretBtn.onclick = ()=>{
      const sk = seckeyEl.value.trim();
      if(!StellarSdk.StrKey.isValidEd25519SecretSeed(sk)){
        toast({type:"err", title:"Error", message:"Invalid secret key."}); return;
      }
      const kp = StellarSdk.Keypair.fromSecret(sk);
      secret = sk;
      setConnected(kp.publicKey(), "secret");
      toast({type:"ok", title:"Done", message:"Secret key set (local signing)."});
    };

    openExplorerBtn.onclick = ()=>{
      const pk = pubkeyEl.value.trim();
      if(!StellarSdk.StrKey.isValidEd25519PublicKey(pk)) return;
      window.open(`https://stellar.expert/explorer/public/account/${pk}`, "_blank", "noopener,noreferrer");
    };

    addTrustBtn.onclick = async ()=>{
      try{
        if(!pubkey){ openConnectModal(); return; }
        if(mode==="pubkey" || mode==="none") throw new Error("Read-only. Connect a wallet or use secret key.");
        await ensureBUSDCTrustline({ interactive:true });
      }catch(e){
        console.error(e);
        toast({type:"err", title:"Error", message:e.message || String(e)});
      }
    };

    refreshBalBtn.onclick = refreshBalance;
    refreshBtn.onclick = refreshState;

    usdcAvailInline.onclick = ()=>{
      if(typeof availableUSDCScaled !== "bigint") return;
      depositAmt.value = fmtScaledBigint(availableUSDCScaled);
      updateFeeBoxes();
      resetAction("deposit");
      toast({type:"ok", title:"Filled", message:"Deposit amount set to your available USDC."});
    };
    busdcAvailInline.onclick = ()=>{
      if(typeof availableBUSDCScaled !== "bigint") return;
      redeemAmt.value = fmtScaledBigint(availableBUSDCScaled);
      updateFeeBoxes();
      resetAction("redeem");
      toast({type:"ok", title:"Filled", message:"Withdraw amount set to your available bUSDC."});
    };

    depositAmt.addEventListener("input", ()=>{ updateFeeBoxes(); resetAction("deposit"); });
    redeemAmt.addEventListener("input", ()=>{ updateFeeBoxes(); resetAction("redeem"); });

    depPreflightBtn.onclick = ()=> preflight("deposit", depositAmt, depositStatus);
    depPayFeeBtn.onclick    = ()=> payFee("deposit", depositStatus);
    depExecuteBtn.onclick   = ()=> executeInvoke("deposit", depositStatus);

    wdPreflightBtn.onclick  = ()=> preflight("redeem", redeemAmt, redeemStatus);
    wdPayFeeBtn.onclick     = ()=> payFee("redeem", redeemStatus);
    wdExecuteBtn.onclick    = ()=> executeInvoke("redeem", redeemStatus);

    depositXdrToggle.onclick = ()=> toggleTextarea(depositXdr, depositXdrToggle);
    redeemXdrToggle.onclick  = ()=> toggleTextarea(redeemXdr, redeemXdrToggle);

    toggleLogsBtn.onclick = ()=>{
      const hidden = logsEl.style.display === "none" || !logsEl.style.display;
      logsEl.style.display = hidden ? "block" : "none";
      toggleLogsBtn.textContent = hidden ? "Hide logs" : "Show logs";
    };

    // Init
    updateFeeBoxes();
    refreshState().catch(()=>{});
    refreshBalance().catch(()=>{});
    syncActionButtons();
  </script>
</body>
</html>
