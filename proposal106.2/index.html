<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Aquarius Vote Booster Simulator</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: sans-serif; margin: 10px; }
    pre { background: #f9f9f9; padding: 10px; }
    .controls { display: flex; flex-wrap: wrap; gap: 16px; margin-top: 20px; }
    .control { display: flex; flex-direction: column; }
    .control label { margin-bottom: 4px; font-size: 0.9em; }
    .control input { padding: 4px; width: 100px; }
    .chart-container { max-width: 600px; margin-top: 20px; }
    .table-container { overflow-x: auto; margin-top: 40px; }
    table { border-collapse: collapse; width: 100%; min-width: 800px; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
    th { background-color: #f2f2f2; }
    input[type=number] { width: 80px; }
    #totalVotes { margin-top: 20px; font-weight: bold; }
    #apiTotalsContainer { margin-top: 40px; }
    @media (max-width: 600px) {
      .controls { flex-direction: column; }
      .control input { width: 80px; }
      table { min-width: 600px; }
    }
  </style>
</head>
<body>
  <h2>Aquarius Vote Booster Simulator</h2>
  <p>Boost formula (fixed):</p>
  <pre>Boost = 1 + MaxBoost × e<sup>–Bribe / (R_market_cap ÷ Divisor)</sup></pre>

  <div class="controls">
    <div class="control">
      <label for="divisor">Divisor</label>
      <input type="number" id="divisor" value="5" min="1" />
    </div>
    <div class="control">
      <label for="rTotal">R_total (AQUA/day)</label>
      <input type="number" id="rTotal" value="7000000" min="0" />
    </div>
    <div class="control">
      <label for="pCap">P_cap (%)</label>
      <input type="number" id="pCap" value="10" min="0" max="100" />
    </div>
    <div class="control">
      <label for="rMarketCap">R_market_cap</label>
      <input type="text" id="rMarketCap" value="700000" disabled />
    </div>
  </div>

  <div class="chart-container">
    <canvas id="curveChart"></canvas>
  </div>

  <div id="loading">Loading data<span id="dots"></span></div>

  <div class="table-container" id="tableWrapper" style="display:none;">
    <table id="votesTable">
      <thead>
        <tr>
          <th>Market</th>
          <th>Votes</th>
          <th>Static Adj Votes</th>
          <th>Bribes</th>
          <th>Dynamic Boost</th>
          <th>Dampened Adj Votes</th>
          <th>Vote Share</th>
          <th>Vote Share Adjust</th>
          <th>AQUA Rewards</th>
        </tr>
      </thead>
      <tbody></tbody>
      <tfoot>
        <tr>
          <th>Total</th>
          <th id="totalVotesFooterVotes">0</th>
          <th id="totalStaticFooter">0</th>
          <th></th>
          <th></th>
          <th id="totalDampFooter">0</th>
          <th id="totalShareFooter">0%</th>
          <th id="totalShareAdjustFooter">0%</th>
          <th id="totalRewardsFooter">0</th>
        </tr>
      </tfoot>
    </table>
  </div>

  <div id="totalVotes" style="display:none;">Total Votes: 0</div>

  <div id="apiTotalsContainer" style="display:none;">
    <h3>API Vote Totals</h3>
    <table id="apiTotalsTable">
      <tbody>
        <tr><td>AQUA Votes</td><td id="apiAqua">–</td></tr>
        <tr><td>upvoteICE Votes</td><td id="apiUpICE">–</td></tr>
        <tr><td>downvoteICE Votes</td><td id="apiDownICE">–</td></tr>
        <tr><th>Total Votes</th><th id="apiTotal">–</th></tr>
      </tbody>
    </table>
  </div>

  <script>
    // ---- formatting helper ----
    function fmt(num, dec=2) {
      return num.toLocaleString(undefined, {
        minimumFractionDigits: dec,
        maximumFractionDigits: dec
      });
    }

    // ---- Chart.js curve logic ----
    const ctx = document.getElementById('curveChart').getContext('2d');
    let curveChart;
    function computeCurve(maxBoost, rMarketCap, divisor) {
      if (isNaN(rMarketCap) || rMarketCap <= 0) {
        return [{ x: 0, y: 1 + maxBoost }];
      }
      const pts = [];
      const step = rMarketCap / 50;
      for (let b = 0; b <= rMarketCap; b += step) {
        const y = 1 + maxBoost * Math.exp(-b / (rMarketCap / divisor));
        pts.push({ x: b, y });
      }
      return pts;
    }
    function updateChart() {
      let divisor = parseFloat(document.getElementById('divisor').value);
      let rTotal  = parseFloat(document.getElementById('rTotal').value);
      let pCap    = parseFloat(document.getElementById('pCap').value);
      if (isNaN(divisor) || divisor <= 0) divisor = 5;
      if (isNaN(rTotal) || rTotal < 0) rTotal = 0;
      if (isNaN(pCap)   || pCap < 0)   pCap = 0;
      const rMarketCap = rTotal * pCap / 100;
      document.getElementById('rMarketCap').value = fmt(rMarketCap, 2);

      const dataA = computeCurve(0.3, rMarketCap, divisor);
      const dataB = computeCurve(0.5, rMarketCap, divisor);

      if (!curveChart) {
        curveChart = new Chart(ctx, {
          type: 'line',
          data: { datasets: [
            { label: 'MaxBoost 0.3', data: dataA, borderColor: 'blue', fill: false,
              parsing: { xAxisKey: 'x', yAxisKey: 'y' } },
            { label: 'MaxBoost 0.5', data: dataB, borderColor: 'red', fill: false,
              parsing: { xAxisKey: 'x', yAxisKey: 'y' } }
          ] },
          options: {
            scales: {
              x: { type: 'linear', title: { display: true, text: 'Bribe' } },
              y: { title: { display: true, text: 'Boost' } }
            }
          }
        });
      } else {
        curveChart.data.datasets[0].data = dataA;
        curveChart.data.datasets[1].data = dataB;
        curveChart.update();
      }
    }
    ['divisor','rTotal','pCap'].forEach(id =>
      document.getElementById(id).addEventListener('input', updateChart)
    );

    // ---- loading and DOM refs ----
    const API = 'https://voting-tracker.aqua.network/api/voting-snapshot/top-volume/?limit=200';
    const HORIZON = 'https://horizon.stellar.org/accounts/';
    let dot = 0;
    const dotsEl     = document.getElementById('dots');
    const loadingEl  = document.getElementById('loading');
    const wrapperEl  = document.getElementById('tableWrapper');
    const totalEl    = document.getElementById('totalVotes');
    const apiBlock   = document.getElementById('apiTotalsContainer');
    const interval   = setInterval(() => {
      dot = (dot + 1) % 4;
      dotsEl.textContent = '.'.repeat(dot);
    }, 500);

    // ---- data fetching ----
    async function fetchMarkets() {
      let all = [], url = API;
      while (url) {
        const res  = await fetch(url);
        const data = await res.json();
        all.push(...data.results);
        url = data.next;
      }
      return all;
    }
    async function fetchTrustlines(key) {
      try {
        const res  = await fetch(HORIZON + key);
        const json = await res.json();
        const bal  = json.balances || [];
        const hasX = bal.some(b => b.asset_type === 'native');
        const nonX = bal.filter(b=>b.asset_type!=='native')
                        .map(b=>b.asset_code);
        if (nonX.length >= 2)        return nonX;
        if (nonX.length === 1 && hasX) return [ nonX[0], 'XLM' ];
        if (hasX)                     return ['XLM'];
        return nonX;
      } catch {
        return ['XLM'];
      }
    }

    // ---- boost calculations ----
    function calcStatic(assets) {
      let b = 1;
      if (assets.includes('AQUA')) b += 0.5;
      if (assets.includes('XLM'))  b += 0.3;
      if (assets.includes('USDC')) b += 0.3;
      return b;
    }
    function calcDynamic(br, maxBoost) {
      let divisor = parseFloat(document.getElementById('divisor').value);
      let rMarket = parseFloat(document.getElementById('rMarketCap').value);
      if (isNaN(divisor) || divisor <= 0) divisor = 5;
      if (isNaN(rMarket) || rMarket <= 0) return 1 + maxBoost;
      return 1 + maxBoost * Math.exp(-br / (rMarket / divisor));
    }

    // ---- row creation ----
    function createRow(item) {
      const tr = document.createElement('tr');
      const base = item.original;
      const st   = item.staticBoost;
      const initDyn = st;
      // initial damp: use static boost if positive, else raw
      const initDamp = base > 0 ? base * st : base;
      tr.innerHTML = `
        <td>${item.market}</td>
        <td>${fmt(Math.abs(base),2)}</td>
        <td>${base>0?fmt(base*st,2):'0.00'}</td>
        <td><input type="number" value="0" min="0"></td>
        <td>${initDyn.toFixed(5)}</td>
        <td>${fmt(initDamp,2)}</td>
        <td>0.00000%</td>
        <td>0.00000%</td>
        <td>0.00</td>
      `;
      const inp     = tr.querySelector('input');
      const dynCell = tr.cells[4];
      const dampCell= tr.cells[5];

      inp.addEventListener('input', () => {
        const br = parseFloat(inp.value) || 0;
        let dyn;
        if (st > 1.5) {
          dyn = st; // exempt
        } else if (base > 0) {
          dyn = calcDynamic(br, st - 1);
        } else {
          dyn = st;
        }
        dynCell.textContent = dyn.toFixed(5);
        const damp = base > 0 ? base * dyn : base;
        dampCell.textContent = fmt(damp,2);
        updateShares();
      });

      return tr;
    }

    // ---- shares, adjusted shares, rewards, totals ----
    function updateShares() {
      const rows = Array.from(document.querySelectorAll('#votesTable tbody tr'));
      const raw  = rows.map(r => parseFloat(r.cells[5].textContent) || 0);
      const pos  = raw.map(v => (v>0 ? v : 0));
      const sumPos        = pos.reduce((a,b)=>a+b,0) || 0;
      // Vote Share % and find qualifiers ≥0.5%
      let qualifiers = [];
      rows.forEach((r,i) => {
        const pct = sumPos>0 ? (pos[i]/sumPos)*100 : 0;
        const share = pct.toFixed(5)+'%';
        r.cells[6].textContent = share;
        if (pct >= 0.5) qualifiers.push({ row: r, pct });
      });
      // Adjusted shares: re-normalize qualifiers to 100%
      const totalQual = qualifiers.reduce((a,b)=>a+b.pct,0) || 1;
      qualifiers.forEach(q => {
        const adjPct = (q.pct/totalQual)*100;
        q.row.cells[7].textContent = adjPct.toFixed(5)+'%';
      });
      // AQUA Rewards = R_total * (adjusted_pct/100)
      let rTotal = parseFloat(document.getElementById('rTotal').value) || 0;
      qualifiers.forEach(q => {
        const adjPct = parseFloat(q.row.cells[7].textContent) || 0;
        q.row.cells[8].textContent = fmt(rTotal * adjPct/100, 2);
      });
      // Footer totals
      const absVotes = rows.map(r=>parseFloat(r.cells[1].textContent)||0);
      const absDamp  = raw.map(v=>Math.abs(v));
      const sumVotes = absVotes.reduce((a,b)=>a+b,0);
      const sumDamp  = absDamp .reduce((a,b)=>a+b,0);
      const sumShare = rows.reduce((a,r)=>a + (parseFloat(r.cells[6].textContent)||0),0);
      const sumAdj   = qualifiers.reduce((a,q)=>a + (parseFloat(q.row.cells[7].textContent)||0),0);
      const sumRwds  = qualifiers.reduce((a,q)=>a + (parseFloat(q.row.cells[8].textContent)||0),0);
      document.getElementById('totalVotesFooterVotes').textContent    = fmt(sumVotes,2);
      document.getElementById('totalStaticFooter').textContent       = fmt(
        rows.reduce((s,r)=>s + (parseFloat(r.cells[2].textContent)||0),0),2
      );
      document.getElementById('totalDampFooter').textContent         = fmt(sumDamp,2);
      document.getElementById('totalShareFooter').textContent        = sumShare.toFixed(5)+'%';
      document.getElementById('totalShareAdjustFooter').textContent  = sumAdj  .toFixed(5)+'%';
      document.getElementById('totalRewardsFooter').textContent      = fmt(sumRwds,2);
      // show main table
      totalEl.textContent = `Total Votes: ${fmt(sumVotes,2)}`;
      totalEl.style.display = 'block';
    }

    // ---- API Vote Totals fetch ----
    async function fetchApiTotals() {
      let aquaSum    = 0;
      let upICEsum   = 0;
      let downICEsum = 0;
      let url = API;
      while (url) {
        const res  = await fetch(url);
        const data = await res.json();
        (data.results || []).forEach(item => {
          const upAssets   = item.extra?.upvote_assets   || [];
          const downAssets = item.extra?.downvote_assets || [];
          upAssets.forEach(a => {
            const v = parseFloat(a.votes_sum) || 0;
            if (a.asset.startsWith('AQUA:'))      aquaSum   += v;
            else if (a.asset.startsWith('upvoteICE:')) upICEsum += v;
          });
          downAssets.forEach(a => {
            const v = parseFloat(a.votes_sum) || 0;
            if (a.asset.startsWith('downvoteICE:')) downICEsum += v;
          });
        });
        url = data.next;
      }
      document.getElementById('apiAqua').textContent    = fmt(aquaSum,   2);
      document.getElementById('apiUpICE').textContent   = fmt(upICEsum,  2);
      document.getElementById('apiDownICE').textContent = fmt(downICEsum,2);
      document.getElementById('apiTotal').textContent   = fmt(
        aquaSum + upICEsum + downICEsum, 2
      );
      apiBlock.style.display = 'block';
    }

    // ---- init everything ----
    async function init() {
      updateChart();
      const mkts   = await fetchMarkets();
      const assets = await Promise.all(mkts.map(m => fetchTrustlines(m.market_key)));

      const frag = document.createDocumentFragment();
      mkts.forEach((m,i) => {
        const orig = parseFloat(m.votes_value) || 0;
        const st   = calcStatic(assets[i]);
        frag.appendChild(createRow({
          market: assets[i].join(' / '),
          original: orig,
          staticBoost: st
        }));
      });
      document.querySelector('#votesTable tbody').appendChild(frag);
      updateShares();
      clearInterval(interval);
      loadingEl.style.display = 'none';
      wrapperEl.style.display = 'block';

      // now fetch the API vote sums
      await fetchApiTotals();
    }

    init();
  </script>
</body>
</html>
